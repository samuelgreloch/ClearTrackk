#!/usr/bin/env node
/**
 * Relay v12.0.0
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 52);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/interopRequireDefault");

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error


var _interopRequireDefault = __webpack_require__(0);

var _createForOfIteratorHelper2 = _interopRequireDefault(__webpack_require__(4));

var _require = __webpack_require__(8),
    GraphQLError = _require.GraphQLError;

/**
 * Creates an error describing invalid application code (GraphQL/Schema)
 * that must be fixed by the end developer. This should only be used
 * for local errors that don't affect processing of other user code.
 */
function createUserError(message, locations, nodes) {
  var messageWithLocations = message;

  if (locations != null) {
    var printedLocations = printLocations(locations);
    messageWithLocations = printedLocations.length === 0 ? message : [message].concat(printedLocations).join('\n\n') + '\n';
  }

  return new GraphQLError(messageWithLocations, nodes !== null && nodes !== void 0 ? nodes : []);
}
/**
 * Similar to createUserError but for errors that are *not* recoverable:
 * the compiler should not continue to process other inputs because their
 * validity can't be determined.
 */


function createNonRecoverableUserError(message, locations, nodes) {
  var messageWithLocations = message;

  if (locations != null) {
    var printedLocations = printLocations(locations);
    messageWithLocations = printedLocations.length === 0 ? message : [message].concat(printedLocations).join('\n\n') + '\n';
  }

  var error = new GraphQLError(messageWithLocations, nodes !== null && nodes !== void 0 ? nodes : []);
  return new Error(error.message);
}
/**
 * Creates an error describing a problem with the compiler itself - such
 * as a broken invariant - that must be fixed within the compiler.
 */


function createCompilerError(message, locations, nodes) {
  var messageWithLocations = message;

  if (locations != null) {
    var printedLocations = printLocations(locations);
    messageWithLocations = printedLocations.length === 0 ? message : [message].concat(printedLocations).join('\n\n') + '\n';
  }

  var error = new GraphQLError("Internal Error: ".concat(messageWithLocations), nodes !== null && nodes !== void 0 ? nodes : []);
  return new Error(error.message);
}
/**
 * Iterates over the elements of some iterable value, calling the
 * supplied callback for each item with a guard for user errors.
 *
 * Non-user errors abort the iteration and are instantly rethrown.
 * User errors are collected and rethrown at the end, if multiple user errors
 * occur, a combined error is thrown.
 */


function eachWithCombinedError(iterable, fn) {
  var errors = [];

  var _iterator = (0, _createForOfIteratorHelper2["default"])(iterable),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var item = _step.value;

      try {
        fn(item);
      } catch (error) {
        if (error instanceof GraphQLError) {
          errors.push(error);
        } else {
          throw error;
        }
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  if (errors.length > 0) {
    if (errors.length === 1) {
      throw createUserError(String(errors[0]).split('\n').map(function (line, index) {
        return index === 0 ? "- ".concat(line) : "  ".concat(line);
      }).join('\n'));
    }

    throw createUserError("Encountered ".concat(errors.length, " errors:\n") + errors.map(function (error) {
      return String(error).split('\n').map(function (line, index) {
        return index === 0 ? "- ".concat(line) : "  ".concat(line);
      }).join('\n');
    }).join('\n'));
  }
}

function printLocations(locations) {
  var printedLocations = [];

  var _iterator2 = (0, _createForOfIteratorHelper2["default"])(locations),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var location = _step2.value;
      var sourceLocation = location;

      while (sourceLocation.kind === 'Derived') {
        sourceLocation = sourceLocation.source;
      }

      switch (sourceLocation.kind) {
        case 'Source':
          {
            // source location
            var prefix = sourceLocation === location ? 'Source: ' : 'Source (derived): ';
            printedLocations.push(prefix + highlightSourceAtLocation(sourceLocation.source, getLocation(sourceLocation.source, sourceLocation.start)));
            break;
          }

        case 'Generated':
          {
            printedLocations.push('Source: (generated)');
            break;
          }

        case 'Unknown':
          {
            printedLocations.push('Source: (unknown)');
            break;
          }

        default:
          {
            sourceLocation;
            throw createCompilerError("CompilerError: cannot print location '".concat(String(sourceLocation), "'."));
          }
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  return printedLocations;
}
/**
 * Render a helpful description of the location of the error in the GraphQL
 * Source document.
 */


function highlightSourceAtLocation(source, location) {
  var firstLineColumnOffset = source.locationOffset.column - 1;
  var body = whitespace(firstLineColumnOffset) + source.body;
  var lineIndex = location.line - 1;
  var lineOffset = source.locationOffset.line - 1;
  var lineNum = location.line + lineOffset;
  var columnOffset = location.line === 1 ? firstLineColumnOffset : 0;
  var columnNum = location.column + columnOffset;
  var lines = body.split(/\r\n|[\n\r]/g);
  return "".concat(source.name, " (").concat(lineNum, ":").concat(columnNum, ")\n") + printPrefixedLines([// Lines specified like this: ["prefix", "string"],
  ["".concat(lineNum - 1, ": "), lines[lineIndex - 1]], ["".concat(lineNum, ": "), lines[lineIndex]], ['', whitespace(columnNum - 1) + '^'], ["".concat(lineNum + 1, ": "), lines[lineIndex + 1]]]);
}

function printPrefixedLines(lines) {
  var existingLines = lines.filter(function (_ref) {
    var _ = _ref[0],
        line = _ref[1];
    return line !== undefined;
  });
  var padLen = 0;

  var _iterator3 = (0, _createForOfIteratorHelper2["default"])(existingLines),
      _step3;

  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var _step3$value = _step3.value,
          prefix = _step3$value[0];
      padLen = Math.max(padLen, prefix.length);
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }

  return existingLines.map(function (_ref2) {
    var prefix = _ref2[0],
        line = _ref2[1];
    return lpad(padLen, prefix) + line;
  }).join('\n');
}

function whitespace(len) {
  return Array(len + 1).join(' ');
}

function lpad(len, str) {
  return whitespace(len - str.length) + str;
}

function getLocation(source, position) {
  var lineRegexp = /\r\n|[\n\r]/g;
  var line = 1;
  var column = position + 1;
  var match;

  while ((match = lineRegexp.exec(source.body)) && match.index < position) {
    line += 1;
    column = position + 1 - (match.index + match[0].length);
  }

  return {
    line: line,
    column: column
  };
}

module.exports = {
  createCompilerError: createCompilerError,
  createNonRecoverableUserError: createNonRecoverableUserError,
  createUserError: createUserError,
  eachWithCombinedError: eachWithCombinedError
};

/***/ }),
/* 2 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/objectSpread2");

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error


var _interopRequireDefault = __webpack_require__(0);

var _objectSpread2 = _interopRequireDefault(__webpack_require__(2));

var invariant = __webpack_require__(6);

var _require = __webpack_require__(1),
    eachWithCombinedError = _require.eachWithCombinedError;

/**
 * @public
 *
 * Helper for writing compiler transforms that apply "map" and/or "filter"-style
 * operations to compiler contexts. The `visitor` argument accepts a map of IR
 * kinds to user-defined functions that can map nodes of that kind to new values
 * (of the same kind).
 *
 * If a visitor function is defined for a kind, the visitor function is
 * responsible for traversing its children (by calling `this.traverse(node)`)
 * and returning either the input (to indicate no changes), a new node (to
 * indicate changes), or null/undefined (to indicate the removal of that node
 * from the output).
 *
 * If a visitor function is *not* defined for a kind, a default traversal is
 * used to evaluate its children.
 *
 * The `stateInitializer` argument accepts an optional function to construct the
 * state for each document (fragment or root) in the context. Any documents for
 * which the initializer returns null/undefined is deleted from the context
 * without being traversed.
 *
 * Example: Alias all scalar fields with the reverse of their name:
 *
 * ```
 * transform(context, {
 *   ScalarField: visitScalarField,
 * });
 *
 * function visitScalarField(field: ScalarField, state: State): ?ScalarField {
 *   // Traverse child nodes - for a scalar field these are the arguments &
 *   // directives.
 *   const nextField = this.traverse(field, state);
 *   // Return a new node with a different alias.
 *   return {
 *     ...nextField,
 *     alias: nextField.name.split('').reverse().join(''),
 *   };
 * }
 * ```
 */
function transform(context, visitor, stateInitializer) {
  var transformer = new Transformer(context, visitor);
  return context.withMutations(function (ctx) {
    var nextContext = ctx;
    eachWithCombinedError(context.documents(), function (prevNode) {
      var nextNode;

      if (stateInitializer === undefined) {
        nextNode = transformer.visit(prevNode, undefined);
      } else {
        var _state = stateInitializer(prevNode);

        if (_state != null) {
          nextNode = transformer.visit(prevNode, _state);
        }
      }

      if (!nextNode) {
        nextContext = nextContext.remove(prevNode.name);
      } else if (nextNode !== prevNode) {
        nextContext = nextContext.replace(nextNode);
      }
    });
    return nextContext;
  });
}
/**
 * @internal
 */


var Transformer = /*#__PURE__*/function () {
  function Transformer(context, visitor) {
    this._context = context;
    this._states = [];
    this._visitor = visitor;
  }
  /**
   * @public
   *
   * Returns the original compiler context that is being transformed. This can
   * be used to look up fragments by name, for example.
   */


  var _proto = Transformer.prototype;

  _proto.getContext = function getContext() {
    return this._context;
  }
  /**
   * @public
   *
   * Transforms the node, calling a user-defined visitor function if defined for
   * the node's kind. Uses the given state for this portion of the traversal.
   *
   * Note: This differs from `traverse` in that it calls a visitor function for
   * the node itself.
   */
  ;

  _proto.visit = function visit(node, state) {
    this._states.push(state);

    var nextNode = this._visit(node);

    this._states.pop();

    return nextNode;
  }
  /**
   * @public
   *
   * Transforms the children of the given node, skipping the user-defined
   * visitor function for the node itself. Uses the given state for this portion
   * of the traversal.
   *
   * Note: This differs from `visit` in that it does not call a visitor function
   * for the node itself.
   */
  ;

  _proto.traverse = function traverse(node, state) {
    this._states.push(state);

    var nextNode = this._traverse(node);

    this._states.pop();

    return nextNode;
  };

  _proto._visit = function _visit(node) {
    var nodeVisitor = this._visitor[node.kind];

    if (nodeVisitor) {
      // If a handler for the kind is defined, it is responsible for calling
      // `traverse` to transform children as necessary.
      var _state2 = this._getState();

      var nextNode = nodeVisitor.call(this, node, _state2);
      return nextNode;
    } // Otherwise traverse is called automatically.


    return this._traverse(node);
  };

  _proto._traverse = function _traverse(prevNode) {
    var nextNode;

    switch (prevNode.kind) {
      case 'Argument':
        nextNode = this._traverseChildren(prevNode, null, ['value']);
        break;

      case 'Literal':
      case 'LocalArgumentDefinition':
      case 'RootArgumentDefinition':
      case 'Variable':
        nextNode = prevNode;
        break;

      case 'Defer':
        nextNode = this._traverseChildren(prevNode, ['selections'], ['if']);
        break;

      case 'Stream':
        nextNode = this._traverseChildren(prevNode, ['selections'], ['if', 'initialCount']);
        break;

      case 'ClientExtension':
        nextNode = this._traverseChildren(prevNode, ['selections']);
        break;

      case 'Directive':
        nextNode = this._traverseChildren(prevNode, ['args']);
        break;

      case 'ModuleImport':
        nextNode = this._traverseChildren(prevNode, ['selections']);

        if (!nextNode.selections.length) {
          nextNode = null;
        }

        break;

      case 'FragmentSpread':
      case 'ScalarField':
        nextNode = this._traverseChildren(prevNode, ['args', 'directives']);
        break;

      case 'InlineDataFragmentSpread':
        nextNode = this._traverseChildren(prevNode, ['selections']);
        break;

      case 'LinkedField':
        nextNode = this._traverseChildren(prevNode, ['args', 'directives', 'selections']);

        if (!nextNode.selections.length) {
          nextNode = null;
        }

        break;

      case 'ListValue':
        nextNode = this._traverseChildren(prevNode, ['items']);
        break;

      case 'ObjectFieldValue':
        nextNode = this._traverseChildren(prevNode, null, ['value']);
        break;

      case 'ObjectValue':
        nextNode = this._traverseChildren(prevNode, ['fields']);
        break;

      case 'Condition':
        nextNode = this._traverseChildren(prevNode, ['directives', 'selections'], ['condition']);

        if (!nextNode.selections.length) {
          nextNode = null;
        }

        break;

      case 'InlineFragment':
        nextNode = this._traverseChildren(prevNode, ['directives', 'selections']);

        if (!nextNode.selections.length) {
          nextNode = null;
        }

        break;

      case 'Fragment':
      case 'Root':
        nextNode = this._traverseChildren(prevNode, ['argumentDefinitions', 'directives', 'selections']);
        break;

      case 'Request':
        nextNode = this._traverseChildren(prevNode, null, ['fragment', 'root']);
        break;

      case 'SplitOperation':
        nextNode = this._traverseChildren(prevNode, ['selections']);
        break;

      default:
        prevNode;
         true ?  true ? invariant(false, 'IRTransformer: Unknown kind `%s`.', prevNode.kind) : undefined : undefined;
    }

    return nextNode;
  };

  _proto._traverseChildren = function _traverseChildren(prevNode, pluralKeys, singularKeys) {
    var _this = this;

    var nextNode;
    pluralKeys && pluralKeys.forEach(function (key) {
      var prevItems = prevNode[key];

      if (!prevItems) {
        return;
      }

      !Array.isArray(prevItems) ?  true ? invariant(false, 'IRTransformer: Expected data for `%s` to be an array, got `%s`.', key, prevItems) : undefined : void 0;

      var nextItems = _this._map(prevItems);

      if (nextNode || nextItems !== prevItems) {
        nextNode = nextNode || (0, _objectSpread2["default"])({}, prevNode);
        nextNode[key] = nextItems;
      }
    });
    singularKeys && singularKeys.forEach(function (key) {
      var prevItem = prevNode[key];

      if (!prevItem) {
        return;
      }

      var nextItem = _this._visit(prevItem);

      if (nextNode || nextItem !== prevItem) {
        nextNode = nextNode || (0, _objectSpread2["default"])({}, prevNode);
        nextNode[key] = nextItem;
      }
    });
    return nextNode || prevNode;
  };

  _proto._map = function _map(prevItems) {
    var _this2 = this;

    var nextItems;
    prevItems.forEach(function (prevItem, index) {
      var nextItem = _this2._visit(prevItem);

      if (nextItems || nextItem !== prevItem) {
        nextItems = nextItems || prevItems.slice(0, index);

        if (nextItem) {
          nextItems.push(nextItem);
        }
      }
    });
    return nextItems || prevItems;
  };

  _proto._getState = function _getState() {
    !this._states.length ?  true ? invariant(false, 'IRTransformer: Expected a current state to be set but found none. ' + 'This is usually the result of mismatched number of pushState()/popState() ' + 'calls.') : undefined : void 0;
    return this._states[this._states.length - 1];
  };

  return Transformer;
}();

module.exports = {
  transform: transform
};

/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/createForOfIteratorHelper");

/***/ }),
/* 5 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/toConsumableArray");

/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = require("invariant");

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error


var _asyncToGenerator = __webpack_require__(12);

var invariant = __webpack_require__(6);
/**
 * The compiler profiler builds a "call graph" of high level operations as a
 * means of tracking time spent over the course of running the compiler.
 */


var enabled = false;
var traces = [{
  ph: 'M',
  pid: 0,
  tid: 0,
  name: 'process_name',
  args: {
    name: 'relay-compiler'
  }
}, {
  ph: 'M',
  pid: 0,
  tid: 0,
  name: 'thread_name',
  args: {
    name: 'relay-compiler'
  }
}];
var stack = [];

function enable() {
  enabled = true;
}

function getTraces() {
  return traces;
}
/**
 * Run the provided function as part of a stack profile.
 */


function run(name, fn) {
  return instrument(fn, name)();
}
/**
 * Run the provided async function as part context in a stack profile.
 * See instrumentAsyncContext() for limitations and usage notes.
 */


function asyncContext(name, fn) {
  return instrumentAsyncContext(fn, name)();
}
/**
 * Wait for the provided async operation as an async profile.
 */


function waitFor(name, fn) {
  return instrumentWait(fn, name)();
}
/**
 * Return a new instrumented sync function to be part of a stack profile.
 *
 * This instruments synchronous functions to be displayed in a stack
 * visualization. To instrument async functions, see instrumentAsyncContext()
 * and instrumentWait().
 */


function instrument(fn, name) {
  var _ref;

  if (!enabled) {
    return fn;
  }

  var profileName = (_ref = name !== null && name !== void 0 ? name : // $FlowFixMe[prop-missing] - Flow no longer considers statics of functions as any
  fn.displayName) !== null && _ref !== void 0 ? _ref : fn.name;

  var instrumented = function instrumented() {
    var traceId = start(profileName);

    try {
      return fn.apply(this, arguments);
    } finally {
      end(traceId);
    }
  };

  instrumented.displayName = profileName;
  return instrumented;
}
/**
 * Return a new instrumented async function which provides context for a stack.
 *
 * Because the resulting profiling information will be incorporated into a
 * stack visualization, the instrumented function must represent a distinct
 * region of time which does not overlap with any other async context.
 *
 * In other words, functions instrumented with instrumentAsyncContext must not
 * run in parallel via Promise.all().
 *
 * To instrument functions which will run in parallel, use instrumentWait().
 */


function instrumentAsyncContext(fn, name) {
  var _ref2;

  if (!enabled) {
    return fn;
  }

  var profileName = (_ref2 = name !== null && name !== void 0 ? name : // $FlowFixMe[prop-missing] - Flow no longer considers statics of functions as any
  fn.displayName) !== null && _ref2 !== void 0 ? _ref2 : fn.name;

  var instrumented = /*#__PURE__*/function () {
    var _instrumented = _asyncToGenerator(function* () {
      var traceId = start(profileName);

      try {
        return yield fn.apply(this, arguments);
      } finally {
        end(traceId);
      }
    });

    function instrumented() {
      return _instrumented.apply(this, arguments);
    }

    return instrumented;
  }();

  instrumented.displayName = profileName;
  return instrumented;
}
/**
 * Return a new instrumented function which performs an awaited async operation.
 *
 * The instrumented function is not included in the overall run time of the
 * compiler, instead it captures the time waiting on some asynchronous external
 * resource such as network or filesystem which are often run in parallel.
 */


function instrumentWait(fn, name) {
  var _ref3;

  if (!enabled) {
    return fn;
  }

  var profileName = (_ref3 = name !== null && name !== void 0 ? name : // $FlowFixMe[prop-missing] - Flow no longer considers statics of functions as any
  fn.displayName) !== null && _ref3 !== void 0 ? _ref3 : fn.name;

  var instrumented = /*#__PURE__*/function () {
    var _instrumented2 = _asyncToGenerator(function* () {
      var traceId = startWait(profileName);

      try {
        return yield fn.apply(this, arguments);
      } finally {
        end(traceId);
      }
    });

    function instrumented() {
      return _instrumented2.apply(this, arguments);
    }

    return instrumented;
  }();

  instrumented.displayName = profileName;
  return instrumented;
}

var T_ZERO = process.hrtime(); // Return a Uint32 of microtime duration since program start.

function microtime() {
  var hrtime = process.hrtime(T_ZERO); // eslint-disable-next-line no-bitwise

  return 0 | hrtime[0] * 1e6 + Math.round(hrtime[1] / 1e3);
}
/**
 * Start a stack profile with a particular name, returns an ID to pass to end().
 *
 * Other profiles may start before this one ends, which will be represented as
 * nested operations, however all nested operations must end before this ends.
 *
 * In particular, be careful to end after errors.
 */


function start(name) {
  var beginTrace = {
    ph: 'B',
    name: name,
    pid: 0,
    tid: 0,
    ts: microtime()
  };
  traces.push(beginTrace);
  stack.push(beginTrace);
  return traces.length - 1;
}

var asyncID = 0;
/**
 * Start an async wait profile with a particular name, returns an ID to pass
 * to end().
 *
 * Other profiles may start before this one ends, which will be represented as
 * nested operations, however all nested operations must end before this ends.
 *
 * In particular, be careful to end after errors.
 */

function startWait(name) {
  traces.push({
    ph: 'b',
    name: name,
    cat: 'wait',
    id: asyncID++,
    pid: 0,
    tid: 0,
    ts: microtime()
  });
  return traces.length - 1;
}

function end(traceIdx) {
  var trace = traces[traceIdx];

  if (trace.ph === 'b') {
    traces.push({
      ph: 'e',
      cat: trace.cat,
      name: trace.name,
      id: trace.id,
      pid: trace.pid,
      tid: trace.tid,
      ts: microtime()
    });
    return;
  }

  !(trace.ph === 'B') ?  true ? invariant(false, 'Begin trace phase') : undefined : void 0;
  !(stack.pop() === trace) ?  true ? invariant(false, 'GraphQLCompilerProfiler: The profile trace %s ended before nested traces. ' + 'If it is async, try using Profile.waitFor or Profile.profileWait.', trace.name) : undefined : void 0;
  var prevTrace = traces[traces.length - 1];

  if (trace === prevTrace) {
    traces[traceIdx] = {
      ph: 'X',
      name: trace.name,
      pid: trace.pid,
      tid: trace.tid,
      ts: trace.ts,
      dur: microtime() - trace.ts
    };
    return;
  }

  traces.push({
    ph: 'E',
    name: trace.name,
    pid: trace.pid,
    tid: trace.tid,
    ts: microtime()
  });
}

module.exports = {
  enable: enable,
  getTraces: getTraces,
  run: run,
  asyncContext: asyncContext,
  waitFor: waitFor,
  instrument: instrument,
  instrumentAsyncContext: instrumentAsyncContext,
  instrumentWait: instrumentWait,
  start: start,
  startWait: startWait,
  end: end
};

/***/ }),
/* 8 */
/***/ (function(module, exports) {

module.exports = require("graphql");

/***/ }),
/* 9 */
/***/ (function(module, exports) {

module.exports = require("path");

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error


var _require = __webpack_require__(1),
    createCompilerError = _require.createCompilerError;

var ID = 'id';
/**
 * @public
 *
 * Determine if an AST node contains a fragment/operation definition.
 */

function isExecutableDefinitionAST(ast) {
  return ast.kind === 'FragmentDefinition' || ast.kind === 'OperationDefinition';
}
/**
 * @public
 *
 * Determine if an AST node contains a schema definition.
 */


function isSchemaDefinitionAST(ast) {
  return ast.kind === 'SchemaDefinition' || ast.kind === 'ScalarTypeDefinition' || ast.kind === 'ObjectTypeDefinition' || ast.kind === 'InterfaceTypeDefinition' || ast.kind === 'UnionTypeDefinition' || ast.kind === 'EnumTypeDefinition' || ast.kind === 'InputObjectTypeDefinition' || ast.kind === 'DirectiveDefinition' || ast.kind === 'ScalarTypeExtension' || ast.kind === 'ObjectTypeExtension' || ast.kind === 'InterfaceTypeExtension' || ast.kind === 'UnionTypeExtension' || ast.kind === 'EnumTypeExtension' || ast.kind === 'InputObjectTypeExtension';
}
/**
 * Generates an id field on the given type.
 */


function generateIDField(schema, type) {
  var idField = schema.getFieldByName(type, 'id');

  if (idField == null) {
    throw new createCompilerError("Expected an 'id' field on type '".concat(schema.getTypeString(type), "'."));
  }

  var idType = schema.assertScalarFieldType(schema.getFieldType(idField));
  return {
    kind: 'ScalarField',
    alias: ID,
    args: [],
    directives: [],
    handles: null,
    loc: {
      kind: 'Generated'
    },
    metadata: null,
    name: ID,
    type: idType
  };
}

function getNullableBooleanInput(schema) {
  return schema.assertInputType(schema.expectBooleanType());
}

function getNonNullBooleanInput(schema) {
  return schema.assertInputType(schema.getNonNullType(schema.expectBooleanType()));
}

function getNullableStringInput(schema) {
  return schema.assertInputType(schema.expectStringType());
}

function getNonNullStringInput(schema) {
  return schema.assertInputType(schema.getNonNullType(schema.expectStringType()));
}

function getNullableIdInput(schema) {
  return schema.assertInputType(schema.expectIdType());
}

function getNonNullIdInput(schema) {
  return schema.assertInputType(schema.getNonNullType(schema.expectIdType()));
}

module.exports = {
  generateIDField: generateIDField,
  isExecutableDefinitionAST: isExecutableDefinitionAST,
  isSchemaDefinitionAST: isSchemaDefinitionAST,
  getNullableBooleanInput: getNullableBooleanInput,
  getNonNullBooleanInput: getNonNullBooleanInput,
  getNullableStringInput: getNullableStringInput,
  getNonNullStringInput: getNonNullStringInput,
  getNullableIdInput: getNullableIdInput,
  getNonNullIdInput: getNonNullIdInput
};

/***/ }),
/* 11 */
/***/ (function(module, exports) {

module.exports = require("relay-runtime");

/***/ }),
/* 12 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/asyncToGenerator");

/***/ }),
/* 13 */
/***/ (function(module, exports) {

module.exports = require("fs");

/***/ }),
/* 14 */
/***/ (function(module, exports) {

module.exports = require("crypto");

/***/ }),
/* 15 */
/***/ (function(module, exports) {

module.exports = require("immutable");

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error

/**
 * Partitions an array given a predicate. All elements satisfying the predicate
 * are part of the first returned array, and all elements that don't are in the
 * second.
 */

function partitionArray(array, predicate) {
  var first = [];
  var second = [];

  for (var i = 0; i < array.length; i++) {
    var item = array[i];

    if (predicate(item)) {
      first.push(item);
    } else {
      second.push(item);
    }
  }

  return [first, second];
}

module.exports = partitionArray;

/***/ }),
/* 17 */
/***/ (function(module, exports) {

module.exports = require("nullthrows");

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error


var _require = __webpack_require__(1),
    createCompilerError = _require.createCompilerError;

function generateAbstractTypeRefinementKey(schema, type) {
  if (!schema.isAbstractType(type)) {
    throw createCompilerError('Expected an abstract type');
  }

  return "__is".concat(schema.getTypeString(type));
}

module.exports = generateAbstractTypeRefinementKey;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error


var _require = __webpack_require__(8),
    visit = _require.visit;

var NodeKeys = {
  Argument: ['value'],
  ClientExtension: ['selections'],
  Condition: ['condition', 'selections'],
  Defer: ['selections', 'if'],
  Directive: ['args'],
  Fragment: ['argumentDefinitions', 'directives', 'selections'],
  FragmentSpread: ['args', 'directives'],
  InlineDataFragmentSpread: ['selections'],
  InlineFragment: ['directives', 'selections'],
  LinkedField: ['args', 'directives', 'selections'],
  Literal: [],
  LocalArgumentDefinition: [],
  ModuleImport: ['selections'],
  Request: ['fragment', 'root'],
  Root: ['argumentDefinitions', 'directives', 'selections'],
  RootArgumentDefinition: [],
  ScalarField: ['args', 'directives'],
  SplitOperation: ['selections'],
  Stream: ['selections', 'if', 'initialCount'],
  Variable: []
};

function visitIR(root, visitor) {
  return visit(root, visitor, NodeKeys);
}

module.exports = {
  visit: visitIR
};

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error


// Copy of Variables type from '../../../react-relay/classic/tools/RelayTypes'
// Duplicating here rather than importing it since we can't take on a dependency
// outside of relay-compiler.
function getLiteralArgumentValues(args) {
  var values = {};
  args.forEach(function (arg) {
    if (arg.value.kind === 'Literal') {
      values[arg.name] = arg.value.value;
    }
  });
  return values;
}

module.exports = getLiteralArgumentValues;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error


var _interopRequireDefault = __webpack_require__(0);

var _createForOfIteratorHelper2 = _interopRequireDefault(__webpack_require__(4));

var _objectSpread2 = _interopRequireDefault(__webpack_require__(2));

var CompilerContext = __webpack_require__(24);

var IRVisitor = __webpack_require__(19);

var SchemaUtils = __webpack_require__(10);

var _require = __webpack_require__(1),
    createCompilerError = _require.createCompilerError;

/**
 * Returns a transformed version of the input context where each document's
 * argument definitions are updated to accurately describe the root variables
 * used (or reachable) from that document:
 * - Fragment argument definitions are updated to include local argument
 *   definitions and any root variables that are referenced
 *   by the fragment (or any fragments it transitively spreads).
 * - Root argument definitions are updated to reflect the variables
 *   referenced locally and all root variables referenced by any
 *   fragments it (transitively) spreads.
 */
function inferRootArgumentDefinitions(context) {
  // This transform does two main tasks:
  // - Determine the set of root variables referenced locally in each
  //   fragment. Note that RootArgumentDefinitions in the fragment's
  //   argumentDefinitions can contain spurious entries for legacy
  //   reasons. Instead of using those the fragment is traversed
  //   to reanalyze variable usage.
  // - Determine the set of root variables that are transitively referenced
  //   by each fragment, ie the union of all root variables used in the
  //   fragment and any fragments it transitively spreads.
  // Cache fragments as they are transformed to avoid duplicate processing.
  // Because @argument values don't matter (only variable names/types),
  // each reachable fragment only has to be checked once.
  var transformed = new Map();
  var nextContext = new CompilerContext(context.getSchema());
  return nextContext.addAll(Array.from(context.documents(), function (node) {
    switch (node.kind) {
      case 'Fragment':
        {
          var argumentDefinitions = transformFragmentArguments(context, transformed, node);
          return (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, node), {}, {
            argumentDefinitions: Array.from(argumentDefinitions.values())
          });
        }

      case 'Root':
        {
          return transformRoot(context, transformed, node);
        }

      case 'SplitOperation':
        {
          return node;
        }

      default:
        {
          node;
          throw createCompilerError("inferRootArgumentDefinitions: Unsupported kind '".concat(node.kind, "'."));
        }
    }
  }));
}

function transformRoot(context, transformed, root) {
  // Ignore argument definitions, determine what root variables are
  // transitively referenced
  var argumentDefinitions = new Map();
  var localArgumentDefinitions = new Map();

  var _iterator = (0, _createForOfIteratorHelper2["default"])(root.argumentDefinitions.entries()),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _step$value = _step.value,
          name = _step$value[0],
          argDef = _step$value[1];

      if (argDef.kind === 'LocalArgumentDefinition') {
        localArgumentDefinitions.set(name, argDef);
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  visit(context, transformed, argumentDefinitions, root);
  return (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, root), {}, {
    argumentDefinitions: Array.from(argumentDefinitions.values(), function (argDef) {
      var _localDefinition$type, _localDefinition$defa;

      if (argDef.kind !== 'RootArgumentDefinition') {
        throw createCompilerError("inferRootArgumentDefinitions: Expected inferred variable '$".concat(argDef.name, "' to be a root variables."), [argDef.loc]);
      }

      var localDefinition = localArgumentDefinitions.get(argDef.name);
      var type = (_localDefinition$type = localDefinition === null || localDefinition === void 0 ? void 0 : localDefinition.type) !== null && _localDefinition$type !== void 0 ? _localDefinition$type : argDef.type;
      return {
        defaultValue: (_localDefinition$defa = localDefinition === null || localDefinition === void 0 ? void 0 : localDefinition.defaultValue) !== null && _localDefinition$defa !== void 0 ? _localDefinition$defa : null,
        kind: 'LocalArgumentDefinition',
        loc: argDef.loc,
        name: argDef.name,
        type: type
      };
    })
  });
}

function transformFragmentArguments(context, transformed, fragment) {
  var name = fragment.name;
  var transformedArguments = transformed.get(name);

  if (transformedArguments != null) {
    return transformedArguments;
  } // Start with only the explicitly defined local arguments, recover the
  // correct set of root variables excluding invalid @arguments values.


  var argumentDefinitions = new Map();
  fragment.argumentDefinitions.forEach(function (argDef) {
    if (argDef.kind === 'LocalArgumentDefinition') {
      argumentDefinitions.set(argDef.name, argDef);
    }
  }); // Break cycles by initially caching a version that only has local
  // arguments. If the current fragment is reached again, it won't have
  // any root variables to add to its parents. The traversal below will
  // find any root variables and update the cached version of the
  // fragment.

  transformed.set(name, argumentDefinitions);
  visit(context, transformed, argumentDefinitions, fragment);
  transformed.set(name, argumentDefinitions);
  return argumentDefinitions;
}

function visit(context, transformed, argumentDefinitions, node) {
  IRVisitor.visit(node, {
    FragmentSpread: function FragmentSpread(fragmentSpread) {
      var fragment = context.getFragment(fragmentSpread.name, fragmentSpread.loc);
      var referencedFragmentArguments = transformFragmentArguments(context, transformed, fragment); // Detect root variables being passed as the value of @arguments;
      // recover the expected type from the corresponding argument definitions.

      fragmentSpread.args.forEach(function (arg) {
        var argDef = referencedFragmentArguments.get(arg.name);

        if (argDef != null && arg.value.kind === 'Variable' && !argumentDefinitions.has(arg.value.variableName)) {
          argumentDefinitions.set(arg.value.variableName, {
            kind: 'RootArgumentDefinition',
            loc: {
              kind: 'Derived',
              source: arg.loc
            },
            name: arg.value.variableName,
            type: argDef.type
          });
        }
      }); // Merge any root variables referenced by the spread fragment
      // into this (parent) fragment's arguments.

      var _iterator2 = (0, _createForOfIteratorHelper2["default"])(referencedFragmentArguments.values()),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var argDef = _step2.value;

          if (argDef.kind === 'RootArgumentDefinition') {
            argumentDefinitions.set(argDef.name, argDef);
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    },
    Argument: function Argument(argument) {
      if (argument.value.kind === 'Literal') {
        return false;
      }

      var values = [argument.value];

      while (values.length > 0) {
        var currentValue = values.pop();

        if (currentValue.kind === 'Variable') {
          var _currentValue$type;

          var type = (_currentValue$type = currentValue.type) !== null && _currentValue$type !== void 0 ? _currentValue$type : argument.type;

          if (type == null) {
            continue;
          }

          if (!argumentDefinitions.has(currentValue.variableName)) {
            // root variable
            argumentDefinitions.set(currentValue.variableName, {
              kind: 'RootArgumentDefinition',
              loc: {
                kind: 'Derived',
                source: argument.loc
              },
              name: currentValue.variableName,
              type: type
            });
          }
        } else if (currentValue.kind === 'ObjectValue') {
          currentValue.fields.forEach(function (fieldValue) {
            if (fieldValue.value.kind !== 'Literal') {
              values.push(fieldValue.value);
            }
          });
        } else if (currentValue.kind === 'ListValue') {
          currentValue.items.forEach(function (listValue) {
            if (listValue.kind !== 'Literal') {
              values.push(listValue);
            }
          });
        }
      }

      return false;
    },
    Condition: function Condition(condition) {
      var _variable$type;

      var variable = condition.condition;

      if (variable.kind !== 'Variable') {
        return;
      }

      var type = (_variable$type = variable.type) !== null && _variable$type !== void 0 ? _variable$type : SchemaUtils.getNonNullBooleanInput(context.getSchema());

      if (!argumentDefinitions.has(variable.variableName)) {
        // root variable
        argumentDefinitions.set(variable.variableName, {
          kind: 'RootArgumentDefinition',
          loc: {
            kind: 'Derived',
            source: variable.loc
          },
          name: variable.variableName,
          type: type
        });
      }
    },
    Defer: function Defer(defer) {
      var _variable$type2;

      var variable = defer["if"];

      if (variable == null || variable.kind !== 'Variable') {
        return;
      }

      var type = (_variable$type2 = variable.type) !== null && _variable$type2 !== void 0 ? _variable$type2 : SchemaUtils.getNonNullBooleanInput(context.getSchema());

      if (!argumentDefinitions.has(variable.variableName)) {
        // root variable
        argumentDefinitions.set(variable.variableName, {
          kind: 'RootArgumentDefinition',
          loc: {
            kind: 'Derived',
            source: variable.loc
          },
          name: variable.variableName,
          type: type
        });
      }
    },
    Stream: function Stream(stream) {
      [stream["if"], stream.initialCount].forEach(function (variable) {
        var _variable$type3;

        if (variable == null || variable.kind !== 'Variable') {
          return;
        }

        var type = (_variable$type3 = variable.type) !== null && _variable$type3 !== void 0 ? _variable$type3 : SchemaUtils.getNonNullBooleanInput(context.getSchema());

        if (!argumentDefinitions.has(variable.variableName)) {
          // root variable
          argumentDefinitions.set(variable.variableName, {
            kind: 'RootArgumentDefinition',
            loc: {
              kind: 'Derived',
              source: variable.loc
            },
            name: variable.variableName,
            type: type
          });
        }
      });
    },
    LinkedField: function LinkedField(field) {
      if (!field.handles) {
        return;
      }

      field.handles.forEach(function (handle) {
        var _variable$type4;

        var variable = handle.dynamicKey;

        if (variable == null) {
          return;
        }

        var type = (_variable$type4 = variable.type) !== null && _variable$type4 !== void 0 ? _variable$type4 : SchemaUtils.getNullableStringInput(context.getSchema());

        if (!argumentDefinitions.has(variable.variableName)) {
          // root variable
          argumentDefinitions.set(variable.variableName, {
            kind: 'RootArgumentDefinition',
            loc: {
              kind: 'Derived',
              source: variable.loc
            },
            name: variable.variableName,
            type: type
          });
        }
      });
    }
  });
}

module.exports = inferRootArgumentDefinitions;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error


var _interopRequireDefault = __webpack_require__(0);

var _createForOfIteratorHelper2 = _interopRequireDefault(__webpack_require__(4));

function buildFragmentSpread(fragment) {
  var args = [];

  var _iterator = (0, _createForOfIteratorHelper2["default"])(fragment.argumentDefinitions),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var argDef = _step.value;

      if (argDef.kind !== 'LocalArgumentDefinition') {
        continue;
      }

      args.push({
        kind: 'Argument',
        loc: {
          kind: 'Derived',
          source: argDef.loc
        },
        name: argDef.name,
        type: argDef.type,
        value: {
          kind: 'Variable',
          loc: {
            kind: 'Derived',
            source: argDef.loc
          },
          variableName: argDef.name,
          type: argDef.type
        }
      });
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return {
    args: args,
    directives: [],
    kind: 'FragmentSpread',
    loc: {
      kind: 'Derived',
      source: fragment.loc
    },
    metadata: null,
    name: fragment.name
  };
}

function buildOperationArgumentDefinitions(argumentDefinitions) {
  var localArgumentDefinitions = argumentDefinitions.map(function (argDef) {
    if (argDef.kind === 'LocalArgumentDefinition') {
      return argDef;
    } else {
      return {
        kind: 'LocalArgumentDefinition',
        name: argDef.name,
        type: argDef.type,
        defaultValue: null,
        loc: argDef.loc
      };
    }
  });
  localArgumentDefinitions.sort(function (a, b) {
    return a.name < b.name ? -1 : a.name > b.name ? 1 : 0;
  });
  return localArgumentDefinitions;
}

module.exports = {
  buildFragmentSpread: buildFragmentSpread,
  buildOperationArgumentDefinitions: buildOperationArgumentDefinitions
};

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 * @emails oncall+relay
 */
// flowlint ambiguous-object-type:error


var _asyncToGenerator = __webpack_require__(12);

var childProcess = __webpack_require__(57);

var watchman = __webpack_require__(58);

var MAX_ATTEMPT_LIMIT = 5;

function delay(delayMs) {
  return new Promise(function (resolve) {
    return setTimeout(resolve, delayMs);
  });
}

var GraphQLWatchmanClient = /*#__PURE__*/function () {
  GraphQLWatchmanClient.isAvailable = function isAvailable() {
    return new Promise(function (resolve) {
      // This command not only will verify that watchman CLI is available
      // More than that `watchman version` is a command that runs on the server.
      // And it can tell us that watchman is up and running
      // Also `watchman version` check ``relative_root`` capability
      // under the covers
      var proc = childProcess.spawn('watchman', ['version']);
      proc.on('error', function () {
        resolve(false);
      });
      proc.on('close', function (code) {
        resolve(code === 0);
      });
    });
  };

  function GraphQLWatchmanClient() {
    var attemptLimit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    this._client = new watchman.Client();
    this._attemptLimit = Math.max(Math.min(MAX_ATTEMPT_LIMIT, attemptLimit), 0);
  }

  var _proto = GraphQLWatchmanClient.prototype;

  _proto._command = function _command() {
    var _this = this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return new Promise(function (resolve, reject) {
      _this._client.command(args, function (error, response) {
        if (error) {
          reject(error);
        } else {
          resolve(response);
        }
      });
    });
  };

  _proto.command = /*#__PURE__*/function () {
    var _command2 = _asyncToGenerator(function* () {
      var attempt = 0;

      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      while (true) {
        try {
          attempt++;
          return yield this._command.apply(this, args);
        } catch (error) {
          if (attempt > this._attemptLimit) {
            throw error;
          }

          yield delay(Math.pow(2, attempt) * 500);

          this._client.end();

          this._client = new watchman.Client();
        }
      }
    });

    function command() {
      return _command2.apply(this, arguments);
    }

    return command;
  }();

  _proto.hasCapability = /*#__PURE__*/function () {
    var _hasCapability = _asyncToGenerator(function* (capability) {
      var resp = yield this.command('list-capabilities');
      return resp.capabilities.includes(capability);
    });

    function hasCapability(_x) {
      return _hasCapability.apply(this, arguments);
    }

    return hasCapability;
  }();

  _proto.watchProject = /*#__PURE__*/function () {
    var _watchProject = _asyncToGenerator(function* (baseDir) {
      var resp = yield this.command('watch-project', baseDir);

      if ('warning' in resp) {
        console.error('Warning:', resp.warning);
      }

      return {
        root: resp.watch,
        relativePath: resp.relative_path
      };
    });

    function watchProject(_x2) {
      return _watchProject.apply(this, arguments);
    }

    return watchProject;
  }();

  _proto.on = function on(event, callback) {
    this._client.on(event, callback);
  };

  _proto.end = function end() {
    this._client.end();
  };

  return GraphQLWatchmanClient;
}();

module.exports = GraphQLWatchmanClient;

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error


var Profiler = __webpack_require__(7);

var invariant = __webpack_require__(6);

var _require = __webpack_require__(1),
    createUserError = _require.createUserError; // $FlowFixMe[untyped-import] - immutable.js is not flow-typed


var _require2 = __webpack_require__(15),
    ImmutableOrderedMap = _require2.OrderedMap;

/**
 * An immutable representation of a corpus of documents being compiled together.
 * For each document, the context stores the IR and any validation errors.
 */
var CompilerContext = /*#__PURE__*/function () {
  // $FlowFixMe[value-as-type]
  function CompilerContext(schema) {
    this._isMutable = false;
    this._documents = new ImmutableOrderedMap();
    this._withTransform = new WeakMap();
    this._schema = schema;
  }
  /**
   * Returns the documents for the context in the order they were added.
   */


  var _proto = CompilerContext.prototype;

  _proto.documents = function documents() {
    return this._documents.toArray();
  };

  _proto.forEachDocument = function forEachDocument(fn) {
    this._documents.forEach(fn);
  };

  _proto.replace = function replace(node) {
    return this._update(this._documents.update(node.name, function (existing) {
      !existing ?  true ? invariant(false, 'CompilerContext: Expected to replace existing node %s, but ' + 'one was not found in the context.', node.name) : undefined : void 0;
      return node;
    }));
  };

  _proto.add = function add(node) {
    return this._update(this._documents.update(node.name, function (existing) {
      !!existing ?  true ? invariant(false, 'CompilerContext: Duplicate document named `%s`. GraphQL ' + 'fragments and roots must have unique names.', node.name) : undefined : void 0;
      return node;
    }));
  };

  _proto.addAll = function addAll(nodes) {
    return this.withMutations(function (mutable) {
      return nodes.reduce(function (ctx, definition) {
        return ctx.add(definition);
      }, mutable);
    });
  }
  /**
   * Apply a list of compiler transforms and return a new compiler context.
   */
  ;

  _proto.applyTransforms = function applyTransforms(transforms, reporter) {
    var _this = this;

    return Profiler.run('applyTransforms', function () {
      return transforms.reduce(function (ctx, transform) {
        return ctx.applyTransform(transform, reporter);
      }, _this);
    });
  }
  /**
   * Applies a transform to this context, returning a new context.
   *
   * This is memoized such that applying the same sequence of transforms will
   * not result in duplicated work.
   */
  ;

  _proto.applyTransform = function applyTransform(transform, reporter) {
    var transformed = this._withTransform.get(transform);

    if (!transformed) {
      var start = process.hrtime();
      transformed = Profiler.instrument(transform)(this);
      var delta = process.hrtime(start);
      var deltaMs = Math.round((delta[0] * 1e9 + delta[1]) / 1e6);
      reporter && reporter.reportTime(transform.name, deltaMs);

      this._withTransform.set(transform, transformed);
    }

    return transformed;
  };

  _proto.get = function get(name) {
    return this._documents.get(name);
  };

  _proto.getFragment = function getFragment(name, referencedFrom) {
    var node = this._documents.get(name);

    if (node == null) {
      throw createUserError("Cannot find fragment '".concat(name, "'."), referencedFrom != null ? [referencedFrom] : null);
    } else if (node.kind !== 'Fragment') {
      throw createUserError("Cannot find fragment '".concat(name, "', a document with this name exists ") + 'but is not a fragment.', [node.loc, referencedFrom].filter(Boolean));
    }

    return node;
  };

  _proto.getRoot = function getRoot(name) {
    var node = this._documents.get(name);

    if (node == null) {
      throw createUserError("Cannot find root '".concat(name, "'."));
    } else if (node.kind !== 'Root') {
      throw createUserError("Cannot find root '".concat(name, "', a document with this name exists but ") + 'is not a root.', [node.loc]);
    }

    return node;
  };

  _proto.remove = function remove(name) {
    return this._update(this._documents["delete"](name));
  };

  _proto.withMutations = function withMutations(fn) {
    var mutableCopy = this._update(this._documents.asMutable());

    mutableCopy._isMutable = true;
    var result = fn(mutableCopy);
    result._isMutable = false;
    result._documents = result._documents.asImmutable();
    return this._documents === result._documents ? this : result;
  };

  _proto._update = function _update(documents) {
    var context = this._isMutable ? this : new CompilerContext(this.getSchema());
    context._documents = documents;
    return context;
  };

  _proto.getSchema = function getSchema() {
    return this._schema;
  };

  return CompilerContext;
}();

module.exports = CompilerContext;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error


function md5(str) {
  return __webpack_require__(14).createHash('md5').update(str, 'utf8').digest('hex');
}

module.exports = md5;

/***/ }),
/* 26 */
/***/ (function(module, exports) {

module.exports = require("@babel/types");

/***/ }),
/* 27 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/defineProperty");

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error


var _interopRequireDefault = __webpack_require__(0);

var _asyncToGenerator = __webpack_require__(12);

var _toConsumableArray2 = _interopRequireDefault(__webpack_require__(5));

var Profiler = __webpack_require__(7);

var crypto = __webpack_require__(14);

var invariant = __webpack_require__(6);

var path = __webpack_require__(9); // flowlint nonstrict-import:warn


var CodegenDirectory = /*#__PURE__*/function () {
  function CodegenDirectory(dir, options) {
    var _this = this;

    var _options$filesystem, _options$shards;

    this._filesystem = (_options$filesystem = options.filesystem) !== null && _options$filesystem !== void 0 ? _options$filesystem : __webpack_require__(13);
    this.onlyValidate = options.onlyValidate;
    this._shards = (_options$shards = options.shards) !== null && _options$shards !== void 0 ? _options$shards : 1;

    if (this._filesystem.existsSync(dir)) {
      !this._filesystem.statSync(dir).isDirectory() ?  true ? invariant(false, 'Expected `%s` to be a directory.', dir) : undefined : void 0;
    }

    if (!this.onlyValidate) {
      var dirs = [];
      var parent = dir;

      while (!this._filesystem.existsSync(parent)) {
        dirs.unshift(parent);
        parent = path.dirname(parent);
      }

      dirs.forEach(function (d) {
        return _this._filesystem.mkdirSync(d);
      });

      if (this._shards > 1) {
        for (var shard = 0; shard < this._shards; shard++) {
          var shardDir = path.join(dir, this._getShardName(shard));

          if (this._filesystem.existsSync(shardDir)) {
            !this._filesystem.statSync(dir).isDirectory() ?  true ? invariant(false, 'Expected `%s` to be a directory.', dir) : undefined : void 0;
          } else {
            this._filesystem.mkdirSync(shardDir);
          }
        }
      }
    }

    this._files = new Set();
    this.changes = {
      deleted: [],
      updated: [],
      created: [],
      unchanged: []
    };
    this._dir = dir;
  }

  CodegenDirectory.combineChanges = function combineChanges(dirs) {
    var changes = {
      deleted: [],
      updated: [],
      created: [],
      unchanged: []
    };
    dirs.forEach(function (dir) {
      var _changes$deleted, _changes$updated, _changes$created, _changes$unchanged;

      (_changes$deleted = changes.deleted).push.apply(_changes$deleted, (0, _toConsumableArray2["default"])(dir.changes.deleted));

      (_changes$updated = changes.updated).push.apply(_changes$updated, (0, _toConsumableArray2["default"])(dir.changes.updated));

      (_changes$created = changes.created).push.apply(_changes$created, (0, _toConsumableArray2["default"])(dir.changes.created));

      (_changes$unchanged = changes.unchanged).push.apply(_changes$unchanged, (0, _toConsumableArray2["default"])(dir.changes.unchanged));
    });
    return changes;
  };

  CodegenDirectory.hasChanges = function hasChanges(changes) {
    return changes.created.length > 0 || changes.updated.length > 0 || changes.deleted.length > 0;
  };

  CodegenDirectory.formatChanges = function formatChanges(changes, options) {
    var output = [];

    function formatFiles(label, files) {
      if (files.length > 0) {
        output.push(label + ':');
        files.forEach(function (file) {
          output.push(' - ' + file);
        });
      }
    }

    if (options.onlyValidate) {
      formatFiles('Missing', changes.created);
      formatFiles('Out of date', changes.updated);
      formatFiles('Extra', changes.deleted);
    } else {
      formatFiles('Created', changes.created);
      formatFiles('Updated', changes.updated);
      formatFiles('Deleted', changes.deleted);
      output.push("Unchanged: ".concat(changes.unchanged.length, " files"));
    }

    return output.join('\n');
  };

  CodegenDirectory.printChanges = function printChanges(changes, options) {
    Profiler.run('CodegenDirectory.printChanges', function () {
      var output = CodegenDirectory.formatChanges(changes, options); // eslint-disable-next-line no-console

      console.log(output);
    });
  };

  CodegenDirectory.getAddedRemovedFiles = function getAddedRemovedFiles(dirs) {
    var added = [];
    var removed = [];
    dirs.forEach(function (dir) {
      dir.changes.created.forEach(function (name) {
        added.push(dir.getPath(name));
      });
      dir.changes.deleted.forEach(function (name) {
        removed.push(dir.getPath(name));
      });
    });
    return {
      added: added,
      removed: removed
    };
  };

  CodegenDirectory.sourceControlAddRemove = /*#__PURE__*/function () {
    var _sourceControlAddRemove = _asyncToGenerator(function* (sourceControl, dirs) {
      var _CodegenDirectory$get = CodegenDirectory.getAddedRemovedFiles(dirs),
          added = _CodegenDirectory$get.added,
          removed = _CodegenDirectory$get.removed;

      sourceControl.addRemove(added, removed);
    });

    function sourceControlAddRemove(_x, _x2) {
      return _sourceControlAddRemove.apply(this, arguments);
    }

    return sourceControlAddRemove;
  }();

  var _proto = CodegenDirectory.prototype;

  _proto.printChanges = function printChanges() {
    CodegenDirectory.printChanges(this.changes, {
      onlyValidate: this.onlyValidate
    });
  };

  _proto.read = function read(filename) {
    var filePath = path.join(this._dir, filename);

    if (this._filesystem.existsSync(filePath)) {
      return this._filesystem.readFileSync(filePath, 'utf8');
    }

    return null;
  };

  _proto.markUnchanged = function markUnchanged(filename) {
    this._addGenerated(filename);

    this.changes.unchanged.push(filename);
  }
  /**
   * Marks a files as updated or out of date without actually writing the file.
   * This is probably only be useful when doing validation without intention to
   * actually write to disk.
   */
  ;

  _proto.markUpdated = function markUpdated(filename) {
    this._addGenerated(filename);

    this.changes.updated.push(filename);
  };

  _proto.writeFile = function writeFile(filename, content) {
    var _this2 = this;

    var shouldRepersist = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    Profiler.run('CodegenDirectory.writeFile', function () {
      _this2._addGenerated(filename);

      var filePath = _this2.getPath(filename);

      if (_this2._filesystem.existsSync(filePath)) {
        var existingContent = _this2._filesystem.readFileSync(filePath, 'utf8');

        if (existingContent === content && !shouldRepersist) {
          _this2.changes.unchanged.push(filename);
        } else {
          _this2._writeFile(filePath, content);

          _this2.changes.updated.push(filename);
        }
      } else {
        _this2._writeFile(filePath, content);

        _this2.changes.created.push(filename);
      }
    });
  };

  _proto._writeFile = function _writeFile(filePath, content) {
    if (!this.onlyValidate) {
      this._filesystem.writeFileSync(filePath, content, 'utf8');
    }
  }
  /**
   * Deletes all non-generated files, except for invisible "dot" files (ie.
   * files with names starting with ".").
   */
  ;

  _proto.deleteExtraFiles = function deleteExtraFiles(keepExtraFile) {
    var _this3 = this;

    Profiler.run('CodegenDirectory.deleteExtraFiles', function () {
      if (_this3._shards > 1) {
        _this3._filesystem.readdirSync(_this3._dir).forEach(function (firstLevel) {
          if (firstLevel.startsWith('.')) {
            // allow hidden files on the first level of the codegen directory
            return;
          }

          var firstLevelPath = path.join(_this3._dir, firstLevel);

          if (!_this3._filesystem.statSync(firstLevelPath).isDirectory()) {
            // Delete all files on the top level, all files need to be in a
            // shard directory.
            _this3._filesystem.unlinkSync(firstLevelPath);

            return;
          }

          _this3._filesystem.readdirSync(firstLevelPath).forEach(function (actualFile) {
            if (keepExtraFile && keepExtraFile(actualFile)) {
              return;
            }

            if (_this3._files.has(actualFile)) {
              return;
            }

            if (!_this3.onlyValidate) {
              try {
                _this3._filesystem.unlinkSync(path.join(firstLevelPath, actualFile));
              } catch (_unused) {
                throw new Error('CodegenDirectory: Failed to delete `' + actualFile + '` in `' + _this3._dir + '`.');
              }
            }

            _this3.changes.deleted.push(actualFile);
          });
        });
      } else {
        _this3._filesystem.readdirSync(_this3._dir).forEach(function (actualFile) {
          if (keepExtraFile && keepExtraFile(actualFile)) {
            return;
          }

          if (actualFile.startsWith('.') || _this3._files.has(actualFile)) {
            return;
          }

          if (!_this3.onlyValidate) {
            try {
              _this3._filesystem.unlinkSync(path.join(_this3._dir, actualFile));
            } catch (_unused2) {
              throw new Error('CodegenDirectory: Failed to delete `' + actualFile + '` in `' + _this3._dir + '`.');
            }
          }

          _this3.changes.deleted.push(actualFile);
        });
      }
    });
  };

  _proto.getPath = function getPath(filename) {
    if (this._shards > 1) {
      var hasher = crypto.createHash('md5');
      hasher.update(filename, 'utf8');

      var shard = hasher.digest().readUInt32BE(0) % this._shards;

      return path.join(this._dir, this._getShardName(shard), filename);
    }

    return path.join(this._dir, filename);
  };

  _proto._getShardName = function _getShardName(shardNumber) {
    var base16length = Math.ceil(Math.log2(256) / 4);
    return shardNumber.toString(16).padStart(base16length, '0');
  };

  _proto._addGenerated = function _addGenerated(filename) {
    !!this._files.has(filename) ?  true ? invariant(false, 'CodegenDirectory: Tried to generate `%s` twice in `%s`.', filename, this._dir) : undefined : void 0;

    this._files.add(filename);
  };

  return CodegenDirectory;
}();

module.exports = CodegenDirectory;

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error


var Profiler = __webpack_require__(7); // $FlowFixMe[untyped-import] : Immutable is not typed


var _require = __webpack_require__(15),
    ImmutableMap = _require.Map;

var ASTCache = /*#__PURE__*/function () {
  function ASTCache(config) {
    this._documents = new Map();
    this._baseDir = config.baseDir;
    this._parse = Profiler.instrument(config.parse, 'ASTCache.parseFn');
  } // Short-term: we don't do subscriptions/delta updates, instead always use all definitions
  // $FlowFixMe[value-as-type]


  var _proto = ASTCache.prototype;

  _proto.documents = function documents() {
    return ImmutableMap(this._documents);
  } // parse should return the set of changes
  ;

  _proto.parseFiles = function parseFiles(files) {
    var _this = this;

    var documents = ImmutableMap();
    files.forEach(function (file) {
      if (!file.exists) {
        _this._documents["delete"](file.relPath);

        return;
      }

      var doc = function () {
        try {
          return _this._parse(_this._baseDir, file);
        } catch (error) {
          throw new Error("Parse error: ".concat(error, " in \"").concat(file.relPath, "\""));
        }
      }();

      if (!doc) {
        _this._documents["delete"](file.relPath);

        return;
      }

      documents = documents.set(file.relPath, doc);

      _this._documents.set(file.relPath, doc);
    });
    return documents;
  };

  return ASTCache;
}();

module.exports = ASTCache;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error


var _interopRequireDefault = __webpack_require__(0);

var _objectSpread2 = _interopRequireDefault(__webpack_require__(2));

var _createForOfIteratorHelper2 = _interopRequireDefault(__webpack_require__(4));

var _toConsumableArray2 = _interopRequireDefault(__webpack_require__(5));

var Profiler = __webpack_require__(7);

var orList = __webpack_require__(66);

var partitionArray = __webpack_require__(16);

var _require = __webpack_require__(31),
    DEFAULT_HANDLE_KEY = _require.DEFAULT_HANDLE_KEY;

var _require2 = __webpack_require__(1),
    createCompilerError = _require2.createCompilerError,
    createUserError = _require2.createUserError,
    eachWithCombinedError = _require2.eachWithCombinedError;

var _require3 = __webpack_require__(10),
    isExecutableDefinitionAST = _require3.isExecutableDefinitionAST;

var _require4 = __webpack_require__(32),
    getFieldDefinitionLegacy = _require4.getFieldDefinitionLegacy;

var _require5 = __webpack_require__(8),
    parseGraphQL = _require5.parse,
    parseType = _require5.parseType,
    print = _require5.print,
    Source = _require5.Source;

var ARGUMENT_DEFINITIONS = 'argumentDefinitions';
var ARGUMENTS = 'arguments';
var DEPRECATED_UNCHECKED_ARGUMENTS = 'uncheckedArguments_DEPRECATED';
var DIRECTIVE_WHITELIST = new Set([ARGUMENT_DEFINITIONS, DEPRECATED_UNCHECKED_ARGUMENTS, ARGUMENTS]);
/**
 * @internal
 *
 * This directive is not intended for use by developers directly. To set a field
 * handle in product code use a compiler plugin.
 */

var CLIENT_FIELD = '__clientField';
var CLIENT_FIELD_HANDLE = 'handle';
var CLIENT_FIELD_KEY = 'key';
var CLIENT_FIELD_FILTERS = 'filters';
var INCLUDE = 'include';
var SKIP = 'skip';
var IF = 'if';
/**
 * Transforms GraphQL text into Relay Compiler's internal, strongly-typed
 * intermediate representation (IR).
 */

function parse(schema, text, filename) {
  var ast = parseGraphQL(new Source(text, filename));
  var parser = new RelayParser(schema.extend(ast), ast.definitions);
  return parser.transform();
}
/**
 * Transforms untyped GraphQL parse trees (ASTs) into Relay Compiler's
 * internal, strongly-typed intermediate representation (IR).
 */


function transform(schema, definitions) {
  return Profiler.run('RelayParser.transform', function () {
    var parser = new RelayParser(schema, definitions);
    return parser.transform();
  });
}
/**
 * @private
 */


var RelayParser = /*#__PURE__*/function () {
  function RelayParser(schema, definitions) {
    var _this = this;

    this._definitions = new Map(); // leaving this configurable to make it easy to experiment w changing later

    this._getFieldDefinition = getFieldDefinitionLegacy;
    this._schema = schema;
    var duplicated = new Set();
    definitions.forEach(function (def) {
      if (isExecutableDefinitionAST(def)) {
        var name = getName(def);

        if (_this._definitions.has(name)) {
          duplicated.add(name);
          return;
        }

        _this._definitions.set(name, def);
      }
    });

    if (duplicated.size) {
      throw createUserError('RelayParser: Encountered duplicate definitions for one or more ' + 'documents: each document must have a unique name. Duplicated documents:\n' + Array.from(duplicated, function (name) {
        return "- ".concat(name);
      }).join('\n'));
    }
  }

  var _proto = RelayParser.prototype;

  _proto.transform = function transform() {
    var _this2 = this;

    var nodes = [];
    var entries = new Map(); // Construct a mapping of name to definition ast + variable definitions.
    // This allows the subsequent AST -> IR tranformation to reference the
    // defined arguments of referenced fragments.

    eachWithCombinedError(this._definitions, function (_ref) {
      var name = _ref[0],
          definition = _ref[1];

      var variableDefinitions = _this2._buildArgumentDefinitions(definition);

      entries.set(name, {
        definition: definition,
        variableDefinitions: variableDefinitions
      });
    }); // Convert the ASTs to IR.

    eachWithCombinedError(entries.values(), function (_ref2) {
      var definition = _ref2.definition,
          variableDefinitions = _ref2.variableDefinitions;
      var node = parseDefinition(_this2._schema, _this2._getFieldDefinition, entries, definition, variableDefinitions);
      nodes.push(node);
    });
    return nodes;
  }
  /**
   * Constructs a mapping of variable names to definitions for the given
   * operation/fragment definition.
   */
  ;

  _proto._buildArgumentDefinitions = function _buildArgumentDefinitions(definition) {
    switch (definition.kind) {
      case 'OperationDefinition':
        return this._buildOperationArgumentDefinitions(definition);

      case 'FragmentDefinition':
        return this._buildFragmentArgumentDefinitions(definition);

      default:
        definition;
        throw createCompilerError("Unexpected ast kind '".concat(definition.kind, "'."), [definition]);
    }
  }
  /**
   * Constructs a mapping of variable names to definitions using the
   * variables defined in `@argumentDefinitions`.
   */
  ;

  _proto._buildFragmentArgumentDefinitions = function _buildFragmentArgumentDefinitions(fragment) {
    var _this3 = this;

    var variableDirectives = (fragment.directives || []).filter(function (directive) {
      return getName(directive) === ARGUMENT_DEFINITIONS;
    });

    if (!variableDirectives.length) {
      return new Map();
    }

    if (variableDirectives.length !== 1) {
      throw createUserError("Directive @".concat(ARGUMENT_DEFINITIONS, " may be defined at most once per ") + 'fragment.', null, variableDirectives);
    }

    var variableDirective = variableDirectives[0]; // work, below accesses all report arguments could still be null/undefined.

    var args = variableDirective.arguments;

    if (variableDirective == null || !Array.isArray(args)) {
      return new Map();
    }

    if (!args.length) {
      throw createUserError("Directive @".concat(ARGUMENT_DEFINITIONS, " requires arguments: remove the ") + 'directive to skip defining local variables for this fragment.', null, [variableDirective]);
    }

    var variables = new Map();
    args.forEach(function (arg) {
      var _defaultValue$value;

      var argName = getName(arg);
      var previousVariable = variables.get(argName);

      if (previousVariable != null) {
        throw createUserError("Duplicate definition for variable '$".concat(argName, "'."), null, [previousVariable.ast, arg]);
      }

      if (arg.value.kind !== 'ObjectValue') {
        throw createUserError("Expected definition for variable '$".concat(argName, "' to be an object ") + "with the shape: '{type: string, defaultValue?: mixed}.", null, [arg.value]);
      }

      var defaultValueNode;
      var typeString;
      arg.value.fields.forEach(function (field) {
        var name = getName(field);

        if (name === 'type') {
          typeString = transformLiteralValue(field.value, field);
        } else if (name === 'defaultValue') {
          defaultValueNode = field.value;
        } else {
          throw createUserError("Expected definition for variable '$".concat(argName, "' to be an object ") + "with the shape: '{type: string, defaultValue?: mixed}.", null, [arg.value]);
        }
      });

      if (typeof typeString !== 'string') {
        throw createUserError("Expected definition for variable '$".concat(argName, "' to be an object ") + "with the shape: '{type: string, defaultValue?: mixed}.", null, [arg.value]);
      }

      var typeFromAST = _this3._schema.getTypeFromAST(parseType(typeString));

      if (typeFromAST == null) {
        throw createUserError( // $FlowFixMe[incompatible-type]
        "Unknown type \"".concat(typeString, "\" referenced in the argument definitions."), null, [arg]);
      }

      var type = _this3._schema.asInputType(typeFromAST);

      if (type == null) {
        throw createUserError( // $FlowFixMe[incompatible-type]
        "Expected type \"".concat(typeString, "\" to be an input type in the \"").concat(arg.name.value, "\" argument definitions."), null, [arg.value]);
      }

      var defaultValue = defaultValueNode != null ? transformValue(_this3._schema, defaultValueNode, type, function (variableAst) {
        throw createUserError("Expected 'defaultValue' to be a literal, got a variable.", null, [variableAst]);
      }) : null;

      if (defaultValue != null && defaultValue.kind !== 'Literal') {
        throw createUserError("Expected 'defaultValue' to be a literal, got a variable.", [defaultValue.loc]);
      }

      variables.set(argName, {
        ast: arg,
        defaultValue: (_defaultValue$value = defaultValue === null || defaultValue === void 0 ? void 0 : defaultValue.value) !== null && _defaultValue$value !== void 0 ? _defaultValue$value : null,
        defined: true,
        name: argName,
        type: type
      });
    });
    return variables;
  }
  /**
   * Constructs a mapping of variable names to definitions using the
   * standard GraphQL syntax for variable definitions.
   */
  ;

  _proto._buildOperationArgumentDefinitions = function _buildOperationArgumentDefinitions(operation) {
    var schema = this._schema;
    var variableDefinitions = new Map();
    (operation.variableDefinitions || []).forEach(function (def) {
      var name = getName(def.variable);
      var typeFromAST = schema.getTypeFromAST(def.type);

      if (typeFromAST == null) {
        throw createUserError("Unknown type: '".concat(getTypeName(def.type), "'."), null, [def.type]);
      }

      var type = schema.asInputType(typeFromAST);

      if (type == null) {
        throw createUserError("Expected type \"".concat(getTypeName(def.type), "\" to be an input type."), null, [def.type]);
      }

      var defaultValue = def.defaultValue ? transformLiteralValue(def.defaultValue, def) : null;
      var previousDefinition = variableDefinitions.get(name);

      if (previousDefinition != null) {
        throw createUserError("Duplicate definition for variable '$".concat(name, "'."), null, [previousDefinition.ast, def]);
      }

      variableDefinitions.set(name, {
        ast: def,
        defaultValue: defaultValue,
        defined: true,
        name: name,
        type: type
      });
    });
    return variableDefinitions;
  };

  return RelayParser;
}();
/**
 * @private
 */


function parseDefinition(schema, getFieldDefinition, entries, definition, variableDefinitions) {
  var parser = new GraphQLDefinitionParser(schema, getFieldDefinition, entries, definition, variableDefinitions);
  return parser.transform();
}
/**
 * @private
 */


var GraphQLDefinitionParser = /*#__PURE__*/function () {
  function GraphQLDefinitionParser(schema, getFieldDefinition, entries, definition, variableDefinitions) {
    this._definition = definition;
    this._entries = entries;
    this._getFieldDefinition = getFieldDefinition;
    this._schema = schema;
    this._variableDefinitions = variableDefinitions;
    this._unknownVariables = new Map();
  }

  var _proto2 = GraphQLDefinitionParser.prototype;

  _proto2.transform = function transform() {
    var definition = this._definition;

    switch (definition.kind) {
      case 'OperationDefinition':
        return this._transformOperation(definition);

      case 'FragmentDefinition':
        return this._transformFragment(definition);

      default:
        definition;
        throw createCompilerError("Unsupported definition type ".concat(definition.kind), [definition]);
    }
  };

  _proto2._recordAndVerifyVariableReference = function _recordAndVerifyVariableReference(variable, name, usedAsType) {
    // Special case for variables used in @arguments where we currently
    // aren't guaranteed to be able to resolve the type.
    if (usedAsType == null) {
      if (!this._variableDefinitions.has(name) && !this._unknownVariables.has(name)) {
        this._unknownVariables.set(name, {
          ast: variable,
          type: null
        });
      }

      return;
    }

    var variableDefinition = this._variableDefinitions.get(name);

    if (variableDefinition != null) {
      // If the variable is defined, all usages must be compatible
      var effectiveType = variableDefinition.type;

      if (variableDefinition.defaultValue != null) {
        // If a default value is defined then it is guaranteed to be used
        // at runtime such that the effective type of the variable is non-null
        effectiveType = this._schema.getNonNullType(this._schema.getNullableType(effectiveType));
      }

      if (!this._schema.isTypeSubTypeOf(effectiveType, usedAsType)) {
        throw createUserError("Variable '$".concat(name, "' was defined as type '").concat(String(variableDefinition.type), "' but used in a location expecting the type '").concat(String(usedAsType), "'"), null, [variableDefinition.ast, variable]);
      }
    } else {
      var previous = this._unknownVariables.get(name);

      if (!previous || !previous.type) {
        // No previous usage, current type is strongest
        this._unknownVariables.set(name, {
          ast: variable,
          type: usedAsType
        });
      } else {
        var previousVariable = previous.ast,
            previousType = previous.type;

        if (!(this._schema.isTypeSubTypeOf(usedAsType, previousType) || this._schema.isTypeSubTypeOf(previousType, usedAsType))) {
          throw createUserError("Variable '$".concat(name, "' was used in locations expecting the conflicting types '").concat(String(previousType), "' and '").concat(String(usedAsType), "'."), null, [previousVariable, variable]);
        } // If the new used type has stronger requirements, use that type as reference,
        // otherwise keep referencing the previous type


        if (this._schema.isTypeSubTypeOf(usedAsType, previousType)) {
          this._unknownVariables.set(name, {
            ast: variable,
            type: usedAsType
          });
        }
      }
    }
  };

  _proto2._getDirectiveLocations = function _getDirectiveLocations() {
    if (!this._directiveLocations) {
      var directiveDefs = this._schema.getDirectives();

      this._directiveLocations = new Map();

      var _iterator = (0, _createForOfIteratorHelper2["default"])(directiveDefs),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var def = _step.value;

          this._directiveLocations.set(def.name, def.locations);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }

    return this._directiveLocations;
  };

  _proto2._validateDirectivesLocation = function _validateDirectivesLocation(directives, allowedLocaction) {
    if (!directives || !directives.length) {
      return;
    }

    var directiveLocs = this._getDirectiveLocations();

    var mismatches = directives.filter(function (directive) {
      var name = getName(directive);

      if (DIRECTIVE_WHITELIST.has(name)) {
        return false;
      }

      var locs = directiveLocs.get(name);

      if (locs == null) {
        throw createUserError("Unknown directive '".concat(name, "'."), null, [directive]);
      }

      return !locs.some(function (loc) {
        return loc === allowedLocaction;
      });
    });

    if (mismatches.length) {
      var invalidDirectives = mismatches.map(function (directive) {
        return '@' + getName(directive);
      }).join(', ');
      throw createUserError("Invalid directives ".concat(invalidDirectives, " found on ").concat(allowedLocaction, "."), null, mismatches);
    }
  };

  _proto2._transformFragment = function _transformFragment(fragment) {
    var directives = this._transformDirectives((fragment.directives || []).filter(function (directive) {
      return getName(directive) !== ARGUMENT_DEFINITIONS;
    }), 'FRAGMENT_DEFINITION');

    var typeFromAST = this._schema.getTypeFromAST(fragment.typeCondition);

    if (typeFromAST == null) {
      throw createUserError("Fragment \"".concat(fragment.name.value, "\" cannot condition on unknown ") + "type \"".concat(String(fragment.typeCondition.name.value), "\"."), null, [fragment.typeCondition]);
    }

    var type = this._schema.asCompositeType(typeFromAST);

    if (type == null) {
      throw createUserError("Fragment \"".concat(fragment.name.value, "\" cannot condition on non composite ") + "type \"".concat(String(type), "\"."), null, [fragment.typeCondition]);
    }

    var selections = this._transformSelections(fragment.selectionSet, type, fragment.typeCondition);

    var argumentDefinitions = (0, _toConsumableArray2["default"])(buildArgumentDefinitions(this._variableDefinitions));

    var _iterator2 = (0, _createForOfIteratorHelper2["default"])(this._unknownVariables),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _step2$value = _step2.value,
            name = _step2$value[0],
            variableReference = _step2$value[1];
        argumentDefinitions.push({
          kind: 'RootArgumentDefinition',
          loc: buildLocation(variableReference.ast.loc),
          name: name,
          type: variableReference.type
        });
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }

    return {
      kind: 'Fragment',
      directives: directives,
      loc: buildLocation(fragment.loc),
      metadata: null,
      name: getName(fragment),
      selections: selections,
      type: type,
      // $FlowFixMe[incompatible-return] - could be null
      argumentDefinitions: argumentDefinitions
    };
  };

  _proto2._getLocationFromOperation = function _getLocationFromOperation(definition) {
    switch (definition.operation) {
      case 'query':
        return 'QUERY';

      case 'mutation':
        return 'MUTATION';

      case 'subscription':
        return 'SUBSCRIPTION';

      default:
        definition.operation;
        throw createCompilerError("Unknown operation type '".concat(definition.operation, "'."), null, [definition]);
    }
  };

  _proto2._transformOperation = function _transformOperation(definition) {
    var name = getName(definition);

    var directives = this._transformDirectives(definition.directives || [], this._getLocationFromOperation(definition));

    var type;
    var operation;
    var schema = this._schema;

    switch (definition.operation) {
      case 'query':
        operation = 'query';
        type = schema.expectQueryType();
        break;

      case 'mutation':
        operation = 'mutation';
        type = schema.expectMutationType();
        break;

      case 'subscription':
        operation = 'subscription';
        type = schema.expectSubscriptionType();
        break;

      default:
        definition.operation;
        throw createCompilerError("Unknown operation type '".concat(definition.operation, "'."), null, [definition]);
    }

    if (!definition.selectionSet) {
      throw createUserError('Expected operation to have selections.', null, [definition]);
    }

    var selections = this._transformSelections(definition.selectionSet, type);

    var argumentDefinitions = buildArgumentDefinitions(this._variableDefinitions);

    if (this._unknownVariables.size !== 0) {
      throw createUserError("Query '".concat(name, "' references undefined variables."), null, Array.from(this._unknownVariables.values(), function (variableReference) {
        return variableReference.ast;
      }));
    }

    return {
      kind: 'Root',
      operation: operation,
      loc: buildLocation(definition.loc),
      metadata: null,
      name: name,
      argumentDefinitions: argumentDefinitions,
      directives: directives,
      selections: selections,
      // $FlowFixMe[incompatible-return]
      type: type
    };
  };

  _proto2._transformSelections = function _transformSelections(selectionSet, parentType, parentTypeAST) {
    var _this4 = this;

    return selectionSet.selections.map(function (selection) {
      var node;

      if (selection.kind === 'Field') {
        node = _this4._transformField(selection, parentType);
      } else if (selection.kind === 'FragmentSpread') {
        node = _this4._transformFragmentSpread(selection, parentType, parentTypeAST);
      } else if (selection.kind === 'InlineFragment') {
        node = _this4._transformInlineFragment(selection, parentType, parentTypeAST);
      } else {
        selection.kind;
        throw createCompilerError("Unknown ast kind '".concat(selection.kind, "'."), [selection]);
      }

      var _this4$_splitConditio = _this4._splitConditions(node.directives),
          conditions = _this4$_splitConditio[0],
          directives = _this4$_splitConditio[1];

      var conditionalNodes = applyConditions(conditions, // $FlowFixMe[incompatible-call]
      [(0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, node), {}, {
        directives: directives
      })]);

      if (conditionalNodes.length !== 1) {
        throw createCompilerError('Expected exactly one condition node.', null, selection.directives);
      }

      return conditionalNodes[0];
    });
  };

  _proto2._transformInlineFragment = function _transformInlineFragment(fragment, parentType, parentTypeAST) {
    var schema = this._schema;
    var typeCondition = fragment.typeCondition != null ? schema.getTypeFromAST(fragment.typeCondition) : parentType;

    if (typeCondition == null) {
      var _fragment$typeConditi;

      throw createUserError('Inline fragments can only be on object, interface or union types' + ", got unknown type '".concat(getTypeName(fragment.typeCondition), "'."), null, [(_fragment$typeConditi = fragment.typeCondition) !== null && _fragment$typeConditi !== void 0 ? _fragment$typeConditi : fragment]);
    }

    var typeConditionName = schema.getTypeString(typeCondition);
    typeCondition = schema.asCompositeType(typeCondition);

    if (typeCondition == null) {
      var _fragment$typeConditi2;

      throw createUserError('Inline fragments can only be on object, interface or union types' + ", got '".concat(typeConditionName, "'."), null, [(_fragment$typeConditi2 = fragment.typeCondition) !== null && _fragment$typeConditi2 !== void 0 ? _fragment$typeConditi2 : fragment]);
    }

    var rawParentType = this._schema.assertCompositeType(this._schema.getRawType(parentType));

    checkFragmentSpreadTypeCompatibility(this._schema, typeCondition, rawParentType, null, fragment.typeCondition, parentTypeAST);

    var directives = this._transformDirectives(fragment.directives || [], 'INLINE_FRAGMENT');

    var selections = this._transformSelections(fragment.selectionSet, typeCondition, fragment.typeCondition);

    return {
      kind: 'InlineFragment',
      directives: directives,
      loc: buildLocation(fragment.loc),
      metadata: null,
      selections: selections,
      typeCondition: typeCondition
    };
  };

  _proto2._transformFragmentSpread = function _transformFragmentSpread(fragmentSpread, parentType, parentTypeAST) {
    var _this5 = this;

    var fragmentName = getName(fragmentSpread);

    var _partitionArray = partitionArray(fragmentSpread.directives || [], function (directive) {
      var name = getName(directive);
      return name === ARGUMENTS || name === DEPRECATED_UNCHECKED_ARGUMENTS;
    }),
        argumentDirectives = _partitionArray[0],
        otherDirectives = _partitionArray[1];

    if (argumentDirectives.length > 1) {
      throw createUserError("Directive @".concat(ARGUMENTS, " may be used at most once per a fragment spread."), null, argumentDirectives);
    }

    var fragmentDefinition = this._entries.get(fragmentName);

    if (fragmentDefinition == null) {
      throw createUserError("Unknown fragment '".concat(fragmentName, "'."), null, [fragmentSpread.name]);
    }

    var fragmentTypeNode = getFragmentType(fragmentDefinition.definition);

    var fragmentType = this._schema.assertCompositeType(this._schema.expectTypeFromAST(fragmentTypeNode));

    var rawParentType = this._schema.assertCompositeType(this._schema.getRawType(parentType));

    checkFragmentSpreadTypeCompatibility(this._schema, fragmentType, rawParentType, fragmentSpread.name.value, fragmentSpread, parentTypeAST);
    var fragmentArgumentDefinitions = fragmentDefinition.variableDefinitions;
    var argumentsDirective = argumentDirectives[0];
    var args;

    if (argumentsDirective != null) {
      var isDeprecatedUncheckedArguments = getName(argumentsDirective) === DEPRECATED_UNCHECKED_ARGUMENTS;
      var hasInvalidArgument = false;
      args = (argumentsDirective.arguments || []).map(function (arg) {
        var _argumentDefinition$t;

        var argName = getName(arg);
        var argValue = arg.value;
        var argumentDefinition = fragmentArgumentDefinitions.get(argName);
        var argumentType = (_argumentDefinition$t = argumentDefinition === null || argumentDefinition === void 0 ? void 0 : argumentDefinition.type) !== null && _argumentDefinition$t !== void 0 ? _argumentDefinition$t : null;

        if (argValue.kind === 'Variable') {
          if (argumentDefinition == null && !isDeprecatedUncheckedArguments) {
            throw createUserError("Variable @".concat(ARGUMENTS, " values are only supported when the ") + "argument is defined with @".concat(ARGUMENT_DEFINITIONS, ". Check ") + "the definition of fragment '".concat(fragmentName, "'."), null, [arg.value, fragmentDefinition.definition]);
          }

          hasInvalidArgument = hasInvalidArgument || argumentDefinition == null; // TODO: check the type of the variable and use the type

          return {
            kind: 'Argument',
            loc: buildLocation(arg.loc),
            name: argName,
            value: _this5._transformVariable(argValue, null),
            type: null
          };
        } else {
          if (argumentType == null) {
            throw createUserError("Literal @".concat(ARGUMENTS, " values are only supported when the ") + "argument is defined with @".concat(ARGUMENT_DEFINITIONS, ". Check ") + "the definition of fragment '".concat(fragmentName, "'."), null, [arg.value, fragmentDefinition.definition]);
          }

          var value = _this5._transformValue(argValue, argumentType);

          return {
            kind: 'Argument',
            loc: buildLocation(arg.loc),
            name: argName,
            value: value,
            type: argumentType
          };
        }
      });

      if (isDeprecatedUncheckedArguments && !hasInvalidArgument) {
        throw createUserError("Invalid use of @".concat(DEPRECATED_UNCHECKED_ARGUMENTS, ": all arguments ") + "are defined, use @".concat(ARGUMENTS, " instead."), null, [argumentsDirective]);
      }
    }

    var directives = this._transformDirectives(otherDirectives, 'FRAGMENT_SPREAD');

    return {
      kind: 'FragmentSpread',
      args: args || [],
      metadata: null,
      loc: buildLocation(fragmentSpread.loc),
      name: fragmentName,
      directives: directives
    };
  };

  _proto2._transformField = function _transformField(field, parentType) {
    var _field$alias$value, _field$alias;

    var schema = this._schema;
    var name = getName(field);

    var fieldDef = this._getFieldDefinition(schema, parentType, name, field);

    if (fieldDef == null) {
      throw createUserError("Unknown field '".concat(name, "' on type '").concat(schema.getTypeString(parentType), "'."), null, [field]);
    }

    var alias = (_field$alias$value = (_field$alias = field.alias) === null || _field$alias === void 0 ? void 0 : _field$alias.value) !== null && _field$alias$value !== void 0 ? _field$alias$value : name;

    var args = this._transformArguments(field.arguments || [], schema.getFieldArgs(fieldDef), fieldDef);

    var _partitionArray2 = partitionArray(field.directives || [], function (directive) {
      return getName(directive) !== CLIENT_FIELD;
    }),
        otherDirectives = _partitionArray2[0],
        clientFieldDirectives = _partitionArray2[1];

    var directives = this._transformDirectives(otherDirectives, 'FIELD');

    var type = schema.getFieldType(fieldDef);

    var handles = this._transformHandle(name, args, clientFieldDirectives);

    if (schema.isLeafType(schema.getRawType(type))) {
      if (field.selectionSet && field.selectionSet.selections && field.selectionSet.selections.length) {
        throw createUserError("Expected no selections for scalar field '".concat(name, "'."), null, [field]);
      }

      return {
        kind: 'ScalarField',
        alias: alias,
        args: args,
        directives: directives,
        handles: handles,
        loc: buildLocation(field.loc),
        metadata: null,
        name: name,
        type: schema.assertScalarFieldType(type)
      };
    } else {
      var selections = field.selectionSet ? this._transformSelections(field.selectionSet, type) : null;

      if (selections == null || selections.length === 0) {
        throw createUserError("Expected at least one selection for non-scalar field '".concat(name, "' on type '").concat(schema.getTypeString(type), "'."), null, [field]);
      }

      return {
        kind: 'LinkedField',
        alias: alias,
        args: args,
        connection: false,
        directives: directives,
        handles: handles,
        loc: buildLocation(field.loc),
        metadata: null,
        name: name,
        selections: selections,
        type: schema.assertLinkedFieldType(type)
      };
    }
  };

  _proto2._transformHandle = function _transformHandle(fieldName, fieldArgs, clientFieldDirectives) {
    var handles = null;
    clientFieldDirectives.forEach(function (clientFieldDirective) {
      var handleArgument = (clientFieldDirective.arguments || []).find(function (arg) {
        return getName(arg) === CLIENT_FIELD_HANDLE;
      });

      if (handleArgument) {
        var name = null;
        var key = DEFAULT_HANDLE_KEY;
        var filters = null;
        var maybeHandle = transformLiteralValue(handleArgument.value, handleArgument);

        if (typeof maybeHandle !== 'string') {
          throw createUserError("Expected a string literal argument for the @".concat(CLIENT_FIELD, " directive."), null, [handleArgument.value]);
        }

        name = maybeHandle;
        var keyArgument = (clientFieldDirective.arguments || []).find(function (arg) {
          return getName(arg) === CLIENT_FIELD_KEY;
        });

        if (keyArgument) {
          var maybeKey = transformLiteralValue(keyArgument.value, keyArgument);

          if (typeof maybeKey !== 'string') {
            throw createUserError("Expected a string literal argument for the @".concat(CLIENT_FIELD, " directive."), null, [keyArgument.value]);
          }

          key = maybeKey;
        }

        var filtersArgument = (clientFieldDirective.arguments || []).find(function (arg) {
          return getName(arg) === CLIENT_FIELD_FILTERS;
        });

        if (filtersArgument) {
          var maybeFilters = transformLiteralValue(filtersArgument.value, filtersArgument);

          if (!(Array.isArray(maybeFilters) && maybeFilters.every(function (filter) {
            return typeof filter === 'string' && fieldArgs.some(function (fieldArg) {
              return fieldArg.name === filter;
            });
          }))) {
            throw createUserError("Expected an array of argument names on field '".concat(fieldName, "'."), null, [filtersArgument.value]);
          } // $FlowFixMe[incompatible-cast]


          filters = maybeFilters;
        }

        var dynamicKeyArgument = (clientFieldDirective.arguments || []).find(function (arg) {
          return getName(arg) === 'dynamicKey_UNSTABLE';
        });

        if (dynamicKeyArgument != null) {
          throw createUserError('Dynamic keys are only supported with @connection.', null, [dynamicKeyArgument.value]);
        }

        handles = handles || [];
        handles.push({
          name: name,
          key: key,
          filters: filters,
          dynamicKey: null
        });
      }
    });
    return handles;
  };

  _proto2._transformDirectives = function _transformDirectives(directives, location) {
    var _this6 = this;

    this._validateDirectivesLocation(directives, location);

    return directives.map(function (directive) {
      var name = getName(directive);

      var directiveDef = _this6._schema.getDirective(name);

      if (directiveDef == null) {
        throw createUserError("Unknown directive '".concat(name, "'."), null, [directive]);
      }

      var args = _this6._transformArguments(directive.arguments || [], directiveDef.args.map(function (item) {
        return {
          name: item.name,
          type: item.type,
          defaultValue: item.defaultValue
        };
      }), null, name);

      return {
        kind: 'Directive',
        loc: buildLocation(directive.loc),
        name: name,
        args: args
      };
    });
  };

  _proto2._transformArguments = function _transformArguments(args, argumentDefinitions, field, directiveName) {
    var _this7 = this;

    return args.map(function (arg) {
      var argName = getName(arg);
      var argDef = argumentDefinitions.find(function (def) {
        return def.name === argName;
      });

      if (argDef == null) {
        var message = "Unknown argument '".concat(argName, "'") + (field ? " on field '".concat(_this7._schema.getFieldName(field), "'") + " of type '".concat(_this7._schema.getTypeString(_this7._schema.getFieldParentType(field)), "'.") : directiveName != null ? " on directive '@".concat(directiveName, "'.") : '.');
        throw createUserError(message, null, [arg]);
      }

      var value = _this7._transformValue(arg.value, argDef.type);

      return {
        kind: 'Argument',
        loc: buildLocation(arg.loc),
        name: argName,
        value: value,
        type: argDef.type
      };
    });
  };

  _proto2._splitConditions = function _splitConditions(mixedDirectives) {
    var _partitionArray3 = partitionArray(mixedDirectives, function (directive) {
      return directive.name === INCLUDE || directive.name === SKIP;
    }),
        conditionDirectives = _partitionArray3[0],
        otherDirectives = _partitionArray3[1];

    var conditions = conditionDirectives.map(function (directive) {
      var passingValue = directive.name === INCLUDE;
      var arg = directive.args[0];

      if (arg == null || arg.name !== IF) {
        throw createUserError("Expected an 'if' argument to @".concat(directive.name, "."), [directive.loc]);
      }

      if (!(arg.value.kind === 'Variable' || arg.value.kind === 'Literal')) {
        throw createUserError("Expected the 'if' argument to @".concat(directive.name, " to be a variable or literal."), [directive.loc]);
      }

      return {
        kind: 'Condition',
        condition: arg.value,
        loc: directive.loc,
        passingValue: passingValue,
        selections: []
      };
    });
    var sortedConditions = conditions.sort(function (a, b) {
      if (a.condition.kind === 'Variable' && b.condition.kind === 'Variable') {
        return a.condition.variableName < b.condition.variableName ? -1 : a.condition.variableName > b.condition.variableName ? 1 : 0;
      } else {
        // sort literals earlier, variables later
        return a.condition.kind === 'Variable' ? 1 : b.condition.kind === 'Variable' ? -1 : 0;
      }
    });
    return [sortedConditions, otherDirectives];
  };

  _proto2._transformVariable = function _transformVariable(ast, usedAsType) {
    var variableName = getName(ast);

    this._recordAndVerifyVariableReference(ast, variableName, usedAsType);

    return {
      kind: 'Variable',
      loc: buildLocation(ast.loc),
      variableName: variableName,
      type: usedAsType
    };
  };

  _proto2._transformValue = function _transformValue(ast, type) {
    var _this8 = this;

    return transformValue(this._schema, ast, type, function (variableAst, variableType) {
      return _this8._transformVariable(variableAst, variableType);
    });
  };

  return GraphQLDefinitionParser;
}();
/**
 * Transforms and validates argument values according to the expected
 * type.
 */


function transformValue(schema, ast, type, transformVariable) {
  if (ast.kind === 'Variable') {
    // Special case variables since there is no value to parse
    return transformVariable(ast, type);
  } else if (ast.kind === 'NullValue') {
    // Special case null literals since there is no value to parse
    if (schema.isNonNull(type)) {
      throw createUserError("Expected a value matching type '".concat(String(type), "'."), null, [ast]);
    }

    return {
      kind: 'Literal',
      loc: buildLocation(ast.loc),
      value: null
    };
  } else {
    return transformNonNullLiteral(schema, ast, type, transformVariable);
  }
}
/**
 * Transforms and validates non-null literal (non-variable) values
 * according to the expected type.
 */


function transformNonNullLiteral(schema, ast, type, transformVariable) {
  // Transform the value based on the type without a non-null wrapper.
  // Note that error messages should still use the original `type`
  // since that accurately describes to the user what the expected
  // type is (using nullableType would suggest that `null` is legal
  // even when it may not be, for example).
  var nullableType = schema.getNullableType(type);

  if (schema.isList(nullableType)) {
    if (ast.kind !== 'ListValue') {
      // Parse singular (non-list) values flowing into a list type
      // as scalars, ie without wrapping them in an array.
      if (!schema.isInputType(schema.getListItemType(nullableType))) {
        throw createUserError("Expected type ".concat(schema.getTypeString(nullableType), " to be an input type."), null, [ast]);
      }

      return transformValue(schema, ast, schema.assertInputType(schema.getListItemType(nullableType)), transformVariable);
    }

    var itemType = schema.assertInputType(schema.getListItemType(nullableType));
    var literalList = [];
    var items = [];
    var areAllItemsScalar = true;
    ast.values.forEach(function (item) {
      var itemValue = transformValue(schema, item, itemType, transformVariable);

      if (itemValue.kind === 'Literal') {
        literalList.push(itemValue.value);
      }

      items.push(itemValue);
      areAllItemsScalar = areAllItemsScalar && itemValue.kind === 'Literal';
    });

    if (areAllItemsScalar) {
      return {
        kind: 'Literal',
        loc: buildLocation(ast.loc),
        value: literalList
      };
    } else {
      return {
        kind: 'ListValue',
        loc: buildLocation(ast.loc),
        items: items
      };
    }
  } else if (schema.isInputObject(nullableType)) {
    if (ast.kind !== 'ObjectValue') {
      throw createUserError("Expected a value matching type '".concat(schema.getTypeString(type), "'."), null, [ast]);
    }

    var literalObject = {};
    var fields = [];
    var areAllFieldsScalar = true;
    var inputType = schema.assertInputObjectType(nullableType);
    var requiredFieldNames = new Set(schema.getFields(inputType).filter(function (field) {
      return schema.isNonNull(schema.getFieldType(field));
    }).map(function (field) {
      return schema.getFieldName(field);
    }));
    var seenFields = new Map();
    ast.fields.forEach(function (field) {
      var fieldName = getName(field);
      var seenField = seenFields.get(fieldName);

      if (seenField) {
        throw createUserError("Duplicated field name '".concat(fieldName, "' in the input object."), null, [field, seenField]);
      }

      var fieldID = schema.getFieldByName(inputType, fieldName);

      if (!fieldID) {
        throw createUserError("Unknown field '".concat(fieldName, "' on type '").concat(schema.getTypeString(inputType), "'."), null, [field]);
      }

      var fieldConfig = schema.getFieldConfig(fieldID);
      var fieldType = schema.assertInputType(fieldConfig.type);
      var fieldValue = transformValue(schema, field.value, fieldType, transformVariable);

      if (fieldValue.kind === 'Literal') {
        literalObject[field.name.value] = fieldValue.value;
      }

      fields.push({
        kind: 'ObjectFieldValue',
        loc: buildLocation(field.loc),
        name: fieldName,
        value: fieldValue
      });
      seenFields.set(fieldName, field);
      requiredFieldNames["delete"](fieldName);
      areAllFieldsScalar = areAllFieldsScalar && fieldValue.kind === 'Literal';
    });

    if (requiredFieldNames.size > 0) {
      var requiredFieldStr = Array.from(requiredFieldNames).map(function (item) {
        return "'".concat(item, "'");
      }).join(', ');
      throw createUserError("Missing non-optional field".concat(requiredFieldNames.size > 1 ? 's:' : '', " ").concat(requiredFieldStr, " for input type '").concat(schema.getTypeString(inputType), "'."), null, [ast]);
    }

    if (areAllFieldsScalar) {
      return {
        kind: 'Literal',
        loc: buildLocation(ast.loc),
        value: literalObject
      };
    } else {
      return {
        kind: 'ObjectValue',
        loc: buildLocation(ast.loc),
        fields: fields
      };
    }
  } else if (schema.isId(nullableType)) {
    // GraphQLID's parseLiteral() always returns the string value. However
    // the int/string distinction may be important at runtime, so this
    // transform parses int/string literals into the corresponding JS types.
    if (ast.kind === 'IntValue') {
      return {
        kind: 'Literal',
        loc: buildLocation(ast.loc),
        value: parseInt(ast.value, 10)
      };
    } else if (ast.kind === 'StringValue') {
      return {
        kind: 'Literal',
        loc: buildLocation(ast.loc),
        value: ast.value
      };
    } else {
      throw createUserError("Invalid value, expected a value matching type '".concat(schema.getTypeString(type), "'."), null, [ast]);
    }
  } else if (schema.isEnum(nullableType)) {
    var enumType = schema.assertEnumType(nullableType);
    var value = schema.parseLiteral(enumType, ast);

    if (value == null) {
      var suggestions = schema.getEnumValues(enumType); // parseLiteral() should return a non-null JavaScript value
      // if the ast value is valid for the type.

      throw createUserError("Expected a value matching type '".concat(schema.getTypeString(type), "'. Possible values: ").concat(orList(suggestions), "?'"), null, [ast]);
    }

    return {
      kind: 'Literal',
      loc: buildLocation(ast.loc),
      value: value
    };
  } else if (schema.isScalar(nullableType)) {
    var _value = schema.parseLiteral(schema.assertScalarType(nullableType), ast);

    if (_value == null) {
      // parseLiteral() should return a non-null JavaScript value
      // if the ast value is valid for the type.
      throw createUserError("Expected a value matching type '".concat(schema.getTypeString(type), "'."), null, [ast]);
    }

    return {
      kind: 'Literal',
      loc: buildLocation(ast.loc),
      value: _value
    };
  } else {
    throw createCompilerError("Unsupported type '".concat(schema.getTypeString(type), "' for input value, expected a GraphQLList, ") + 'GraphQLInputObjectType, GraphQLEnumType, or GraphQLScalarType.', null, [ast]);
  }
}
/**
 * @private
 */


function transformLiteralValue(ast, context) {
  switch (ast.kind) {
    case 'IntValue':
      return parseInt(ast.value, 10);

    case 'FloatValue':
      return parseFloat(ast.value);

    case 'StringValue':
      return ast.value;

    case 'BooleanValue':
      // Note: duplicated because Flow does not understand fall-through cases
      return ast.value;

    case 'EnumValue':
      // Note: duplicated because Flow does not understand fall-through cases
      return ast.value;

    case 'ListValue':
      return ast.values.map(function (item) {
        return transformLiteralValue(item, context);
      });

    case 'NullValue':
      return null;

    case 'ObjectValue':
      {
        var objectValue = {};
        ast.fields.forEach(function (field) {
          var fieldName = getName(field);
          var value = transformLiteralValue(field.value, context);
          objectValue[fieldName] = value;
        });
        return objectValue;
      }

    case 'Variable':
      throw createUserError('Unexpected variable where a literal (static) value is required.', null, [ast, context]);

    default:
      ast.kind;
      throw createCompilerError("Unknown ast kind '".concat(ast.kind, "'."), [ast]);
  }
}
/**
 * @private
 */


function buildArgumentDefinitions(variables) {
  return Array.from(variables.values(), function (_ref3) {
    var ast = _ref3.ast,
        name = _ref3.name,
        defaultValue = _ref3.defaultValue,
        type = _ref3.type;
    return {
      kind: 'LocalArgumentDefinition',
      loc: buildLocation(ast.loc),
      name: name,
      type: type,
      defaultValue: defaultValue
    };
  });
}
/**
 * @private
 */


function buildLocation(loc) {
  if (loc == null) {
    return {
      kind: 'Unknown'
    };
  }

  return {
    kind: 'Source',
    start: loc.start,
    end: loc.end,
    source: loc.source
  };
}
/**
 * @private
 */


function applyConditions(conditions, selections) {
  var nextSelections = selections;
  conditions.forEach(function (condition) {
    nextSelections = [(0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, condition), {}, {
      selections: nextSelections
    })];
  });
  return nextSelections;
}
/**
 * @private
 */


function getName(ast) {
  var _ast$name;

  var name = (_ast$name = ast.name) === null || _ast$name === void 0 ? void 0 : _ast$name.value;

  if (typeof name !== 'string') {
    throw createCompilerError("Expected ast node to have a 'name'.", null, [ast]);
  }

  return name;
}

function getTypeName(ast) {
  return ast ? print(ast) : 'Undefined Type Name';
}
/**
 * @private
 */


function getFragmentType(ast) {
  if (ast.kind === 'FragmentDefinition') {
    return ast.typeCondition;
  }

  throw createCompilerError('Expected ast node to be a FragmentDefinition node.', null, [ast]);
}

function checkFragmentSpreadTypeCompatibility(schema, fragmentType, parentType, fragmentName, fragmentTypeAST, parentTypeAST) {
  if (!schema.doTypesOverlap(fragmentType, schema.assertCompositeType(parentType))) {
    var nodes = [];

    if (parentTypeAST) {
      nodes.push(parentTypeAST);
    }

    if (fragmentTypeAST) {
      nodes.push(fragmentTypeAST);
    }

    var possibleConcreteTypes = schema.isAbstractType(parentType) ? Array.from(schema.getPossibleTypes(schema.assertAbstractType(parentType))) : [];
    var suggestedTypesMessage = '';

    if (possibleConcreteTypes.length !== 0) {
      suggestedTypesMessage = " Possible concrete types include ".concat(possibleConcreteTypes.sort().slice(0, 3).map(function (type) {
        return "'".concat(schema.getTypeString(type), "'");
      }).join(', '), ", etc.");
    }

    throw createUserError((fragmentName != null ? "Fragment '".concat(fragmentName, "' cannot be spread here as objects of ") : 'Fragment cannot be spread here as objects of ') + "type '".concat(schema.getTypeString(parentType), "' ") + "can never be of type '".concat(schema.getTypeString(fragmentType), "'.") + suggestedTypesMessage, null, nodes);
  }
}

module.exports = {
  parse: parse,
  transform: transform
};

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error


module.exports = {
  DEFAULT_HANDLE_KEY: ''
};

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error


var _interopRequireDefault = __webpack_require__(0);

var _createForOfIteratorHelper2 = _interopRequireDefault(__webpack_require__(4));

var _require = __webpack_require__(1),
    createCompilerError = _require.createCompilerError;

var _require2 = __webpack_require__(8),
    SchemaMetaFieldDef = _require2.SchemaMetaFieldDef,
    TypeMetaFieldDef = _require2.TypeMetaFieldDef;

/**
 * Find the definition of a field of the specified type using strict
 * resolution rules per the GraphQL spec.
 */
function getFieldDefinitionStrict(schema, parentType, fieldName) {
  var type = schema.getRawType(parentType);
  var queryType = schema.getQueryType();
  var isQueryType = queryType != null && schema.areEqualTypes(type, queryType);
  var hasTypeName = schema.isAbstractType(type) || schema.isObject(type);
  var schemaFieldDef;

  if (isQueryType && fieldName === SchemaMetaFieldDef.name) {
    schemaFieldDef = queryType != null ? schema.getFieldByName(queryType, '__schema') : null;
  } else if (isQueryType && fieldName === TypeMetaFieldDef.name) {
    schemaFieldDef = queryType != null ? schema.getFieldByName(queryType, '__type') : null;
  } else if (hasTypeName && fieldName === '__typename') {
    schemaFieldDef = schema.getFieldByName(schema.assertCompositeType(type), '__typename');
  } else if (hasTypeName && fieldName === '__id') {
    schemaFieldDef = schema.getFieldByName(schema.assertCompositeType(type), '__id');
  } else if (schema.isInterface(type) || schema.isObject(type)) {
    var compositeType = schema.assertCompositeType(type);

    if (schema.hasField(compositeType, fieldName)) {
      schemaFieldDef = schema.getFieldByName(compositeType, fieldName);
    } else {
      return null;
    }
  }

  return schemaFieldDef;
}
/**
 * Find the definition of a field of the specified type, first trying
 * the standard spec-compliant resolution process and falling back
 * to legacy mode that supports fat interfaces.
 */


function getFieldDefinitionLegacy(schema, parentType, fieldName, fieldAST) {
  var _schemaFieldDef;

  var schemaFieldDef = getFieldDefinitionStrict(schema, parentType, fieldName);

  if (!schemaFieldDef) {
    schemaFieldDef = getFieldDefinitionLegacyImpl(schema, parentType, fieldName, fieldAST);
  }

  return (_schemaFieldDef = schemaFieldDef) !== null && _schemaFieldDef !== void 0 ? _schemaFieldDef : null;
}
/**
 * @private
 */


function getFieldDefinitionLegacyImpl(schema, type, fieldName, fieldAST) {
  var rawType = schema.getRawType(type);

  if (schema.isAbstractType(rawType) && fieldAST && fieldAST.directives && fieldAST.directives.some(function (directive) {
    return getName(directive) === 'fixme_fat_interface';
  })) {
    var possibleTypes = schema.getPossibleTypes(schema.assertAbstractType(rawType));
    var schemaFieldDef;

    var _iterator = (0, _createForOfIteratorHelper2["default"])(possibleTypes),
        _step;

    try {
      var _loop = function _loop() {
        var possibleType = _step.value;
        var possibleField = schema.getFieldByName(possibleType, fieldName);

        if (possibleField) {
          // Fat interface fields can have differing arguments. Try to return
          // a field with matching arguments, but still return a field if the
          // arguments do not match.
          schemaFieldDef = possibleField;

          if (fieldAST && fieldAST.arguments) {
            var argumentsAllExist = fieldAST.arguments.every(function (argument) {
              return schema.getFieldArgByName(possibleField, getName(argument)) != null;
            });

            if (argumentsAllExist) {
              return "break";
            }
          }
        }
      };

      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _ret = _loop();

        if (_ret === "break") break;
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return schemaFieldDef;
  }
}
/**
 * @private
 */


function getName(ast) {
  var name = ast.name ? ast.name.value : null;

  if (typeof name !== 'string') {
    throw createCompilerError("Expected ast node to have a 'name'.", null, [ast]);
  }

  return name;
}

module.exports = {
  getFieldDefinitionLegacy: getFieldDefinitionLegacy,
  getFieldDefinitionStrict: getFieldDefinitionStrict
};

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error


var invariant = __webpack_require__(6);

var _require = __webpack_require__(31),
    DEFAULT_HANDLE_KEY = _require.DEFAULT_HANDLE_KEY;

var INDENT = '  ';
/**
 * Converts an IR node into a GraphQL string. Custom Relay
 * extensions (directives) are not supported; to print fragments with
 * variables or fragment spreads with arguments, transform the node
 * prior to printing.
 */

function print(schema, node) {
  switch (node.kind) {
    case 'Fragment':
      return "fragment ".concat(node.name, " on ").concat(schema.getTypeString(node.type)) + printFragmentArgumentDefinitions(schema, node.argumentDefinitions) + printDirectives(schema, node.directives) + printSelections(schema, node, '', {}) + '\n';

    case 'Root':
      return "".concat(node.operation, " ").concat(node.name) + printArgumentDefinitions(schema, node.argumentDefinitions) + printDirectives(schema, node.directives) + printSelections(schema, node, '', {}) + '\n';

    case 'SplitOperation':
      return "SplitOperation ".concat(node.name, " on ").concat(schema.getTypeString(node.type)) + printSelections(schema, node, '', {}) + '\n';

    default:
      node;
       true ?  true ? invariant(false, 'IRPrinter: Unsupported IR node `%s`.', node.kind) : undefined : undefined;
  }
}

function printSelections(schema, node, indent, options) {
  var selections = node.selections;

  if (selections == null) {
    return '';
  }

  var printed = selections.map(function (selection) {
    return printSelection(schema, selection, indent, options);
  });
  return printed.length ? " {\n".concat(indent + INDENT).concat(printed.join('\n' + indent + INDENT), "\n").concat(indent).concat((options === null || options === void 0 ? void 0 : options.isClientExtension) === true ? '# ' : '', "}") : '';
}
/**
 * Prints a field without subselections.
 */


function printField(schema, field, options) {
  var _options$parentDirect;

  var parentDirectives = (_options$parentDirect = options === null || options === void 0 ? void 0 : options.parentDirectives) !== null && _options$parentDirect !== void 0 ? _options$parentDirect : '';
  var isClientExtension = (options === null || options === void 0 ? void 0 : options.isClientExtension) === true;
  return (isClientExtension ? '# ' : '') + (field.alias === field.name ? field.name : field.alias + ': ' + field.name) + printArguments(schema, field.args) + parentDirectives + printDirectives(schema, field.directives) + printHandles(schema, field);
}

function printSelection(schema, selection, indent, options) {
  var _options$parentDirect2;

  var str;
  var parentDirectives = (_options$parentDirect2 = options === null || options === void 0 ? void 0 : options.parentDirectives) !== null && _options$parentDirect2 !== void 0 ? _options$parentDirect2 : '';
  var isClientExtension = (options === null || options === void 0 ? void 0 : options.isClientExtension) === true;

  if (selection.kind === 'LinkedField') {
    str = printField(schema, selection, {
      parentDirectives: parentDirectives,
      isClientExtension: isClientExtension
    });
    str += printSelections(schema, selection, indent + INDENT, {
      isClientExtension: isClientExtension
    });
  } else if (selection.kind === 'ModuleImport') {
    str = selection.selections.map(function (matchSelection) {
      return printSelection(schema, matchSelection, indent, {
        parentDirectives: parentDirectives,
        isClientExtension: isClientExtension
      });
    }).join('\n' + indent + INDENT);
  } else if (selection.kind === 'ScalarField') {
    str = printField(schema, selection, {
      parentDirectives: parentDirectives,
      isClientExtension: isClientExtension
    });
  } else if (selection.kind === 'InlineFragment') {
    str = '';

    if (isClientExtension) {
      str += '# ';
    }

    str += '... on ' + schema.getTypeString(selection.typeCondition);
    str += parentDirectives;
    str += printDirectives(schema, selection.directives);
    str += printSelections(schema, selection, indent + INDENT, {
      isClientExtension: isClientExtension
    });
  } else if (selection.kind === 'FragmentSpread') {
    str = '';

    if (isClientExtension) {
      str += '# ';
    }

    str += '...' + selection.name;
    str += parentDirectives;
    str += printFragmentArguments(schema, selection.args);
    str += printDirectives(schema, selection.directives);
  } else if (selection.kind === 'InlineDataFragmentSpread') {
    str = "# ".concat(selection.name, " @inline") + "\n".concat(indent).concat(INDENT, "...") + parentDirectives + printSelections(schema, selection, indent + INDENT, {});
  } else if (selection.kind === 'Condition') {
    var value = printValue(schema, selection.condition, null); // For Flow

    !(value != null) ?  true ? invariant(false, 'IRPrinter: Expected a variable for condition, got a literal `null`.') : undefined : void 0;
    var condStr = selection.passingValue ? ' @include' : ' @skip';
    condStr += '(if: ' + value + ')';
    condStr += parentDirectives; // For multi-selection conditions, pushes the condition down to each

    var subSelections = selection.selections.map(function (sel) {
      return printSelection(schema, sel, indent, {
        parentDirectives: condStr,
        isClientExtension: isClientExtension
      });
    });
    str = subSelections.join('\n' + indent + INDENT);
  } else if (selection.kind === 'Stream') {
    var streamStr = parentDirectives;
    streamStr += " @stream(label: \"".concat(selection.label, "\"");

    if (selection["if"] !== null) {
      var _printValue;

      streamStr += ", if: ".concat((_printValue = printValue(schema, selection["if"], null)) !== null && _printValue !== void 0 ? _printValue : '');
    }

    if (selection.initialCount !== null) {
      var _printValue2;

      streamStr += ", initial_count: ".concat((_printValue2 = printValue(schema, selection.initialCount, null)) !== null && _printValue2 !== void 0 ? _printValue2 : '');
    }

    if (selection.useCustomizedBatch !== null) {
      var _printValue3;

      streamStr += ", use_customized_batch: ".concat((_printValue3 = printValue(schema, selection.useCustomizedBatch, null)) !== null && _printValue3 !== void 0 ? _printValue3 : 'false');
    }

    streamStr += ')';

    var _subSelections = selection.selections.map(function (sel) {
      return printSelection(schema, sel, indent, {
        parentDirectives: streamStr,
        isClientExtension: isClientExtension
      });
    });

    str = _subSelections.join('\n' + INDENT);
  } else if (selection.kind === 'Defer') {
    var deferStr = parentDirectives;
    deferStr += " @defer(label: \"".concat(selection.label, "\"");

    if (selection["if"] !== null) {
      var _printValue4;

      deferStr += ", if: ".concat((_printValue4 = printValue(schema, selection["if"], null)) !== null && _printValue4 !== void 0 ? _printValue4 : '');
    }

    deferStr += ')';

    if (selection.selections.every(function (subSelection) {
      return subSelection.kind === 'InlineFragment' || subSelection.kind === 'FragmentSpread';
    })) {
      var _subSelections2 = selection.selections.map(function (sel) {
        return printSelection(schema, sel, indent, {
          parentDirectives: deferStr,
          isClientExtension: isClientExtension
        });
      });

      str = _subSelections2.join('\n' + INDENT);
    } else {
      str = '...' + deferStr;
      str += printSelections(schema, selection, indent + INDENT, {
        isClientExtension: isClientExtension
      });
    }
  } else if (selection.kind === 'ClientExtension') {
    !(isClientExtension === false) ?  true ? invariant(false, 'IRPrinter: Did not expect to encounter a ClientExtension node ' + 'as a descendant of another ClientExtension node.') : undefined : void 0;
    str = '# Client-only selections:\n' + indent + INDENT + selection.selections.map(function (sel) {
      return printSelection(schema, sel, indent, {
        parentDirectives: parentDirectives,
        isClientExtension: true
      });
    }).join('\n' + indent + INDENT);
  } else {
    selection;
     true ?  true ? invariant(false, 'IRPrinter: Unknown selection kind `%s`.', selection.kind) : undefined : undefined;
  }

  return str;
}

function printArgumentDefinitions(schema, argumentDefinitions) {
  var printed = argumentDefinitions.map(function (def) {
    var str = "$".concat(def.name, ": ").concat(schema.getTypeString(def.type));

    if (def.defaultValue != null) {
      str += ' = ' + printLiteral(schema, def.defaultValue, def.type);
    }

    return str;
  });
  return printed.length ? "(\n".concat(INDENT).concat(printed.join('\n' + INDENT), "\n)") : '';
}

function printFragmentArgumentDefinitions(schema, argumentDefinitions) {
  var printed;
  argumentDefinitions.forEach(function (def) {
    if (def.kind !== 'LocalArgumentDefinition') {
      return;
    }

    printed = printed || [];
    var str = "".concat(def.name, ": {type: \"").concat(schema.getTypeString(def.type), "\"");

    if (def.defaultValue != null) {
      str += ", defaultValue: ".concat(printLiteral(schema, def.defaultValue, def.type));
    }

    str += '}'; // $FlowFixMe[incompatible-use]

    printed.push(str);
  });
  return printed && printed.length ? " @argumentDefinitions(\n".concat(INDENT).concat(printed.join('\n' + INDENT), "\n)") : '';
}

function printHandles(schema, field) {
  if (!field.handles) {
    return '';
  }

  var printed = field.handles.map(function (handle) {
    // For backward compatibility.
    var key = handle.key === DEFAULT_HANDLE_KEY ? '' : ", key: \"".concat(handle.key, "\"");
    var filters = handle.filters == null ? '' : ", filters: ".concat(JSON.stringify(Array.from(handle.filters).sort()));
    var handleArgs = handle.handleArgs == null ? '' : ", handleArgs: ".concat(printArguments(schema, handle.handleArgs));
    return "@__clientField(handle: \"".concat(handle.name, "\"").concat(key).concat(filters).concat(handleArgs, ")");
  });
  return printed.length ? ' ' + printed.join(' ') : '';
}

function printDirectives(schema, directives) {
  var printed = directives.map(function (directive) {
    return '@' + directive.name + printArguments(schema, directive.args);
  });
  return printed.length ? ' ' + printed.join(' ') : '';
}

function printFragmentArguments(schema, args) {
  var printedArgs = printArguments(schema, args);

  if (!printedArgs.length) {
    return '';
  }

  return " @arguments".concat(printedArgs);
}

function printArguments(schema, args) {
  var printed = [];
  args.forEach(function (arg) {
    var printedValue = printValue(schema, arg.value, arg.type);

    if (printedValue != null) {
      printed.push(arg.name + ': ' + printedValue);
    }
  });
  return printed.length ? '(' + printed.join(', ') + ')' : '';
}

function printValue(schema, value, type) {
  if (type != null && schema.isNonNull(type)) {
    type = schema.getNullableType(type);
  }

  if (value.kind === 'Variable') {
    return '$' + value.variableName;
  } else if (value.kind === 'ObjectValue') {
    var inputType = type != null ? schema.asInputObjectType(type) : null;
    var pairs = value.fields.map(function (field) {
      var fieldConfig = inputType != null ? schema.hasField(inputType, field.name) ? schema.getFieldConfig(schema.expectField(inputType, field.name)) : null : null;
      var innerValue = printValue(schema, field.value, fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.type);
      return innerValue == null ? null : field.name + ': ' + innerValue;
    }).filter(Boolean);
    return '{' + pairs.join(', ') + '}';
  } else if (value.kind === 'ListValue') {
    !(type && schema.isList(type)) ?  true ? invariant(false, 'GraphQLIRPrinter: Need a type in order to print arrays.') : undefined : void 0;
    var innerType = schema.getListItemType(type);
    return "[".concat(value.items.map(function (i) {
      return printValue(schema, i, innerType);
    }).join(', '), "]");
  } else if (value.value != null) {
    return printLiteral(schema, value.value, type);
  } else {
    return null;
  }
}

function printLiteral(schema, value, type) {
  if (value == null) {
    var _JSON$stringify;

    return (_JSON$stringify = JSON.stringify(value)) !== null && _JSON$stringify !== void 0 ? _JSON$stringify : 'null';
  }

  if (type != null && schema.isNonNull(type)) {
    type = schema.getNullableType(type);
  }

  if (type && schema.isEnum(type)) {
    var _JSON$stringify2;

    var result = schema.serialize(schema.assertEnumType(type), value);

    if (result == null && typeof value === 'string') {
      // For backwards compatibility, print invalid input values as-is. This
      // can occur with literals defined as an @argumentDefinitions
      // defaultValue.
      result = value;
    }

    !(typeof result === 'string') ?  true ? invariant(false, 'IRPrinter: Expected value of type %s to be a valid enum value, got `%s`.', schema.getTypeString(type), (_JSON$stringify2 = JSON.stringify(value)) !== null && _JSON$stringify2 !== void 0 ? _JSON$stringify2 : 'null') : undefined : void 0;
    return result;
  } else if (type && (schema.isId(type) || schema.isInt(type))) {
    var _JSON$stringify3;

    return (_JSON$stringify3 = JSON.stringify(value)) !== null && _JSON$stringify3 !== void 0 ? _JSON$stringify3 : '';
  } else if (type && schema.isScalar(type)) {
    var _JSON$stringify4;

    var _result = schema.serialize(schema.assertScalarType(type), value);

    return (_JSON$stringify4 = JSON.stringify(_result)) !== null && _JSON$stringify4 !== void 0 ? _JSON$stringify4 : '';
  } else if (Array.isArray(value)) {
    !(type && schema.isList(type)) ?  true ? invariant(false, 'IRPrinter: Need a type in order to print arrays.') : undefined : void 0;
    var itemType = schema.getListItemType(type);
    return '[' + value.map(function (item) {
      return printLiteral(schema, item, itemType);
    }).join(', ') + ']';
  } else if (type && schema.isList(type) && value != null) {
    // Not an array, but still a list. Treat as list-of-one as per spec 3.1.7:
    // http://facebook.github.io/graphql/October2016/#sec-Lists
    return printLiteral(schema, value, schema.getListItemType(type));
  } else if (typeof value === 'object' && value != null) {
    var fields = [];
    !(type && schema.isInputObject(type)) ?  true ? invariant(false, 'IRPrinter: Need an InputObject type to print objects.') : undefined : void 0;
    var inputType = schema.assertInputObjectType(type);

    for (var key in value) {
      if (value.hasOwnProperty(key)) {
        var fieldConfig = schema.getFieldConfig(schema.expectField(inputType, key));
        fields.push(key + ': ' + printLiteral(schema, value[key], fieldConfig.type));
      }
    }

    return '{' + fields.join(', ') + '}';
  } else {
    var _JSON$stringify5;

    return (_JSON$stringify5 = JSON.stringify(value)) !== null && _JSON$stringify5 !== void 0 ? _JSON$stringify5 : 'null';
  }
}

module.exports = {
  print: print,
  printField: printField,
  printArguments: printArguments,
  printDirectives: printDirectives
};

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error


function argumentContainsVariables(arg) {
  if (arg == null) {
    return false;
  }

  switch (arg.kind) {
    case 'Variable':
      return true;

    case 'Literal':
      return false;

    case 'ListValue':
      return arg.items.some(argumentContainsVariables);

    case 'ObjectValue':
      return arg.fields.some(argumentContainsVariables);

    default:
      arg.kind;
      return false;
  }
}

module.exports = argumentContainsVariables;

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */


var _interopRequireDefault = __webpack_require__(0);

var _createForOfIteratorHelper2 = _interopRequireDefault(__webpack_require__(4));

function sortObjectByKey(obj) {
  if (obj == null) {
    return obj;
  }

  var result = {};

  var _iterator = (0, _createForOfIteratorHelper2["default"])(Object.keys(obj).sort()),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _key = _step.value;
      result[_key] = obj[_key];
    } // $FlowFixMe[incompatible-return]

  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return result;
}

module.exports = sortObjectByKey;

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error

/**
 * Marks a string of code as code to be replaced later.
 */

function moduleDependency(code) {
  return "@@MODULE_START@@".concat(code, "@@MODULE_END@@");
}
/**
 * After JSON.stringify'ing some code that contained parts marked with `mark()`,
 * this post-processes the JSON to convert the marked code strings to raw code.
 *
 * Example:
 *   CodeMarker.postProcess(
 *     JSON.stringify({code: CodeMarker.mark('alert(1)')})
 *   )
 */


function postProcess(json, printModule) {
  return json.replace(/"@@MODULE_START@@(.*?)@@MODULE_END@@"/g, function (_, moduleName) {
    return printModule(moduleName);
  });
}
/**
 * Transforms a value such that any transitive CodeMarker strings are replaced
 * with the value of the named module in the given module map.
 */


function transform(node, moduleMap) {
  if (node == null) {
    return node;
  } else if (Array.isArray(node)) {
    return node.map(function (item) {
      return transform(item, moduleMap);
    });
  } else if (typeof node === 'object') {
    var next = {};
    Object.keys(node).forEach(function (key) {
      next[key] = transform(node[key], moduleMap);
    });
    return next;
  } else if (typeof node === 'string') {
    var match = /^@@MODULE_START@@(.*?)@@MODULE_END@@$/.exec(node);

    if (match != null) {
      var moduleName = match[1];

      if (moduleMap.hasOwnProperty(moduleName)) {
        return moduleMap[moduleName];
      } else {
        throw new Error("Could not find a value for CodeMarker value '".concat(moduleName, "', ") + 'make sure to supply one in the module mapping.');
      }
    } else if (node.indexOf('@@MODULE_START') >= 0) {
      throw new Error("Found unprocessed CodeMarker value '".concat(node, "'."));
    }

    return node;
  } else {
    // mixed
    return node;
  }
}

module.exports = {
  moduleDependency: moduleDependency,
  postProcess: postProcess,
  transform: transform
};

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c