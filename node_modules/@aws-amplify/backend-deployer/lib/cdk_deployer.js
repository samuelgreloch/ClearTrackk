import stream from 'stream';
import readline from 'readline';
import { AmplifyError, AmplifyUserError, CDKContextKey, } from '@aws-amplify/platform-core';
import { dirname } from 'path';
/**
 * Commands that can be invoked
 */
var InvokableCommand;
(function (InvokableCommand) {
    InvokableCommand["DEPLOY"] = "deploy";
    InvokableCommand["DESTROY"] = "destroy";
    InvokableCommand["SYNTH"] = "synth";
})(InvokableCommand || (InvokableCommand = {}));
/**
 * Invokes CDK command via execa
 */
export class CDKDeployer {
    cdkErrorMapper;
    backendLocator;
    packageManagerController;
    relativeCloudAssemblyLocation = '.amplify/artifacts/cdk.out';
    /**
     * Instantiates instance of CDKDeployer
     */
    constructor(cdkErrorMapper, backendLocator, packageManagerController) {
        this.cdkErrorMapper = cdkErrorMapper;
        this.backendLocator = backendLocator;
        this.packageManagerController = packageManagerController;
    }
    /**
     * Invokes cdk deploy command
     */
    deploy = async (backendId, deployProps) => {
        const cdkCommandArgs = [];
        if (backendId.type === 'sandbox') {
            cdkCommandArgs.push('--hotswap-fallback');
            cdkCommandArgs.push('--method=direct');
            if (deployProps?.secretLastUpdated) {
                cdkCommandArgs.push('--context', `secretLastUpdated=${deployProps.secretLastUpdated.getTime()}`);
            }
        }
        if (deployProps?.profile) {
            cdkCommandArgs.push('--profile', deployProps.profile);
        }
        // first synth with the backend definition but suppress any errors.
        // We want to show errors from the TS compiler rather than the ESBuild as
        // TS errors are more relevant (Library validations are type reliant).
        const startTime = Date.now();
        let synthError = undefined;
        try {
            await this.tryInvokeCdk(InvokableCommand.SYNTH, backendId, this.getAppCommand(), cdkCommandArgs.concat('--quiet') // don't print the CFN template to stdout
            );
        }
        catch (e) {
            synthError = e;
        }
        // CDK prints synth time in seconds rounded to 2 decimal places. Here we duplicate that behavior.
        const synthTimeSeconds = Math.floor((Date.now() - startTime) / 10) / 100;
        // then run type checks
        try {
            await this.invokeTsc(deployProps);
        }
        catch (typeError) {
            if (synthError &&
                AmplifyError.isAmplifyError(typeError) &&
                typeError.cause?.message.match(/Cannot find module '\$amplify\/env\/.*' or its corresponding type declarations/)) {
                // synth has failed and we don't have auto generated function environment definition files. This
                // resulted in the exception caught here, which is not very useful for the customers.
                // We instead throw the synth error for customers to fix what caused the synth to fail.
                throw synthError;
            }
            throw typeError;
        }
        // If somehow TSC was successful but synth wasn't, we now throw to surface the synth error
        if (synthError) {
            throw synthError;
        }
        // then deploy with the cloud assembly that was generated during synth
        const deployResult = await this.tryInvokeCdk(InvokableCommand.DEPLOY, backendId, this.relativeCloudAssemblyLocation, cdkCommandArgs);
        return {
            deploymentTimes: {
                synthesisTime: synthTimeSeconds,
                totalTime: synthTimeSeconds + (deployResult?.deploymentTimes?.totalTime || 0),
            },
        };
    };
    /**
     * Invokes cdk destroy command
     */
    destroy = async (backendId, destroyProps) => {
        const cdkCommandArgs = ['--force'];
        if (destroyProps?.profile) {
            cdkCommandArgs.push('--profile', destroyProps.profile);
        }
        return this.tryInvokeCdk(InvokableCommand.DESTROY, backendId, this.getAppCommand(), cdkCommandArgs);
    };
    /**
     * Wrapper for the child process executor. Helps in unit testing as node:test framework
     * doesn't have capabilities to mock exported functions like `execa` as of right now.
     */
    executeCommand = async (commandArgs, options = {
        redirectStdoutToStderr: false,
    }) => {
        // We let the stdout and stdin inherit and streamed to parent process but pipe
        // the stderr and use it to throw on failure. This is to prevent actual
        // actionable errors being hidden among the stdout. Moreover execa errors are
        // useless when calling CLIs unless you made execa calling error.
        let aggregatedStderr = '';
        const aggregatorStderrStream = new stream.Writable();
        aggregatorStderrStream._write = function (chunk, encoding, done) {
            aggregatedStderr += chunk;
            done();
        };
        const childProcess = this.packageManagerController.runWithPackageManager(commandArgs, process.cwd(), {
            stdin: 'inherit',
            stdout: 'pipe',
            stderr: 'pipe',
            // Piping the output by default strips off the color. This is a workaround to
            // preserve the color being piped to parent process.
            extendEnv: true,
            env: { FORCE_COLOR: '1' },
        });
        childProcess.stderr?.pipe(aggregatorStderrStream);
        if (options?.redirectStdoutToStderr) {
            childProcess.stdout?.pipe(aggregatorStderrStream);
        }
        else {
            childProcess.stdout?.pipe(process.stdout);
        }
        const cdkOutput = { deploymentTimes: {} };
        if (childProcess.stdout) {
            await this.populateCDKOutputFromStdout(cdkOutput, childProcess.stdout);
        }
        try {
            await childProcess;
            return cdkOutput;
            // eslint-disable-next-line amplify-backend-rules/propagate-error-cause
        }
        catch (error) {
            // swallow execa error if the cdk cli ran and produced some stderr.
            // Most of the time this error is noise(basically child exited with exit code...)
            // bubbling this up to customers add confusion (Customers don't need to know we are running IPC calls
            // and their exit codes printed while sandbox continue to run). Hence we explicitly don't pass error in the cause
            // rather throw the entire stderr for clients to figure out what to do with it.
            // However if the cdk process didn't run or produced no output, then we have nothing to go on with. So we throw
            // this error to aid in some debugging.
            if (aggregatedStderr.trim()) {
                // If the string is more than 65KB, truncate and keep the last portion.
                // eslint-disable-next-line amplify-backend-rules/prefer-amplify-errors
                throw new Error(this.truncateString(aggregatedStderr, 65000));
            }
            else {
                throw error;
            }
        }
    };
    truncateString = (str, size) => {
        const encoder = new TextEncoder();
        const decoder = new TextDecoder();
        const encoded = encoder.encode(str);
        return encoded.byteLength > size
            ? '...truncated...' + decoder.decode(encoded.slice(-size))
            : str;
    };
    getAppCommand = () => this.packageManagerController.getCommand([
        'tsx',
        this.backendLocator.locate(),
    ]);
    invokeTsc = async (deployProps) => {
        if (!deployProps?.validateAppSources) {
            return;
        }
        try {
            await this.executeCommand([
                'tsc',
                '--showConfig',
                '--project',
                dirname(this.backendLocator.locate()),
            ], { redirectStdoutToStderr: true } // TSC prints errors to stdout by default
            );
        }
        catch (error) {
            // If we cannot load ts config, turn off type checking
            return;
        }
        try {
            await this.executeCommand([
                'tsc',
                '--noEmit',
                '--skipLibCheck',
                // pointing the project arg to the amplify backend directory will use the tsconfig present in that directory
                '--project',
                dirname(this.backendLocator.locate()),
            ], { redirectStdoutToStderr: true } // TSC prints errors to stdout by default
            );
        }
        catch (err) {
            throw new AmplifyUserError('SyntaxError', {
                message: 'TypeScript validation check failed.',
                resolution: 'Fix the syntax and type errors in your backend definition.',
            }, err instanceof Error ? err : undefined);
        }
    };
    /**
     * calls invokeCDK and wrap it in a try catch
     */
    tryInvokeCdk = async (invokableCommand, backendId, appArgument, additionalArguments) => {
        try {
            return await this.invokeCdk(invokableCommand, backendId, appArgument, additionalArguments);
        }
        catch (err) {
            throw this.cdkErrorMapper.getAmplifyError(err);
        }
    };
    /**
     * Executes a CDK command
     */
    invokeCdk = async (invokableCommand, backendId, appArgument, additionalArguments) => {
        // Basic args
        const cdkCommandArgs = [
            'cdk',
            invokableCommand.toString(),
            // This is unfortunate. CDK writes everything to stderr without `--ci` flag and we need to differentiate between the two.
            // See https://github.com/aws/aws-cdk/issues/7717 for more details.
            '--ci',
            '--app',
            appArgument,
            '--all',
            '--output',
            this.relativeCloudAssemblyLocation,
        ];
        // Add context information if available
        cdkCommandArgs.push('--context', `${CDKContextKey.BACKEND_NAMESPACE}=${backendId.namespace}`, '--context', `${CDKContextKey.BACKEND_NAME}=${backendId.name}`);
        if (backendId.type !== 'sandbox') {
            cdkCommandArgs.push('--require-approval', 'never');
        }
        cdkCommandArgs.push('--context', `${CDKContextKey.DEPLOYMENT_TYPE}=${backendId.type}`);
        if (additionalArguments) {
            cdkCommandArgs.push(...additionalArguments);
        }
        return await this.executeCommand(cdkCommandArgs);
    };
    populateCDKOutputFromStdout = async (output, stdout) => {
        const regexTotalTime = /✨ {2}Total time: (\d*\.*\d*)s.*/;
        const regexSynthTime = /✨ {2}Synthesis time: (\d*\.*\d*)s/;
        const reader = readline.createInterface(stdout);
        for await (const line of reader) {
            if (line.includes('✨')) {
                // Good chance that it contains timing information
                const totalTime = line.match(regexTotalTime);
                if (totalTime && totalTime.length > 1 && !isNaN(+totalTime[1])) {
                    output.deploymentTimes.totalTime = +totalTime[1];
                }
                const synthTime = line.match(regexSynthTime);
                if (synthTime && synthTime.length > 1 && !isNaN(+synthTime[1])) {
                    output.deploymentTimes.synthesisTime = +synthTime[1];
                }
            }
        }
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2RrX2RlcGxveWVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2Nka19kZXBsb3llci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLE1BQU0sTUFBTSxRQUFRLENBQUM7QUFDNUIsT0FBTyxRQUFRLE1BQU0sVUFBVSxDQUFDO0FBYWhDLE9BQU8sRUFDTCxZQUFZLEVBQ1osZ0JBQWdCLEVBRWhCLGFBQWEsR0FDZCxNQUFNLDRCQUE0QixDQUFDO0FBQ3BDLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFFL0I7O0dBRUc7QUFDSCxJQUFLLGdCQUlKO0FBSkQsV0FBSyxnQkFBZ0I7SUFDbkIscUNBQWlCLENBQUE7SUFDakIsdUNBQW1CLENBQUE7SUFDbkIsbUNBQWUsQ0FBQTtBQUNqQixDQUFDLEVBSkksZ0JBQWdCLEtBQWhCLGdCQUFnQixRQUlwQjtBQUVEOztHQUVHO0FBQ0gsTUFBTSxPQUFPLFdBQVc7SUFNSDtJQUNBO0lBQ0E7SUFQRiw2QkFBNkIsR0FBRyw0QkFBNEIsQ0FBQztJQUM5RTs7T0FFRztJQUNILFlBQ21CLGNBQThCLEVBQzlCLGNBQThCLEVBQzlCLHdCQUFrRDtRQUZsRCxtQkFBYyxHQUFkLGNBQWMsQ0FBZ0I7UUFDOUIsbUJBQWMsR0FBZCxjQUFjLENBQWdCO1FBQzlCLDZCQUF3QixHQUF4Qix3QkFBd0IsQ0FBMEI7SUFDbEUsQ0FBQztJQUNKOztPQUVHO0lBQ0gsTUFBTSxHQUFHLEtBQUssRUFBRSxTQUE0QixFQUFFLFdBQXlCLEVBQUUsRUFBRTtRQUN6RSxNQUFNLGNBQWMsR0FBYSxFQUFFLENBQUM7UUFDcEMsSUFBSSxTQUFTLENBQUMsSUFBSSxLQUFLLFNBQVMsRUFBRTtZQUNoQyxjQUFjLENBQUMsSUFBSSxDQUFDLG9CQUFvQixDQUFDLENBQUM7WUFDMUMsY0FBYyxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO1lBQ3ZDLElBQUksV0FBVyxFQUFFLGlCQUFpQixF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QUMzRCxNQUFNLE1BQU0sR0FBRyxRQUFRLENBQUMsZUFBZSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ2hELElBQUksS0FBSyxFQUFFLE1BQU0sSUFBSSxJQUFJLE1BQU0sRUFBRTtZQUMvQixJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLEVBQUU7Z0JBQ3RCLGtEQUFrRDtnQkFDbEQsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxjQUFjLENBQUMsQ0FBQztnQkFDN0MsSUFBSSxTQUFTLElBQUksU0FBUyxDQUFDLE1BQU0sR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRTtvQkFDOUQsTUFBTSxDQUFDLGVBQWUsQ0FBQyxTQUFTLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7aUJBQ2xEO2dCQUNELE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsY0FBYyxDQUFDLENBQUM7Z0JBQzdDLElBQUksU0FBUyxJQUFJLFNBQVMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUU7b0JBQzlELE1BQU0sQ0FBQyxlQUFlLENBQUMsYUFBYSxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO2lCQUN0RDthQUNGO1NBQ0Y7SUFDSCxDQUFDLENBQUM7Q0FDSCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBzdHJlYW0gZnJvbSAnc3RyZWFtJztcbmltcG9ydCByZWFkbGluZSBmcm9tICdyZWFkbGluZSc7XG5pbXBvcnQge1xuICBCYWNrZW5kRGVwbG95ZXIsXG4gIERlcGxveVByb3BzLFxuICBEZXBsb3lSZXN1bHQsXG4gIERlc3Ryb3lQcm9wcyxcbiAgRGVzdHJveVJlc3VsdCxcbn0gZnJvbSAnLi9jZGtfZGVwbG95ZXJfc2luZ2xldG9uX2ZhY3RvcnkuanMnO1xuaW1wb3J0IHsgQ0RLRGVwbG95bWVudEVycm9yLCBDZGtFcnJvck1hcHBlciB9IGZyb20gJy4vY2RrX2Vycm9yX21hcHBlci5qcyc7XG5pbXBvcnQge1xuICBCYWNrZW5kSWRlbnRpZmllcixcbiAgdHlwZSBQYWNrYWdlTWFuYWdlckNvbnRyb2xsZXIsXG59IGZyb20gJ0Bhd3MtYW1wbGlmeS9wbHVnaW4tdHlwZXMnO1xuaW1wb3J0IHtcbiAgQW1wbGlmeUVycm9yLFxuICBBbXBsaWZ5VXNlckVycm9yLFxuICBCYWNrZW5kTG9jYXRvcixcbiAgQ0RLQ29udGV4dEtleSxcbn0gZnJvbSAnQGF3cy1hbXBsaWZ5L3BsYXRmb3JtLWNvcmUnO1xuaW1wb3J0IHsgZGlybmFtZSB9IGZyb20gJ3BhdGgnO1xuXG4vKipcbiAqIENvbW1hbmRzIHRoYXQgY2FuIGJlIGludm9rZWRcbiAqL1xuZW51bSBJbnZva2FibGVDb21tYW5kIHtcbiAgREVQTE9ZID0gJ2RlcGxveScsXG4gIERFU1RST1kgPSAnZGVzdHJveScsXG4gIFNZTlRIID0gJ3N5bnRoJyxcbn1cblxuLyoqXG4gKiBJbnZva2VzIENESyBjb21tYW5kIHZpYSBleGVjYVxuICovXG5leHBvcnQgY2xhc3MgQ0RLRGVwbG95ZXIgaW1wbGVtZW50cyBCYWNrZW5kRGVwbG95ZXIge1xuICBwcml2YXRlIHJlYWRvbmx5IHJlbGF0aXZlQ2xvdWRBc3NlbWJseUxvY2F0aW9uID0gJy5hbXBsaWZ5L2FydGlmYWN0cy9jZGsub3V0JztcbiAgLyoqXG4gICAqIEluc3RhbnRpYXRlcyBpbnN0YW5jZSBvZiBDREtEZXBsb3llclxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBjZGtFcnJvck1hcHBlcjogQ2RrRXJyb3JNYXBwZXIsXG4gICAgcHJpdmF0ZSByZWFkb25seSBiYWNrZW5kTG9jYXRvcjogQmFja2VuZExvY2F0b3IsXG4gICAgcHJpdmF0ZSByZWFkb25seSBwYWNrYWdlTWFuYWdlckNvbnRyb2xsZXI6IFBhY2thZ2VNYW5hZ2VyQ29udHJvbGxlclxuICApIHt9XG4gIC8qKlxuICAgKiBJbnZva2VzIGNkayBkZXBsb3kgY29tbWFuZFxuICAgKi9cbiAgZGVwbG95ID0gYXN5bmMgKGJhY2tlbmRJZDogQmFja2VuZElkZW50aWZpZXIsIGRlcGxveVByb3BzPzogRGVwbG95UHJvcHMpID0+IHtcbiAgICBjb25zdCBjZGtDb21tYW5kQXJnczogc3RyaW5nW10gPSBbXTtcbiAgICBpZiAoYmFja2VuZElkLnR5cGUgPT09ICdzYW5kYm94Jykge1xuICAgICAgY2RrQ29tbWFuZEFyZ3MucHVzaCgnLS1ob3Rzd2FwLWZhbGxiYWNrJyk7XG4gICAgICBjZGtDb21tYW5kQXJncy5wdXNoKCctLW1ldGhvZD1kaXJlY3QnKTtcbiAgICAgIGlmIChkZXBsb3lQcm9wcz8uc2VjcmV0TGFzdFVwZGF0ZWQpIHtcbiAgICAgICAgY2RrQ29tbWFuZEFyZ3MucHVzaChcbiAgICAgICAgICAnLS1jb250ZXh0JyxcbiAgICAgICAgICBgc2VjcmV0TGFzdFVwZGF0ZWQ9JHtkZXBsb3lQcm9wcy5zZWNyZXRMYXN0VXBkYXRlZC5nZXRUaW1lKCl9YFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChkZXBsb3lQcm9wcz8ucHJvZmlsZSkge1xuICAgICAgY2RrQ29tbWFuZEFyZ3MucHVzaCgnLS1wcm9maWxlJywgZGVwbG95UHJvcHMucHJvZmlsZSk7XG4gICAgfVxuXG4gICAgLy8gZmlyc3Qgc3ludGggd2l0aCB0aGUgYmFja2VuZCBkZWZpbml0aW9uIGJ1dCBzdXBwcmVzcyBhbnkgZXJyb3JzLlxuICAgIC8vIFdlIHdhbnQgdG8gc2hvdyBlcnJvcnMgZnJvbSB0aGUgVFMgY29tcGlsZXIgcmF0aGVyIHRoYW4gdGhlIEVTQnVpbGQgYXNcbiAgICAvLyBUUyBlcnJvcnMgYXJlIG1vcmUgcmVsZXZhbnQgKExpYnJhcnkgdmFsaWRhdGlvbnMgYXJlIHR5cGUgcmVsaWFudCkuXG4gICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBsZXQgc3ludGhFcnJvciA9IHVuZGVmaW5lZDtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy50cnlJbnZva2VDZGsoXG4gICAgICAgIEludm9rYWJsZUNvbW1hbmQuU1lOVEgsXG4gICAgICAgIGJhY2tlbmRJZCxcbiAgICAgICAgdGhpcy5nZXRBcHBDb21tYW5kKCksXG4gICAgICAgIGNka0NvbW1hbmRBcmdzLmNvbmNhdCgnLS1xdWlldCcpIC8vIGRvbid0IHByaW50IHRoZSBDRk4gdGVtcGxhdGUgdG8gc3Rkb3V0XG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHN5bnRoRXJyb3IgPSBlO1xuICAgIH1cbiAgICAvLyBDREsgcHJpbnRzIHN5bnRoIHRpbWUgaW4gc2Vjb25kcyByb3VuZGVkIHRvIDIgZGVjaW1hbCBwbGFjZXMuIEhlcmUgd2UgZHVwbGljYXRlIHRoYXQgYmVoYXZpb3IuXG4gICAgY29uc3Qgc3ludGhUaW1lU2Vjb25kcyA9IE1hdGguZmxvb3IoKERhdGUubm93KCkgLSBzdGFydFRpbWUpIC8gMTApIC8gMTAwO1xuXG4gICAgLy8gdGhlbiBydW4gdHlwZSBjaGVja3NcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5pbnZva2VUc2MoZGVwbG95UHJvcHMpO1xuICAgIH0gY2F0Y2ggKHR5cGVFcnJvcjogdW5rbm93bikge1xuICAgICAgaWYgKFxuICAgICAgICBzeW50aEVycm9yICYmXG4gICAgICAgIEFtcGxpZnlFcnJvci5pc0FtcGxpZnlFcnJvcih0eXBlRXJyb3IpICYmXG4gICAgICAgIHR5cGVFcnJvci5jYXVzZT8ubWVzc2FnZS5tYXRjaChcbiAgICAgICAgICAvQ2Fubm90IGZpbmQgbW9kdWxlICdcXCRhbXBsaWZ5XFwvZW52XFwvLionIG9yIGl0cyBjb3JyZXNwb25kaW5nIHR5cGUgZGVjbGFyYXRpb25zL1xuICAgICAgICApXG4gICAgICApIHtcbiAgICAgICAgLy8gc3ludGggaGFzIGZhaWxlZCBhbmQgd2UgZG9uJ3QgaGF2ZSBhdXRvIGdlbmVyYXRlZCBmdW5jdGlvbiBlbnZpcm9ubWVudCBkZWZpbml0aW9uIGZpbGVzLiBUaGlzXG4gICAgICAgIC8vIHJlc3VsdGVkIGluIHRoZSBleGNlcHRpb24gY2F1Z2h0IGhlcmUsIHdoaWNoIGlzIG5vdCB2ZXJ5IHVzZWZ1bCBmb3IgdGhlIGN1c3RvbWVycy5cbiAgICAgICAgLy8gV2UgaW5zdGVhZCB0aHJvdyB0aGUgc3ludGggZXJyb3IgZm9yIGN1c3RvbWVycyB0byBmaXggd2hhdCBjYXVzZWQgdGhlIHN5bnRoIHRvIGZhaWwuXG4gICAgICAgIHRocm93IHN5bnRoRXJyb3I7XG4gICAgICB9XG4gICAgICB0aHJvdyB0eXBlRXJyb3I7XG4gICAgfVxuXG4gICAgLy8gSWYgc29tZWhvdyBUU0Mgd2FzIHN1Y2Nlc3NmdWwgYnV0IHN5bnRoIHdhc24ndCwgd2Ugbm93IHRocm93IHRvIHN1cmZhY2UgdGhlIHN5bnRoIGVycm9yXG4gICAgaWYgKHN5bnRoRXJyb3IpIHtcbiAgICAgIHRocm93IHN5bnRoRXJyb3I7XG4gICAgfVxuXG4gICAgLy8gdGhlbiBkZXBsb3kgd2l0aCB0aGUgY2xvdWQgYXNzZW1ibHkgdGhhdCB3YXMgZ2VuZXJhdGVkIGR1cmluZyBzeW50aFxuICAgIGNvbnN0IGRlcGxveVJlc3VsdCA9IGF3YWl0IHRoaXMudHJ5SW52b2tlQ2RrKFxuICAgICAgSW52b2thYmxlQ29tbWFuZC5ERVBMT1ksXG4gICAgICBiYWNrZW5kSWQsXG4gICAgICB0aGlzLnJlbGF0aXZlQ2xvdWRBc3NlbWJseUxvY2F0aW9uLFxuICAgICAgY2RrQ29tbWFuZEFyZ3NcbiAgICApO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRlcGxveW1lbnRUaW1lczoge1xuICAgICAgICBzeW50aGVzaXNUaW1lOiBzeW50aFRpbWVTZWNvbmRzLFxuICAgICAgICB0b3RhbFRpbWU6XG4gICAgICAgICAgc3ludGhUaW1lU2Vjb25kcyArIChkZXBsb3lSZXN1bHQ/LmRlcGxveW1lbnRUaW1lcz8udG90YWxUaW1lIHx8IDApLFxuICAgICAgfSxcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbnZva2VzIGNkayBkZXN0cm95IGNvbW1hbmRcbiAgICovXG4gIGRlc3Ryb3kgPSBhc3luYyAoXG4gICAgYmFja2VuZElkOiBCYWNrZW5kSWRlbnRpZmllcixcbiAgICBkZXN0cm95UHJvcHM/OiBEZXN0cm95UHJvcHNcbiAgKSA9PiB7XG4gICAgY29uc3QgY2RrQ29tbWFuZEFyZ3M6IHN0cmluZ1tdID0gWyctLWZvcmNlJ107XG4gICAgaWYgKGRlc3Ryb3lQcm9wcz8ucHJvZmlsZSkge1xuICAgICAgY2RrQ29tbWFuZEFyZ3MucHVzaCgnLS1wcm9maWxlJywgZGVzdHJveVByb3BzLnByb2ZpbGUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50cnlJbnZva2VDZGsoXG4gICAgICBJbnZva2FibGVDb21tYW5kLkRFU1RST1ksXG4gICAgICBiYWNrZW5kSWQsXG4gICAgICB0aGlzLmdldEFwcENvbW1hbmQoKSxcbiAgICAgIGNka0NvbW1hbmRBcmdzXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogV3JhcHBlciBmb3IgdGhlIGNoaWxkIHByb2Nlc3MgZXhlY3V0b3IuIEhlbHBzIGluIHVuaXQgdGVzdGluZyBhcyBub2RlOnRlc3QgZnJhbWV3b3JrXG4gICAqIGRvZXNuJ3QgaGF2ZSBjYXBhYmlsaXRpZXMgdG8gbW9jayBleHBvcnRlZCBmdW5jdGlvbnMgbGlrZSBgZXhlY2FgIGFzIG9mIHJpZ2h0IG5vdy5cbiAgICovXG4gIGV4ZWN1dGVDb21tYW5kID0gYXN5bmMgKFxuICAgIGNvbW1hbmRBcmdzOiBzdHJpbmdbXSxcbiAgICBvcHRpb25zOiB7IHJlZGlyZWN0U3Rkb3V0VG9TdGRlcnI6IGJvb2xlYW4gfSA9IHtcbiAgICAgIHJlZGlyZWN0U3Rkb3V0VG9TdGRlcnI6IGZhbHNlLFxuICAgIH1cbiAgKSA9PiB7XG4gICAgLy8gV2UgbGV0IHRoZSBzdGRvdXQgYW5kIHN0ZGluIGluaGVyaXQgYW5kIHN0cmVhbWVkIHRvIHBhcmVudCBwcm9jZXNzIGJ1dCBwaXBlXG4gICAgLy8gdGhlIHN0ZGVyciBhbmQgdXNlIGl0IHRvIHRocm93IG9uIGZhaWx1cmUuIFRoaXMgaXMgdG8gcHJldmVudCBhY3R1YWxcbiAgICAvLyBhY3Rpb25hYmxlIGVycm9ycyBiZWluZyBoaWRkZW4gYW1vbmcgdGhlIHN0ZG91dC4gTW9yZW92ZXIgZXhlY2EgZXJyb3JzIGFyZVxuICAgIC8vIHVzZWxlc3Mgd2hlbiBjYWxsaW5nIENMSXMgdW5sZXNzIHlvdSBtYWRlIGV4ZWNhIGNhbGxpbmcgZXJyb3IuXG4gICAgbGV0IGFnZ3JlZ2F0ZWRTdGRlcnIgPSAnJztcbiAgICBjb25zdCBhZ2dyZWdhdG9yU3RkZXJyU3RyZWFtID0gbmV3IHN0cmVhbS5Xcml0YWJsZSgpO1xuICAgIGFnZ3JlZ2F0b3JTdGRlcnJTdHJlYW0uX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgZG9uZSkge1xuICAgICAgYWdncmVnYXRlZFN0ZGVyciArPSBjaHVuaztcbiAgICAgIGRvbmUoKTtcbiAgICB9O1xuICAgIGNvbnN0IGNoaWxkUHJvY2VzcyA9IHRoaXMucGFja2FnZU1hbmFnZXJDb250cm9sbGVyLnJ1bldpdGhQYWNrYWdlTWFuYWdlcihcbiAgICAgIGNvbW1hbmRBcmdzLFxuICAgICAgcHJvY2Vzcy5jd2QoKSxcbiAgICAgIHtcbiAgICAgICAgc3RkaW46ICdpbmhlcml0JyxcbiAgICAgICAgc3Rkb3V0OiAncGlwZScsXG4gICAgICAgIHN0ZGVycjogJ3BpcGUnLFxuICAgICAgICAvLyBQaXBpbmcgdGhlIG91dHB1dCBieSBkZWZhdWx0IHN0cmlwcyBvZmYgdGhlIGNvbG9yLiBUaGlzIGlzIGEgd29ya2Fyb3VuZCB0b1xuICAgICAgICAvLyBwcmVzZXJ2ZSB0aGUgY29sb3IgYmVpbmcgcGlwZWQgdG8gcGFyZW50IHByb2Nlc3MuXG4gICAgICAgIGV4dGVuZEVudjogdHJ1ZSxcbiAgICAgICAgZW52OiB7IEZPUkNFX0NPTE9SOiAnMScgfSxcbiAgICAgIH1cbiAgICApO1xuXG4gICAgY2hpbGRQcm9jZXNzLnN0ZGVycj8ucGlwZShhZ2dyZWdhdG9yU3RkZXJyU3RyZWFtKTtcblxuICAgIGlmIChvcHRpb25zPy5yZWRpcmVjdFN0ZG91dFRvU3RkZXJyKSB7XG4gICAgICBjaGlsZFByb2Nlc3Muc3Rkb3V0Py5waXBlKGFnZ3JlZ2F0b3JTdGRlcnJTdHJlYW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGlsZFByb2Nlc3Muc3Rkb3V0Py5waXBlKHByb2Nlc3Muc3Rkb3V0KTtcbiAgICB9XG5cbiAgICBjb25zdCBjZGtPdXRwdXQgPSB7IGRlcGxveW1lbnRUaW1lczoge30gfTtcbiAgICBpZiAoY2hpbGRQcm9jZXNzLnN0ZG91dCkge1xuICAgICAgYXdhaXQgdGhpcy5wb3B1bGF0ZUNES091dHB1dEZyb21TdGRvdXQoY2RrT3V0cHV0LCBjaGlsZFByb2Nlc3Muc3Rkb3V0KTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgYXdhaXQgY2hpbGRQcm9jZXNzO1xuICAgICAgcmV0dXJuIGNka091dHB1dDtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBhbXBsaWZ5LWJhY2tlbmQtcnVsZXMvcHJvcGFnYXRlLWVycm9yLWNhdXNlXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIHN3YWxsb3cgZXhlY2EgZXJyb3IgaWYgdGhlIGNkayBjbGkgcmFuIGFuZCBwcm9kdWNlZCBzb21lIHN0ZGVyci5cbiAgICAgIC8vIE1vc3Qgb2YgdGhlIHRpbWUgdGhpcyBlcnJvciBpcyBub2lzZShiYXNpY2FsbHkgY2hpbGQgZXhpdGVkIHdpdGggZXhpdCBjb2RlLi4uKVxuICAgICAgLy8gYnViYmxpbmcgdGhpcyB1cCB0byBjdXN0b21lcnMgYWRkIGNvbmZ1c2lvbiAoQ3VzdG9tZXJzIGRvbid0IG5lZWQgdG8ga25vdyB3ZSBhcmUgcnVubmluZyBJUEMgY2FsbHNcbiAgICAgIC8vIGFuZCB0aGVpciBleGl0IGNvZGVzIHByaW50ZWQgd2hpbGUgc2FuZGJveCBjb250aW51ZSB0byBydW4pLiBIZW5jZSB3ZSBleHBsaWNpdGx5IGRvbid0IHBhc3MgZXJyb3IgaW4gdGhlIGNhdXNlXG4gICAgICAvLyByYXRoZXIgdGhyb3cgdGhlIGVudGlyZSBzdGRlcnIgZm9yIGNsaWVudHMgdG8gZmlndXJlIG91dCB3aGF0IHRvIGRvIHdpdGggaXQuXG4gICAgICAvLyBIb3dldmVyIGlmIHRoZSBjZGsgcHJvY2VzcyBkaWRuJ3QgcnVuIG9yIHByb2R1Y2VkIG5vIG91dHB1dCwgdGhlbiB3ZSBoYXZlIG5vdGhpbmcgdG8gZ28gb24gd2l0aC4gU28gd2UgdGhyb3dcbiAgICAgIC8vIHRoaXMgZXJyb3IgdG8gYWlkIGluIHNvbWUgZGVidWdnaW5nLlxuICAgICAgaWYgKGFnZ3JlZ2F0ZWRTdGRlcnIudHJpbSgpKSB7XG4gICAgICAgIC8vIElmIHRoZSBzdHJpbmcgaXMgbW9yZSB0aGFuIDY1S0IsIHRydW5jYXRlIGFuZCBrZWVwIHRoZSBsYXN0IHBvcnRpb24uXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBhbXBsaWZ5LWJhY2tlbmQtcnVsZXMvcHJlZmVyLWFtcGxpZnktZXJyb3JzXG4gICAgICAgIHRocm93IG5ldyBFcnJvcih0aGlzLnRydW5jYXRlU3RyaW5nKGFnZ3JlZ2F0ZWRTdGRlcnIsIDY1MDAwKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcHJpdmF0ZSB0cnVuY2F0ZVN0cmluZyA9IChzdHI6IHN0cmluZywgc2l6ZTogbnVtYmVyKSA9PiB7XG4gICAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgICBjb25zdCBlbmNvZGVkID0gZW5jb2Rlci5lbmNvZGUoc3RyKTtcbiAgICByZXR1cm4gZW5jb2RlZC5ieXRlTGVuZ3RoID4gc2l6ZVxuICAgICAgPyAnLi4udHJ1bmNhdGVkLi4uJyArIGRlY29kZXIuZGVjb2RlKGVuY29kZWQuc2xpY2UoLXNpemUpKVxuICAgICAgOiBzdHI7XG4gIH07XG5cbiAgcHJpdmF0ZSBnZXRBcHBDb21tYW5kID0gKCkgPT5cbiAgICB0aGlzLnBhY2thZ2VNYW5hZ2VyQ29udHJvbGxlci5nZXRDb21tYW5kKFtcbiAgICAgICd0c3gnLFxuICAgICAgdGhpcy5iYWNrZW5kTG9jYXRvci5sb2NhdGUoKSxcbiAgICBdKTtcblxuICBwcml2YXRlIGludm9rZVRzYyA9IGFzeW5jIChkZXBsb3lQcm9wcz86IERlcGxveVByb3BzKSA9PiB7XG4gICAgaWYgKCFkZXBsb3lQcm9wcz8udmFsaWRhdGVBcHBTb3VyY2VzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLmV4ZWN1dGVDb21tYW5kKFxuICAgICAgICBbXG4gICAgICAgICAgJ3RzYycsXG4gICAgICAgICAgJy0tc2hvd0NvbmZpZycsXG4gICAgICAgICAgJy0tcHJvamVjdCcsXG4gICAgICAgICAgZGlybmFtZSh0aGlzLmJhY2tlbmRMb2NhdG9yLmxvY2F0ZSgpKSxcbiAgICAgICAgXSxcbiAgICAgICAgeyByZWRpcmVjdFN0ZG91dFRvU3RkZXJyOiB0cnVlIH0gLy8gVFNDIHByaW50cyBlcnJvcnMgdG8gc3Rkb3V0IGJ5IGRlZmF1bHRcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIElmIHdlIGNhbm5vdCBsb2FkIHRzIGNvbmZpZywgdHVybiBvZmYgdHlwZSBjaGVja2luZ1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5leGVjdXRlQ29tbWFuZChcbiAgICAgICAgW1xuICAgICAgICAgICd0c2MnLFxuICAgICAgICAgICctLW5vRW1pdCcsXG4gICAgICAgICAgJy0tc2tpcExpYkNoZWNrJyxcbiAgICAgICAgICAvLyBwb2ludGluZyB0aGUgcHJvamVjdCBhcmcgdG8gdGhlIGFtcGxpZnkgYmFja2VuZCBkaXJlY3Rvcnkgd2lsbCB1c2UgdGhlIHRzY29uZmlnIHByZXNlbnQgaW4gdGhhdCBkaXJlY3RvcnlcbiAgICAgICAgICAnLS1wcm9qZWN0JyxcbiAgICAgICAgICBkaXJuYW1lKHRoaXMuYmFja2VuZExvY2F0b3IubG9jYXRlKCkpLFxuICAgICAgICBdLFxuICAgICAgICB7IHJlZGlyZWN0U3Rkb3V0VG9TdGRlcnI6IHRydWUgfSAvLyBUU0MgcHJpbnRzIGVycm9ycyB0byBzdGRvdXQgYnkgZGVmYXVsdFxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IG5ldyBBbXBsaWZ5VXNlckVycm9yPENES0RlcGxveW1lbnRFcnJvcj4oXG4gICAgICAgICdTeW50YXhFcnJvcicsXG4gICAgICAgIHtcbiAgICAgICAgICBtZXNzYWdlOiAnVHlwZVNjcmlwdCB2YWxpZGF0aW9uIGNoZWNrIGZhaWxlZC4nLFxuICAgICAgICAgIHJlc29sdXRpb246XG4gICAgICAgICAgICAnRml4IHRoZSBzeW50YXggYW5kIHR5cGUgZXJyb3JzIGluIHlvdXIgYmFja2VuZCBkZWZpbml0aW9uLicsXG4gICAgICAgIH0sXG4gICAgICAgIGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyIDogdW5kZWZpbmVkXG4gICAgICApO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogY2FsbHMgaW52b2tlQ0RLIGFuZCB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoXG4gICAqL1xuICBwcml2YXRlIHRyeUludm9rZUNkayA9IGFzeW5jIChcbiAgICBpbnZva2FibGVDb21tYW5kOiBJbnZva2FibGVDb21tYW5kLFxuICAgIGJhY2tlbmRJZDogQmFja2VuZElkZW50aWZpZXIsXG4gICAgYXBwQXJndW1lbnQ6IHN0cmluZyxcbiAgICBhZGRpdGlvbmFsQXJndW1lbnRzPzogc3RyaW5nW11cbiAgKTogUHJvbWlzZTxEZXBsb3lSZXN1bHQgfCBEZXN0cm95UmVzdWx0PiA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmludm9rZUNkayhcbiAgICAgICAgaW52b2thYmxlQ29tbWFuZCxcbiAgICAgICAgYmFja2VuZElkLFxuICAgICAgICBhcHBBcmd1bWVudCxcbiAgICAgICAgYWRkaXRpb25hbEFyZ3VtZW50c1xuICAgICAgKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IHRoaXMuY2RrRXJyb3JNYXBwZXIuZ2V0QW1wbGlmeUVycm9yKGVyciBhcyBFcnJvcik7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyBhIENESyBjb21tYW5kXG4gICAqL1xuICBwcml2YXRlIGludm9rZUNkayA9IGFzeW5jIChcbiAgICBpbnZva2FibGVDb21tYW5kOiBJbnZva2FibGVDb21tYW5kLFxuICAgIGJhY2tlbmRJZDogQmFja2VuZElkZW50aWZpZXIsXG4gICAgYXBwQXJndW1lbnQ6IHN0cmluZyxcbiAgICBhZGRpdGlvbmFsQXJndW1lbnRzPzogc3RyaW5nW11cbiAgKTogUHJvbWlzZTxEZXBsb3lSZXN1bHQgfCBEZXN0cm95UmVzdWx0PiA9PiB7XG4gICAgLy8gQmFzaWMgYXJnc1xuICAgIGNvbnN0IGNka0NvbW1hbmRBcmdzID0gW1xuICAgICAgJ2NkaycsXG4gICAgICBpbnZva2FibGVDb21tYW5kLnRvU3RyaW5nKCksXG4gICAgICAvLyBUaGlzIGlzIHVuZm9ydHVuYXRlLiBDREsgd3JpdGVzIGV2ZXJ5dGhpbmcgdG8gc3RkZXJyIHdpdGhvdXQgYC0tY2lgIGZsYWcgYW5kIHdlIG5lZWQgdG8gZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIHRoZSB0d28uXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2F3cy9hd3MtY2RrL2lzc3Vlcy83NzE3IGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAnLS1jaScsXG4gICAgICAnLS1hcHAnLFxuICAgICAgYXBwQXJndW1lbnQsXG4gICAgICAnLS1hbGwnLFxuICAgICAgJy0tb3V0cHV0JyxcbiAgICAgIHRoaXMucmVsYXRpdmVDbG91ZEFzc2VtYmx5TG9jYXRpb24sXG4gICAgXTtcblxuICAgIC8vIEFkZCBjb250ZXh0IGluZm9ybWF0aW9uIGlmIGF2YWlsYWJsZVxuICAgIGNka0NvbW1hbmRBcmdzLnB1c2goXG4gICAgICAnLS1jb250ZXh0JyxcbiAgICAgIGAke0NES0NvbnRleHRLZXkuQkFDS0VORF9OQU1FU1BBQ0V9PSR7YmFja2VuZElkLm5hbWVzcGFjZX1gLFxuICAgICAgJy0tY29udGV4dCcsXG4gICAgICBgJHtDREtDb250ZXh0S2V5LkJBQ0tFTkRfTkFNRX09JHtiYWNrZW5kSWQubmFtZX1gXG4gICAgKTtcblxuICAgIGlmIChiYWNrZW5kSWQudHlwZSAhPT0gJ3NhbmRib3gnKSB7XG4gICAgICBjZGtDb21tYW5kQXJncy5wdXNoKCctLXJlcXVpcmUtYXBwcm92YWwnLCAnbmV2ZXInKTtcbiAgICB9XG5cbiAgICBjZGtDb21tYW5kQXJncy5wdXNoKFxuICAgICAgJy0tY29udGV4dCcsXG4gICAgICBgJHtDREtDb250ZXh0S2V5LkRFUExPWU1FTlRfVFlQRX09JHtiYWNrZW5kSWQudHlwZX1gXG4gICAgKTtcblxuICAgIGlmIChhZGRpdGlvbmFsQXJndW1lbnRzKSB7XG4gICAgICBjZGtDb21tYW5kQXJncy5wdXNoKC4uLmFkZGl0aW9uYWxBcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBhd2FpdCB0aGlzLmV4ZWN1dGVDb21tYW5kKGNka0NvbW1hbmRBcmdzKTtcbiAgfTtcblxuICBwcml2YXRlIHBvcHVsYXRlQ0RLT3V0cHV0RnJvbVN0ZG91dCA9IGFzeW5jIChcbiAgICBvdXRwdXQ6IERlcGxveVJlc3VsdCB8IERlc3Ryb3lSZXN1bHQsXG4gICAgc3Rkb3V0OiBzdHJlYW0uUmVhZGFibGVcbiAgKSA9PiB7XG4gICAgY29uc3QgcmVnZXhUb3RhbFRpbWUgPSAv4pyoIHsyfVRvdGFsIHRpbWU6IChcXGQqXFwuKlxcZCopcy4qLztcbiAgICBjb25zdCByZWdleFN5bnRoVGltZSA9IC/inKggezJ9U3ludGhlc2lzIHRpbWU6IChcXGQqXFwuKlxcZCopcy87XG4gICAgY29uc3QgcmVhZGVyID0gcmVhZGxpbmUuY3JlYXRlSW50ZXJmYWNlKHN0ZG91dCk7XG4gICAgZm9yIGF3YWl0IChjb25zdCBsaW5lIG9mIHJlYWRlcikge1xuICAgICAgaWYgKGxpbmUuaW5jbHVkZXMoJ+KcqCcpKSB7XG4gICAgICAgIC8vIEdvb2QgY2hhbmNlIHRoYXQgaXQgY29udGFpbnMgdGltaW5nIGluZm9ybWF0aW9uXG4gICAgICAgIGNvbnN0IHRvdGFsVGltZSA9IGxpbmUubWF0Y2gocmVnZXhUb3RhbFRpbWUpO1xuICAgICAgICBpZiAodG90YWxUaW1lICYmIHRvdGFsVGltZS5sZW5ndGggPiAxICYmICFpc05hTigrdG90YWxUaW1lWzFdKSkge1xuICAgICAgICAgIG91dHB1dC5kZXBsb3ltZW50VGltZXMudG90YWxUaW1lID0gK3RvdGFsVGltZVsxXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzeW50aFRpbWUgPSBsaW5lLm1hdGNoKHJlZ2V4U3ludGhUaW1lKTtcbiAgICAgICAgaWYgKHN5bnRoVGltZSAmJiBzeW50aFRpbWUubGVuZ3RoID4gMSAmJiAhaXNOYU4oK3N5bnRoVGltZVsxXSkpIHtcbiAgICAgICAgICBvdXRwdXQuZGVwbG95bWVudFRpbWVzLnN5bnRoZXNpc1RpbWUgPSArc3ludGhUaW1lWzFdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuIl19