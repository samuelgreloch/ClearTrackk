import fsp from 'fs/promises';
import path from 'path';
import { printer } from '../../printer.js';
import { LogLevel } from '../../printer/printer.js';
/**
 * YarnClassicLockFileReader is an abstraction around the logic used to read and parse lock file contents
 */
export class YarnClassicLockFileReader {
    getLockFileContentsFromCwd = async () => {
        const eolRegex = '[\r\n]';
        const dependencies = [];
        const yarnLockPath = path.resolve(process.cwd(), 'yarn.lock');
        try {
            const yarnLockContents = await fsp.readFile(yarnLockPath, 'utf-8');
            const yarnLockContentsArray = yarnLockContents
                .trim()
                .split(new RegExp(`${eolRegex}${eolRegex}`));
            // Slice to remove comment block at the start of the lock file
            for (const yarnDependencyBlock of yarnLockContentsArray.slice(1)) {
                const yarnDependencyLines = yarnDependencyBlock
                    .trim()
                    .split(new RegExp(eolRegex));
                const yarnDependencyName = yarnDependencyLines[0];
                const yarnDependencyVersion = yarnDependencyLines[1];
                // Get dependency name before versioning info
                const dependencyName = yarnDependencyName
                    .slice(0, yarnDependencyName.lastIndexOf('@'))
                    .replaceAll(/"/g, '');
                const versionMatch = yarnDependencyVersion.match(/"(.*)"/);
                const dependencyVersion = versionMatch ? versionMatch[1] : '';
                dependencies.push({ name: dependencyName, version: dependencyVersion });
            }
        }
        catch (error) {
            printer.log(`Failed to get lock file contents because ${yarnLockPath} does not exist or is not parse-able`, LogLevel.DEBUG);
            return;
        }
        return { dependencies };
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoieWFybl9jbGFzc2ljX2xvY2tfZmlsZV9yZWFkZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvcGFja2FnZS1tYW5hZ2VyLWNvbnRyb2xsZXIvbG9jay1maWxlLXJlYWRlci95YXJuX2NsYXNzaWNfbG9ja19maWxlX3JlYWRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxPQUFPLEdBQUcsTUFBTSxhQUFhLENBQUM7QUFDOUIsT0FBTyxJQUFJLE1BQU0sTUFBTSxDQUFDO0FBRXhCLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUMzQyxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFFcEQ7O0dBRUc7QUFDSCxNQUFNLE9BQU8seUJBQXlCO0lBQ3BDLDBCQUEwQixHQUFHLEtBQUssSUFFaEMsRUFBRTtRQUNGLE1BQU0sUUFBUSxHQUFHLFFBQVEsQ0FBQztRQUMxQixNQUFNLFlBQVksR0FBc0IsRUFBRSxDQUFDO1FBQzNDLE1BQU0sWUFBWSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxFQUFFLFdBQVcsQ0FBQyxDQUFDO1FBRTlELElBQUk7WUFDRixNQUFNLGdCQUFnQixHQUFHLE1BQU0sR0FBRyxDQUFDLFFBQVEsQ0FBQyxZQUFZLEVBQUUsT0FBTyxDQUFDLENBQUM7WUFDbkUsTUFBTSxxQkFBcUIsR0FBRyxnQkFBZ0I7aUJBQzNDLElBQUksRUFBRTtpQkFDTixLQUFLLENBQUMsSUFBSSxNQUFNLENBQUMsR0FBRyxRQUFRLEdBQUcsUUFBUSxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBRS9DLDhEQUE4RDtZQUM5RCxLQUFLLE1BQU0sbUJBQW1CLElBQUkscUJBQXFCLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFO2dCQUNoRSxNQUFNLG1CQUFtQixHQUFHLG1CQUFtQjtxQkFDNUMsSUFBSSxFQUFFO3FCQUNOLEtBQUssQ0FBQyxJQUFJLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO2dCQUMvQixNQUFNLGtCQUFrQixHQUFHLG1CQUFtQixDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNsRCxNQUFNLHFCQUFxQixHQUFHLG1CQUFtQixDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUVyRCw2Q0FBNkM7Z0JBQzdDLE1BQU0sY0FBYyxHQUFHLGtCQUFrQjtxQkFDdEMsS0FBSyxDQUFDLENBQUMsRUFBRSxrQkFBa0IsQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUM7cUJBQzdDLFVBQVUsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLENBQUM7Z0JBQ3hCLE1BQU0sWUFBWSxHQUFHLHFCQUFxQixDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQztnQkFDM0QsTUFBTSxpQkFBaUIsR0FBRyxZQUFZLENBQUMsQ0FBQyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO2dCQUU5RCxZQUFZLENBQUMsSUFBSSxDQUFDLEVBQUUsSUFBSSxFQUFFLGNBQWMsRUFBRSxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsQ0FBQyxDQUFDO2FBQ3pFO1NBQ0Y7UUFBQyxPQUFPLEtBQUssRUFBRTtZQUNkLE9BQU8sQ0FBQyxHQUFHLENBQ1QsNENBQTRDLFlBQVksc0NBQXNDLEVBQzlGLFFBQVEsQ0FBQyxLQUFLLENBQ2YsQ0FBQztZQUNGLE9BQU87U0FDUjtRQUVELE9BQU8sRUFBRSxZQUFZLEVBQUUsQ0FBQztJQUMxQixDQUFDLENBQUM7Q0FDSCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERlcGVuZGVuY3kgfSBmcm9tICdAYXdzLWFtcGxpZnkvcGx1Z2luLXR5cGVzJztcbmltcG9ydCBmc3AgZnJvbSAnZnMvcHJvbWlzZXMnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBMb2NrRmlsZUNvbnRlbnRzLCBMb2NrRmlsZVJlYWRlciB9IGZyb20gJy4vdHlwZXMuanMnO1xuaW1wb3J0IHsgcHJpbnRlciB9IGZyb20gJy4uLy4uL3ByaW50ZXIuanMnO1xuaW1wb3J0IHsgTG9nTGV2ZWwgfSBmcm9tICcuLi8uLi9wcmludGVyL3ByaW50ZXIuanMnO1xuXG4vKipcbiAqIFlhcm5DbGFzc2ljTG9ja0ZpbGVSZWFkZXIgaXMgYW4gYWJzdHJhY3Rpb24gYXJvdW5kIHRoZSBsb2dpYyB1c2VkIHRvIHJlYWQgYW5kIHBhcnNlIGxvY2sgZmlsZSBjb250ZW50c1xuICovXG5leHBvcnQgY2xhc3MgWWFybkNsYXNzaWNMb2NrRmlsZVJlYWRlciBpbXBsZW1lbnRzIExvY2tGaWxlUmVhZGVyIHtcbiAgZ2V0TG9ja0ZpbGVDb250ZW50c0Zyb21Dd2QgPSBhc3luYyAoKTogUHJvbWlzZTxcbiAgICBMb2NrRmlsZUNvbnRlbnRzIHwgdW5kZWZpbmVkXG4gID4gPT4ge1xuICAgIGNvbnN0IGVvbFJlZ2V4ID0gJ1tcXHJcXG5dJztcbiAgICBjb25zdCBkZXBlbmRlbmNpZXM6IEFycmF5PERlcGVuZGVuY3k+ID0gW107XG4gICAgY29uc3QgeWFybkxvY2tQYXRoID0gcGF0aC5yZXNvbHZlKHByb2Nlc3MuY3dkKCksICd5YXJuLmxvY2snKTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB5YXJuTG9ja0NvbnRlbnRzID0gYXdhaXQgZnNwLnJlYWRGaWxlKHlhcm5Mb2NrUGF0aCwgJ3V0Zi04Jyk7XG4gICAgICBjb25zdCB5YXJuTG9ja0NvbnRlbnRzQXJyYXkgPSB5YXJuTG9ja0NvbnRlbnRzXG4gICAgICAgIC50cmltKClcbiAgICAgICAgLnNwbGl0KG5ldyBSZWdFeHAoYCR7ZW9sUmVnZXh9JHtlb2xSZWdleH1gKSk7XG5cbiAgICAgIC8vIFNsaWNlIHRvIHJlbW92ZSBjb21tZW50IGJsb2NrIGF0IHRoZSBzdGFydCBvZiB0aGUgbG9jayBmaWxlXG4gICAgICBmb3IgKGNvbnN0IHlhcm5EZXBlbmRlbmN5QmxvY2sgb2YgeWFybkxvY2tDb250ZW50c0FycmF5LnNsaWNlKDEpKSB7XG4gICAgICAgIGNvbnN0IHlhcm5EZXBlbmRlbmN5TGluZXMgPSB5YXJuRGVwZW5kZW5jeUJsb2NrXG4gICAgICAgICAgLnRyaW0oKVxuICAgICAgICAgIC5zcGxpdChuZXcgUmVnRXhwKGVvbFJlZ2V4KSk7XG4gICAgICAgIGNvbnN0IHlhcm5EZXBlbmRlbmN5TmFtZSA9IHlhcm5EZXBlbmRlbmN5TGluZXNbMF07XG4gICAgICAgIGNvbnN0IHlhcm5EZXBlbmRlbmN5VmVyc2lvbiA9IHlhcm5EZXBlbmRlbmN5TGluZXNbMV07XG5cbiAgICAgICAgLy8gR2V0IGRlcGVuZGVuY3kgbmFtZSBiZWZvcmUgdmVyc2lvbmluZyBpbmZvXG4gICAgICAgIGNvbnN0IGRlcGVuZGVuY3lOYW1lID0geWFybkRlcGVuZGVuY3lOYW1lXG4gICAgICAgICAgLnNsaWNlKDAsIHlhcm5EZXBlbmRlbmN5TmFtZS5sYXN0SW5kZXhPZignQCcpKVxuICAgICAgICAgIC5yZXBsYWNlQWxsKC9cIi9nLCAnJyk7XG4gICAgICAgIGNvbnN0IHZlcnNpb25NYXRjaCA9IHlhcm5EZXBlbmRlbmN5VmVyc2lvbi5tYXRjaCgvXCIoLiopXCIvKTtcbiAgICAgICAgY29uc3QgZGVwZW5kZW5jeVZlcnNpb24gPSB2ZXJzaW9uTWF0Y2ggPyB2ZXJzaW9uTWF0Y2hbMV0gOiAnJztcblxuICAgICAgICBkZXBlbmRlbmNpZXMucHVzaCh7IG5hbWU6IGRlcGVuZGVuY3lOYW1lLCB2ZXJzaW9uOiBkZXBlbmRlbmN5VmVyc2lvbiB9KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcHJpbnRlci5sb2coXG4gICAgICAgIGBGYWlsZWQgdG8gZ2V0IGxvY2sgZmlsZSBjb250ZW50cyBiZWNhdXNlICR7eWFybkxvY2tQYXRofSBkb2VzIG5vdCBleGlzdCBvciBpcyBub3QgcGFyc2UtYWJsZWAsXG4gICAgICAgIExvZ0xldmVsLkRFQlVHXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiB7IGRlcGVuZGVuY2llcyB9O1xuICB9O1xufVxuIl19