import { LogLevel } from '@aws-amplify/cli-core';
import { BackendOutputClientError, BackendOutputClientErrorType, } from '@aws-amplify/deployed-backend-client';
import { TagName } from '@aws-amplify/platform-core';
import { GetFunctionCommand } from '@aws-sdk/client-lambda';
/**
 * Logs streamer for customer defined lambda functions in a sandbox.
 */
export class LambdaFunctionLogStreamer {
    lambda;
    logsMonitor;
    backendOutputClient;
    printer;
    enabled = false;
    /**
     * Creates an instance of LambdaFunctionLogStreamer
     */
    constructor(lambda, logsMonitor, backendOutputClient, printer) {
        this.lambda = lambda;
        this.logsMonitor = logsMonitor;
        this.backendOutputClient = backendOutputClient;
        this.printer = printer;
    }
    /**
     * Starts streaming logs in the given sandbox.
     * @param sandboxBackendId The sandbox backend identifier.
     * @param streamingOptions Options to configure the log streaming.
     */
    startStreamingLogs = async (sandboxBackendId, streamingOptions) => {
        if (streamingOptions?.enabled) {
            this.enabled = true;
        }
        else {
            return;
        }
        let backendOutput = {};
        try {
            backendOutput = await this.backendOutputClient.getOutput(sandboxBackendId);
        }
        catch (error) {
            // If stack does not exist or hasn't deployed successfully, we do not want to go further to start streaming logs
            if (BackendOutputClientError.isBackendOutputClientError(error) &&
                [
                    BackendOutputClientErrorType.NO_STACK_FOUND,
                    BackendOutputClientErrorType.NO_OUTPUTS_FOUND,
                ].some((code) => error.code === code)) {
                this.enabled = false;
                return;
            }
        }
        const definedFunctionsPayload = backendOutput['AWS::Amplify::Function']?.payload.definedFunctions;
        const definedConversationHandlersPayload = backendOutput['AWS::Amplify::AI::Conversation']?.payload
            .definedConversationHandlers;
        const deployedFunctionNames = definedFunctionsPayload
            ? JSON.parse(definedFunctionsPayload)
            : [];
        deployedFunctionNames.push(...(definedConversationHandlersPayload
            ? JSON.parse(definedConversationHandlersPayload)
            : []));
        for (const functionName of deployedFunctionNames) {
            const getFunctionResponse = await this.lambda.send(new GetFunctionCommand({
                FunctionName: functionName,
            }));
            const logGroupName = getFunctionResponse.Configuration?.LoggingConfig?.LogGroup;
            if (!logGroupName) {
                this.printer.log(`[Sandbox] Could not find logGroup for lambda function ${functionName}. Logs will not be streamed for this function.`, LogLevel.DEBUG);
                continue;
            }
            const friendlyFunctionName = getFunctionResponse.Tags?.[TagName.FRIENDLY_NAME];
            if (!friendlyFunctionName) {
                this.printer.log(`[Sandbox] Could not find user defined name for lambda function ${functionName}. Logs will not be streamed for this function.`, LogLevel.DEBUG);
                continue;
            }
            let shouldStreamLogs = false;
            if (streamingOptions.logsFilters) {
                for (const filter of streamingOptions.logsFilters) {
                    const pattern = new RegExp(filter);
                    if (pattern.test(friendlyFunctionName)) {
                        shouldStreamLogs = true;
                        this.printer.log(`[Sandbox] Logs for function ${friendlyFunctionName} will be streamed as it matched filter '${filter}'`, LogLevel.DEBUG);
                        break;
                    }
                }
            }
            else {
                // No logs filter, means we stream all logs
                this.printer.log(`[Sandbox] Logs for function ${friendlyFunctionName} will be streamed.`, LogLevel.DEBUG);
                shouldStreamLogs = true;
            }
            if (shouldStreamLogs) {
                this.logsMonitor?.addLogGroups(friendlyFunctionName, logGroupName);
            }
            else {
                this.printer.log(`[Sandbox] Skipping logs streaming for function ${friendlyFunctionName} since it did not match any filters. To stream logs for this function, ensure at least one of your logs-filters match this function name.`, LogLevel.DEBUG);
            }
        }
        // finally start listening
        this.logsMonitor?.activate(streamingOptions.logsOutFile);
    };
    stopStreamingLogs = () => {
        if (!this.enabled) {
            return;
        }
        this.printer.log(`[Sandbox] Streaming function logs will be paused during the deployment and will be resumed after the deployment is completed.`, LogLevel.DEBUG);
        this.logsMonitor?.pause();
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGFtYmRhX2Z1bmN0aW9uX2xvZ19zdHJlYW1lci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9sYW1iZGFfZnVuY3Rpb25fbG9nX3N0cmVhbWVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxRQUFRLEVBQVcsTUFBTSx1QkFBdUIsQ0FBQztBQUMxRCxPQUFPLEVBRUwsd0JBQXdCLEVBQ3hCLDRCQUE0QixHQUM3QixNQUFNLHNDQUFzQyxDQUFDO0FBQzlDLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQztBQUdyRCxPQUFPLEVBQUUsa0JBQWtCLEVBQWdCLE1BQU0sd0JBQXdCLENBQUM7QUFJMUU7O0dBRUc7QUFDSCxNQUFNLE9BQU8seUJBQXlCO0lBTWpCO0lBQ0E7SUFDQTtJQUNBO0lBUlgsT0FBTyxHQUFZLEtBQUssQ0FBQztJQUNqQzs7T0FFRztJQUNILFlBQ21CLE1BQW9CLEVBQ3BCLFdBQXNDLEVBQ3RDLG1CQUF3QyxFQUN4QyxPQUFnQjtRQUhoQixXQUFNLEdBQU4sTUFBTSxDQUFjO1FBQ3BCLGdCQUFXLEdBQVgsV0FBVyxDQUEyQjtRQUN0Qyx3QkFBbUIsR0FBbkIsbUJBQW1CLENBQXFCO1FBQ3hDLFlBQU8sR0FBUCxPQUFPLENBQVM7SUFDaEMsQ0FBQztJQUVKOzs7O09BSUc7SUFDSCxrQkFBa0IsR0FBRyxLQUFLLEVBQ3hCLGdCQUFtQyxFQUNuQyxnQkFBa0QsRUFDbEQsRUFBRTtRQUNGLElBQUksZ0JBQWdCLEVBQUUsT0FBTyxFQUFFO1lBQzdCLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDO1NBQ3JCO2FBQU07WUFDTCxPQUFPO1NBQ1I7UUFFRCxJQUFJLGFBQWEsR0FBa0IsRUFBRSxDQUFDO1FBQ3RDLElBQUk7WUFDRixhQUFhLEdBQUcsTUFBTSxJQUFJLENBQUMsbUJBQW1CLENBQUMsU0FBUyxDQUN0RCxnQkFBZ0IsQ0FDakIsQ0FBQztTQUNIO1FBQUMsT0FBTyxL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RTtpQkFBTTtnQkFDTCxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FDZCxrREFBa0Qsb0JBQW9CLDJJQUEySSxFQUNqTixRQUFRLENBQUMsS0FBSyxDQUNmLENBQUM7YUFDSDtTQUNGO1FBRUQsMEJBQTBCO1FBQzFCLElBQUksQ0FBQyxXQUFXLEVBQUUsUUFBUSxDQUFDLGdCQUFnQixDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQzNELENBQUMsQ0FBQztJQUVGLGlCQUFpQixHQUFHLEdBQUcsRUFBRTtRQUN2QixJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRTtZQUNqQixPQUFPO1NBQ1I7UUFDRCxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FDZCwrSEFBK0gsRUFDL0gsUUFBUSxDQUFDLEtBQUssQ0FDZixDQUFDO1FBQ0YsSUFBSSxDQUFDLFdBQVcsRUFBRSxLQUFLLEVBQUUsQ0FBQztJQUM1QixDQUFDLENBQUM7Q0FDSCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IExvZ0xldmVsLCBQcmludGVyIH0gZnJvbSAnQGF3cy1hbXBsaWZ5L2NsaS1jb3JlJztcbmltcG9ydCB7XG4gIEJhY2tlbmRPdXRwdXRDbGllbnQsXG4gIEJhY2tlbmRPdXRwdXRDbGllbnRFcnJvcixcbiAgQmFja2VuZE91dHB1dENsaWVudEVycm9yVHlwZSxcbn0gZnJvbSAnQGF3cy1hbXBsaWZ5L2RlcGxveWVkLWJhY2tlbmQtY2xpZW50JztcbmltcG9ydCB7IFRhZ05hbWUgfSBmcm9tICdAYXdzLWFtcGxpZnkvcGxhdGZvcm0tY29yZSc7XG5pbXBvcnQgeyBCYWNrZW5kSWRlbnRpZmllciwgQmFja2VuZE91dHB1dCB9IGZyb20gJ0Bhd3MtYW1wbGlmeS9wbHVnaW4tdHlwZXMnO1xuXG5pbXBvcnQgeyBHZXRGdW5jdGlvbkNvbW1hbmQsIExhbWJkYUNsaWVudCB9IGZyb20gJ0Bhd3Mtc2RrL2NsaWVudC1sYW1iZGEnO1xuaW1wb3J0IHsgQ2xvdWRXYXRjaExvZ0V2ZW50TW9uaXRvciB9IGZyb20gJy4vY2xvdWR3YXRjaF9sb2dzX21vbml0b3IuanMnO1xuaW1wb3J0IHsgU2FuZGJveEZ1bmN0aW9uU3RyZWFtaW5nT3B0aW9ucyB9IGZyb20gJy4vc2FuZGJveC5qcyc7XG5cbi8qKlxuICogTG9ncyBzdHJlYW1lciBmb3IgY3VzdG9tZXIgZGVmaW5lZCBsYW1iZGEgZnVuY3Rpb25zIGluIGEgc2FuZGJveC5cbiAqL1xuZXhwb3J0IGNsYXNzIExhbWJkYUZ1bmN0aW9uTG9nU3RyZWFtZXIge1xuICBwcml2YXRlIGVuYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgTGFtYmRhRnVuY3Rpb25Mb2dTdHJlYW1lclxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBsYW1iZGE6IExhbWJkYUNsaWVudCxcbiAgICBwcml2YXRlIHJlYWRvbmx5IGxvZ3NNb25pdG9yOiBDbG91ZFdhdGNoTG9nRXZlbnRNb25pdG9yLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgYmFja2VuZE91dHB1dENsaWVudDogQmFja2VuZE91dHB1dENsaWVudCxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHByaW50ZXI6IFByaW50ZXJcbiAgKSB7fVxuXG4gIC8qKlxuICAgKiBTdGFydHMgc3RyZWFtaW5nIGxvZ3MgaW4gdGhlIGdpdmVuIHNhbmRib3guXG4gICAqIEBwYXJhbSBzYW5kYm94QmFja2VuZElkIFRoZSBzYW5kYm94IGJhY2tlbmQgaWRlbnRpZmllci5cbiAgICogQHBhcmFtIHN0cmVhbWluZ09wdGlvbnMgT3B0aW9ucyB0byBjb25maWd1cmUgdGhlIGxvZyBzdHJlYW1pbmcuXG4gICAqL1xuICBzdGFydFN0cmVhbWluZ0xvZ3MgPSBhc3luYyAoXG4gICAgc2FuZGJveEJhY2tlbmRJZDogQmFja2VuZElkZW50aWZpZXIsXG4gICAgc3RyZWFtaW5nT3B0aW9ucz86IFNhbmRib3hGdW5jdGlvblN0cmVhbWluZ09wdGlvbnNcbiAgKSA9PiB7XG4gICAgaWYgKHN0cmVhbWluZ09wdGlvbnM/LmVuYWJsZWQpIHtcbiAgICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgYmFja2VuZE91dHB1dDogQmFja2VuZE91dHB1dCA9IHt9O1xuICAgIHRyeSB7XG4gICAgICBiYWNrZW5kT3V0cHV0ID0gYXdhaXQgdGhpcy5iYWNrZW5kT3V0cHV0Q2xpZW50LmdldE91dHB1dChcbiAgICAgICAgc2FuZGJveEJhY2tlbmRJZFxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gSWYgc3RhY2sgZG9lcyBub3QgZXhpc3Qgb3IgaGFzbid0IGRlcGxveWVkIHN1Y2Nlc3NmdWxseSwgd2UgZG8gbm90IHdhbnQgdG8gZ28gZnVydGhlciB0byBzdGFydCBzdHJlYW1pbmcgbG9nc1xuICAgICAgaWYgKFxuICAgICAgICBCYWNrZW5kT3V0cHV0Q2xpZW50RXJyb3IuaXNCYWNrZW5kT3V0cHV0Q2xpZW50RXJyb3IoZXJyb3IpICYmXG4gICAgICAgIFtcbiAgICAgICAgICBCYWNrZW5kT3V0cHV0Q2xpZW50RXJyb3JUeXBlLk5PX1NUQUNLX0ZPVU5ELFxuICAgICAgICAgIEJhY2tlbmRPdXRwdXRDbGllbnRFcnJvclR5cGUuTk9fT1VUUFVUU19GT1VORCxcbiAgICAgICAgXS5zb21lKChjb2RlKSA9PiAoZXJyb3IgYXMgQmFja2VuZE91dHB1dENsaWVudEVycm9yKS5jb2RlID09PSBjb2RlKVxuICAgICAgKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZGVmaW5lZEZ1bmN0aW9uc1BheWxvYWQgPVxuICAgICAgYmFja2VuZE91dHB1dFsnQVdTOjpBbXBsaWZ5OjpGdW5jdGlvbiddPy5wYXlsb2FkLmRlZmluZWRGdW5jdGlvbnM7XG4gICAgY29uc3QgZGVmaW5lZENvbnZlcnNhdGlvbkhhbmRsZXJzUGF5bG9hZCA9XG4gICAgICBiYWNrZW5kT3V0cHV0WydBV1M6OkFtcGxpZnk6OkFJOjpDb252ZXJzYXRpb24nXT8ucGF5bG9hZFxuICAgICAgICAuZGVmaW5lZENvbnZlcnNhdGlvbkhhbmRsZXJzO1xuICAgIGNvbnN0IGRlcGxveWVkRnVuY3Rpb25OYW1lcyA9IGRlZmluZWRGdW5jdGlvbnNQYXlsb2FkXG4gICAgICA/IChKU09OLnBhcnNlKGRlZmluZWRGdW5jdGlvbnNQYXlsb2FkKSBhcyBzdHJpbmdbXSlcbiAgICAgIDogW107XG4gICAgZGVwbG95ZWRGdW5jdGlvbk5hbWVzLnB1c2goXG4gICAgICAuLi4oZGVmaW5lZENvbnZlcnNhdGlvbkhhbmRsZXJzUGF5bG9hZFxuICAgICAgICA/IChKU09OLnBhcnNlKGRlZmluZWRDb252ZXJzYXRpb25IYW5kbGVyc1BheWxvYWQpIGFzIHN0cmluZ1tdKVxuICAgICAgICA6IFtdKVxuICAgICk7XG5cbiAgICBmb3IgKGNvbnN0IGZ1bmN0aW9uTmFtZSBvZiBkZXBsb3llZEZ1bmN0aW9uTmFtZXMpIHtcbiAgICAgIGNvbnN0IGdldEZ1bmN0aW9uUmVzcG9uc2UgPSBhd2FpdCB0aGlzLmxhbWJkYS5zZW5kKFxuICAgICAgICBuZXcgR2V0RnVuY3Rpb25Db21tYW5kKHtcbiAgICAgICAgICBGdW5jdGlvbk5hbWU6IGZ1bmN0aW9uTmFtZSxcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICBjb25zdCBsb2dHcm91cE5hbWUgPVxuICAgICAgICBnZXRGdW5jdGlvblJlc3BvbnNlLkNvbmZpZ3VyYXRpb24/LkxvZ2dpbmdDb25maWc/LkxvZ0dyb3VwO1xuICAgICAgaWYgKCFsb2dHcm91cE5hbWUpIHtcbiAgICAgICAgdGhpcy5wcmludGVyLmxvZyhcbiAgICAgICAgICBgW1NhbmRib3hdIENvdWxkIG5vdCBmaW5kIGxvZ0dyb3VwIGZvciBsYW1iZGEgZnVuY3Rpb24gJHtmdW5jdGlvbk5hbWV9LiBMb2dzIHdpbGwgbm90IGJlIHN0cmVhbWVkIGZvciB0aGlzIGZ1bmN0aW9uLmAsXG4gICAgICAgICAgTG9nTGV2ZWwuREVCVUdcbiAgICAgICAgKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBmcmllbmRseUZ1bmN0aW9uTmFtZSA9XG4gICAgICAgIGdldEZ1bmN0aW9uUmVzcG9uc2UuVGFncz8uW1RhZ05hbWUuRlJJRU5ETFlfTkFNRV07XG4gICAgICBpZiAoIWZyaWVuZGx5RnVuY3Rpb25OYW1lKSB7XG4gICAgICAgIHRoaXMucHJpbnRlci5sb2coXG4gICAgICAgICAgYFtTYW5kYm94XSBDb3VsZCBub3QgZmluZCB1c2VyIGRlZmluZWQgbmFtZSBmb3IgbGFtYmRhIGZ1bmN0aW9uICR7ZnVuY3Rpb25OYW1lfS4gTG9ncyB3aWxsIG5vdCBiZSBzdHJlYW1lZCBmb3IgdGhpcyBmdW5jdGlvbi5gLFxuICAgICAgICAgIExvZ0xldmVsLkRFQlVHXG4gICAgICAgICk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBsZXQgc2hvdWxkU3RyZWFtTG9ncyA9IGZhbHNlO1xuICAgICAgaWYgKHN0cmVhbWluZ09wdGlvbnMubG9nc0ZpbHRlcnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBmaWx0ZXIgb2Ygc3RyZWFtaW5nT3B0aW9ucy5sb2dzRmlsdGVycykge1xuICAgICAgICAgIGNvbnN0IHBhdHRlcm4gPSBuZXcgUmVnRXhwKGZpbHRlcik7XG4gICAgICAgICAgaWYgKHBhdHRlcm4udGVzdChmcmllbmRseUZ1bmN0aW9uTmFtZSkpIHtcbiAgICAgICAgICAgIHNob3VsZFN0cmVhbUxvZ3MgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5wcmludGVyLmxvZyhcbiAgICAgICAgICAgICAgYFtTYW5kYm94XSBMb2dzIGZvciBmdW5jdGlvbiAke2ZyaWVuZGx5RnVuY3Rpb25OYW1lfSB3aWxsIGJlIHN0cmVhbWVkIGFzIGl0IG1hdGNoZWQgZmlsdGVyICcke2ZpbHRlcn0nYCxcbiAgICAgICAgICAgICAgTG9nTGV2ZWwuREVCVUdcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5vIGxvZ3MgZmlsdGVyLCBtZWFucyB3ZSBzdHJlYW0gYWxsIGxvZ3NcbiAgICAgICAgdGhpcy5wcmludGVyLmxvZyhcbiAgICAgICAgICBgW1NhbmRib3hdIExvZ3MgZm9yIGZ1bmN0aW9uICR7ZnJpZW5kbHlGdW5jdGlvbk5hbWV9IHdpbGwgYmUgc3RyZWFtZWQuYCxcbiAgICAgICAgICBMb2dMZXZlbC5ERUJVR1xuICAgICAgICApO1xuICAgICAgICBzaG91bGRTdHJlYW1Mb2dzID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNob3VsZFN0cmVhbUxvZ3MpIHtcbiAgICAgICAgdGhpcy5sb2dzTW9uaXRvcj8uYWRkTG9nR3JvdXBzKGZyaWVuZGx5RnVuY3Rpb25OYW1lLCBsb2dHcm91cE5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmludGVyLmxvZyhcbiAgICAgICAgICBgW1NhbmRib3hdIFNraXBwaW5nIGxvZ3Mgc3RyZWFtaW5nIGZvciBmdW5jdGlvbiAke2ZyaWVuZGx5RnVuY3Rpb25OYW1lfSBzaW5jZSBpdCBkaWQgbm90IG1hdGNoIGFueSBmaWx0ZXJzLiBUbyBzdHJlYW0gbG9ncyBmb3IgdGhpcyBmdW5jdGlvbiwgZW5zdXJlIGF0IGxlYXN0IG9uZSBvZiB5b3VyIGxvZ3MtZmlsdGVycyBtYXRjaCB0aGlzIGZ1bmN0aW9uIG5hbWUuYCxcbiAgICAgICAgICBMb2dMZXZlbC5ERUJVR1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGZpbmFsbHkgc3RhcnQgbGlzdGVuaW5nXG4gICAgdGhpcy5sb2dzTW9uaXRvcj8uYWN0aXZhdGUoc3RyZWFtaW5nT3B0aW9ucy5sb2dzT3V0RmlsZSk7XG4gIH07XG5cbiAgc3RvcFN0cmVhbWluZ0xvZ3MgPSAoKSA9PiB7XG4gICAgaWYgKCF0aGlzLmVuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5wcmludGVyLmxvZyhcbiAgICAgIGBbU2FuZGJveF0gU3RyZWFtaW5nIGZ1bmN0aW9uIGxvZ3Mgd2lsbCBiZSBwYXVzZWQgZHVyaW5nIHRoZSBkZXBsb3ltZW50IGFuZCB3aWxsIGJlIHJlc3VtZWQgYWZ0ZXIgdGhlIGRlcGxveW1lbnQgaXMgY29tcGxldGVkLmAsXG4gICAgICBMb2dMZXZlbC5ERUJVR1xuICAgICk7XG4gICAgdGhpcy5sb2dzTW9uaXRvcj8ucGF1c2UoKTtcbiAgfTtcbn1cbiJdfQ==