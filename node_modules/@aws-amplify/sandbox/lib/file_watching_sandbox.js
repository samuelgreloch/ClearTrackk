import debounce from 'debounce-promise';
import parcelWatcher from '@parcel/watcher';
import parseGitIgnore from 'parse-gitignore';
import path from 'path';
import fs from 'fs';
import _open from 'open';
// EventEmitter is a class name and expected to have PascalCase
// eslint-disable-next-line @typescript-eslint/naming-convention
import EventEmitter from 'events';
import { GetParameterCommand, ParameterNotFound, SSMServiceException, } from '@aws-sdk/client-ssm';
import { AmplifyPrompter, LogLevel, format, } from '@aws-amplify/cli-core';
import { createFilesChangesTracker, } from './files_changes_tracker.js';
import { AmplifyError, AmplifyUserError, BackendIdentifierConversions, } from '@aws-amplify/platform-core';
import { EOL } from 'os';
/**
 * CDK stores bootstrap version in parameter store. Example parameter name looks like /cdk-bootstrap/<qualifier>/version.
 * The default value for qualifier is hnb659fds, i.e. default parameter path is /cdk-bootstrap/hnb659fds/version.
 * The default qualifier is hardcoded value without any significance.
 * Ability to provide custom qualifier is intended for name isolation between automated tests of the CDK itself.
 * In order to use custom qualifier all stack synthesizers must be programmatically configured to use it.
 * That makes bootstraps with custom qualifier incompatible with Amplify Backend and we treat that setup as
 * not bootstrapped.
 * See: https://docs.aws.amazon.com/cdk/v2/guide/bootstrapping.html
 */
export const CDK_DEFAULT_BOOTSTRAP_VERSION_PARAMETER_NAME = 
// suppress spell checker, it is triggered by qualifier value.
// eslint-disable-next-line spellcheck/spell-checker
'/cdk-bootstrap/hnb659fds/version';
export const CDK_MIN_BOOTSTRAP_VERSION = 6;
/**
 * Constructs Amplify Console bootstrap URL for a given region
 * @param region AWS region
 * @returns Amplify Console bootstrap URL
 */
export const getBootstrapUrl = (region) => `https://${region}.console.aws.amazon.com/amplify/create/bootstrap?region=${region}`;
/**
 * Runs a file watcher and deploys
 */
export class FileWatchingSandbox extends EventEmitter {
    backendIdSandboxResolver;
    executor;
    ssmClient;
    functionsLogStreamer;
    printer;
    open;
    watcherSubscription;
    outputFilesExcludedFromWatch = ['.amplify'];
    filesChangesTracker;
    /**
     * Creates a watcher process for this instance
     */
    constructor(backendIdSandboxResolver, executor, ssmClient, functionsLogStreamer, printer, open = _open) {
        process.once('SIGINT', () => void this.stop());
        process.once('SIGTERM', () => void this.stop());
        super();
        this.backendIdSandboxResolver = backendIdSandboxResolver;
        this.executor = executor;
        this.ssmClient = ssmClient;
        this.functionsLogStreamer = functionsLogStreamer;
        this.printer = printer;
        this.open = open;
    }
    /**
     * @inheritdoc
     */
    emit(eventName, ...args) {
        return super.emit(eventName, ...args);
    }
    /**
     * @inheritdoc
     */
    on(eventName, listener) {
        return super.on(eventName, listener);
    }
    /**
     * @inheritdoc
     */
    start = async (options) => {
        const watchDir = options.dir ?? './amplify';
        const watchForChanges = options.watchForChanges ?? true;
        if (!fs.existsSync(watchDir)) {
            throw new AmplifyUserError('PathNotFoundError', {
                message: `${watchDir} does not exist.`,
                resolution: 'Make sure you are running this command from your project root directory.',
            });
        }
        this.filesChangesTracker = await createFilesChangesTracker(watchDir);
        const bootstrapped = await this.isBootstrapped();
        // get region from an available sdk client;
        const region = await this.ssmClient.config.region();
        if (!bootstrapped) {
            this.printer.log(`The region ${format.highlight(region)} has not been bootstrapped. Sign in to the AWS console as a Root user or Admin to complete the bootstrap process, then restart the sandbox.${EOL}If this is not the region you are expecting to bootstrap, check for any AWS environment variables that may be set in your shell or use ${format.command('--profile <profile-name>')} to specify a profile with the correct region.`);
            const bootstrapUrl = getBootstrapUrl(region);
            try {
                await this.open(bootstrapUrl);
            }
            catch (e) {
                // If opening the link fails for any reason we fall back to
                // printing the url in the console.
                // This might happen:
                // - in headless environments
                // - if user does not have any app to open URL
                // - if browser crashes
                let logEntry = 'Unable to open bootstrap url';
                if (e instanceof Error) {
                    logEntry = `${logEntry}, ${e.message}`;
                }
                this.printer.log(logEntry, LogLevel.DEBUG);
                this.printer.log(`Open ${bootstrapUrl} in the browser.`);
            }
            return;
        }
        const ignoredPaths = this.getGitIgnoredPaths();
        this.outputFilesExcludedFromWatch =
            this.outputFilesExcludedFromWatch.concat(...ignoredPaths);
        await this.printSandboxNameInfo(options.identifier);
        // Since 'cdk deploy' is a relatively slow operation for a 'watch' process,
        // introduce a concurrency latch that tracks the state.
        // This way, if file change events arrive when a 'cdk deploy' is still executing,
        // we will batch them, and trigger another 'cdk deploy' after the current one finishes,
        // making sure 'cdk deploy's  always execute one at a time.
        // Here's a diagram showing the state transitions:
        // --------    file changed     --------------    file changed     --------------  file changed
        // |      | ------------------> |            | ------------------> |            | --------------|
        // | open |                     | deploying  |                     |   queued   |               |
        // |      | <------------------ |            | <------------------ |            | <-------------|
        // --------  'cdk deploy' done  --------------  'cdk deploy' done  --------------
        let latch = 'open';
        const deployAndWatch = debounce(async () => {
            latch = 'deploying';
            // Stop streaming the logs so that deployment logs don't get mixed up
            this.functionsLogStreamer.stopStreamingLogs();
            await this.deploy(options);
            // If latch is still 'deploying' after the 'await', that's fine,
            // but if it's 'queued', that means we need to deploy again
            while (latch === 'queued') {
                // TypeScript doesn't realize latch can change between 'awaits' ¯\_(ツ)_/¯,
                // and thinks the above 'while' condition is always 'false' without the cast
                latch = 'deploying';
                this.printer.log("[Sandbox] Detected file changes while previous deployment was in progress. Invoking 'sandbox' again");
                await this.deploy(options);
            }
            latch = 'open';
            // Idle state, let customers know and start streaming function logs
            this.emitWatching();
            await this.functionsLogStreamer.startStreamingLogs(await this.backendIdSandboxResolver(options.identifier), options.functionStreamingOptions);
        });
        if (watchForChanges) {
            this.watcherSubscription = await parcelWatcher.subscribe(watchDir, async (_, events) => {
                // Log and track file changes.
                await Promise.all(events.map(({ type: eventName, path }) => {
                    this.filesChangesTracker.trackFileChange(path);
                    this.printer.log(`[Sandbox] Triggered due to a file ${eventName} event: ${path}`);
                }));
                if (latch === 'open') {
                    await deployAndWatch();
                }
                else {
                    // this means latch is either 'deploying' or 'queued'
                    latch = 'queued';
                    this.printer.log('[Sandbox] Previous deployment is still in progress. ' +
                        'Will queue for another deployment after this one finishes');
                }
            }, {
                ignore: this.outputFilesExcludedFromWatch.concat(...(options.exclude ?? [])),
            });
            // Start the first full deployment without waiting for a file change
            await deployAndWatch();
        }
        else {
            await this.deploy(options);
        }
    };
    /**
     * @inheritdoc
     */
    stop = async () => {
        this.printer.log(`[Sandbox] Shutting down`, LogLevel.DEBUG);
        this.functionsLogStreamer?.stopStreamingLogs();
        // can be undefined if command exits before subscription
        await this.watcherSubscription?.unsubscribe();
    };
    /**
     * @inheritdoc
     */
    delete = async (options) => {
        this.printer.log('[Sandbox] Deleting all the resources in the sandbox environment...');
        await this.executor.destroy(await this.backendIdSandboxResolver(options.identifier), options.profile);
        this.emit('successfulDeletion');
        this.printer.log('[Sandbox] Finished deleting.');
    };
    shouldValidateAppSources = () => {
        const snapshot = this.filesChangesTracker.getAndResetSnapshot();
        // if zero files changed this indicates initial deployment
        const shouldValidateOnColdStart = snapshot.hadTypeScriptFilesAtStart &&
            !snapshot.didAnyFileChangeSinceStart;
        return (shouldValidateOnColdStart ||
            snapshot.didAnyTypeScriptFileChangeSinceLastSnapshot);
    };
    deploy = async (options) => {
        try {
            const deployResult = await this.executor.deploy(await this.backendIdSandboxResolver(options.identifier), 
            // It's important to pass this as callback so that debounce does
            // not reset tracker prematurely
            this.shouldValidateAppSources, options.profile);
            this.printer.log('[Sandbox] Deployment successful', LogLevel.DEBUG);
            this.emit('successfulDeployment', deployResult);
        }
        catch (error) {
            // Print a meaningful message
            this.printer.print(format.error(this.getErrorMessage(error)));
            this.emit('failedDeployment', error);
            // If the error is because of a non-allowed destructive change such as
            // https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-cognito-userpool.html#cfn-cognito-userpool-aliasattributes
            // offer to recreate the sandbox or revert the change
            if (AmplifyError.isAmplifyError(error) &&
                error.name === 'CFNUpdateNotSupportedError') {
                await this.handleUnsupportedDestructiveChanges(options);
            }
            // else do not propagate and let the sandbox continue to run
        }
    };
    reset = async (options) => {
        await this.delete({ identifier: options.identifier });
        await this.start(options);
    };
    /**
     * Just a shorthand console log to indicate whenever watcher is going idle
     */
    emitWatching = () => {
        this.printer.log(`[Sandbox] Watching for file changes...`);
    };
    /**
     * Reads and parses .gitignore file and returns the list of paths
     */
    getGitIgnoredPaths = () => {
        const gitIgnoreFilePath = path.join(process.cwd(), '.gitignore');
        if (fs.existsSync(gitIgnoreFilePath)) {
            return parseGitIgnore
                .parse(gitIgnoreFilePath)
                .patterns.map((pattern) => pattern.startsWith('/') ? pattern.substring(1) : pattern)
                .filter((pattern) => {
                if (pattern.startsWith('!')) {
                    this.printer.log(`[Sandbox] Pattern ${pattern} found in .gitignore. "${pattern.substring(1)}" will not be watched if other patterns in .gitignore are excluding it.`);
                    return false;
                }
                return true;
            });
        }
        return [];
    };
    /**
     * Checks if a given region has been bootstrapped with >= min version using CDK bootstrap version parameter
     * stored in parameter store.
     * @returns A Boolean that represents if region has been bootstrapped.
     */
    isBootstrapped = async () => {
        try {
            const { Parameter: parameter } = await this.ssmClient.send(new GetParameterCommand({
                Name: CDK_DEFAULT_BOOTSTRAP_VERSION_PARAMETER_NAME,
            }));
            const bootstrapVersion = parameter?.Value;
            if (!bootstrapVersion ||
                Number(bootstrapVersion) < CDK_MIN_BOOTSTRAP_VERSION) {
                return false;
            }
            return true;
        }
        catch (e) {
            if (e instanceof ParameterNotFound) {
                return false;
            }
            if (e instanceof SSMServiceException &&
                [
                    'UnrecognizedClientException',
                    'AccessDeniedException',
                    'NotAuthorized',
                    'ExpiredTokenException',
                    'ExpiredToken',
                    'InvalidSignatureException',
                ].includes(e.name)) {
                throw new AmplifyUserError('SSMCredentialsError', {
                    message: `${e.name}: ${e.message}`,
                    resolution: 'Make sure your AWS credentials are set up correctly and have permissions to call SSM:GetParameter',
                }, e);
            }
            // If we are unable to retrieve bootstrap version parameter due to other reasons, we fail fast.
            throw e;
        }
    };
    /**
     * Generates a printable error message from the thrown error
     */
    getErrorMessage = (error) => {
        let message;
        if (error instanceof Error) {
            message = error.message;
            // Add the downstream exception
            if (error.cause && error.cause instanceof Error && error.cause.message) {
                message = `${message}\nCaused By: ${error.cause.message}\n`;
            }
            if (AmplifyError.isAmplifyError(error) && error.resolution) {
                message = `${message}\nResolution: ${error.resolution}\n`;
            }
        }
        else
            message = String(error);
        return message;
    };
    handleUnsupportedDestructiveChanges = async (options) => {
        this.printer.print(format.error('[Sandbox] We cannot deploy your new changes. You can either revert them or recreate your sandbox with the new changes (deleting all user data)'));
        // offer to recreate the sandbox with new properties
        const answer = await AmplifyPrompter.yesOrNo({
            message: 'Would you like to recreate your sandbox (deleting all user data)?',
            defaultValue: false,
        });
        if (answer) {
            await this.stop();
            await this.reset(options);
        }
        // else let the sandbox continue so customers can revert their changes
    };
    printSandboxNameInfo = async (sandboxIdentifier) => {
        const sandboxBackendId = await this.backendIdSandboxResolver(sandboxIdentifier);
        const stackName = BackendIdentifierConversions.toStackName(sandboxBackendId);
        this.printer.log(format.indent(format.highlight(format.bold('\nAmplify Sandbox\n'))));
        this.printer.log(format.indent(`${format.bold('Identifier:')} \t${sandboxBackendId.name}`));
        this.printer.log(format.indent(`${format.bold('Stack:')} \t${stackName}`));
        if (!sandboxIdentifier) {
            this.printer.log(`${format.indent(format.dim('\nTo specify a different sandbox identifier, use '))}${format.bold('--identifier')}`);
        }
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmlsZV93YXRjaGluZ19zYW5kYm94LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2ZpbGVfd2F0Y2hpbmdfc2FuZGJveC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLFFBQVEsTUFBTSxrQkFBa0IsQ0FBQztBQUN4QyxPQUFPLGFBQTRCLE1BQU0saUJBQWlCLENBQUM7QUFTM0QsT0FBTyxjQUFjLE1BQU0saUJBQWlCLENBQUM7QUFDN0MsT0FBTyxJQUFJLE1BQU0sTUFBTSxDQUFDO0FBQ3hCLE9BQU8sRUFBRSxNQUFNLElBQUksQ0FBQztBQUNwQixPQUFPLEtBQUssTUFBTSxNQUFNLENBQUM7QUFDekIsK0RBQStEO0FBQy9ELGdFQUFnRTtBQUNoRSxPQUFPLFlBQVksTUFBTSxRQUFRLENBQUM7QUFDbEMsT0FBTyxFQUNMLG1CQUFtQixFQUNuQixpQkFBaUIsRUFFakIsbUJBQW1CLEdBQ3BCLE1BQU0scUJBQXFCLENBQUM7QUFDN0IsT0FBTyxFQUNMLGVBQWUsRUFDZixRQUFRLEVBRVIsTUFBTSxHQUNQLE1BQU0sdUJBQXVCLENBQUM7QUFDL0IsT0FBTyxFQUVMLHlCQUF5QixHQUMxQixNQUFNLDRCQUE0QixDQUFDO0FBQ3BDLE9BQU8sRUFDTCxZQUFZLEVBQ1osZ0JBQWdCLEVBQ2hCLDRCQUE0QixHQUM3QixNQUFNLDRCQUE0QixDQUFDO0FBRXBDLE9BQU8sRUFBRSxHQUFHLEVBQUUsTUFBTSxJQUFJLENBQUM7QUFFekI7Ozs7Ozs7OztHQVNHO0FBQ0gsTUFBTSxDQUFDLE1BQU0sNENBQTRDO0FBQ3ZELDhEQUE4RDtBQUM5RCxvREFBb0Q7QUFDcEQsa0NBQWtDLENBQUM7QUFDckMsTUFBTSxDQUFDLE1BQU0seUJBQXlCLEdBQUcsQ0FBQyxDQUFDO0FBRTNDOzs7O0dBSUc7QUFDSCxNQUFNLENBQUMsTUFBTSxlQUFlLEdBQUcsQ0FBQyxNQUFjLEVBQUUsRUFBRSxDQUNoRCxXQUFXLE1BQU0sMkRBQTJELE1BQU0sRUFB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QUFFO1FBQ2xFLE1BQU0sZ0JBQWdCLEdBQUcsTUFBTSxJQUFJLENBQUMsd0JBQXdCLENBQzFELGlCQUFpQixDQUNsQixDQUFDO1FBQ0YsTUFBTSxTQUFTLEdBQ2IsNEJBQTRCLENBQUMsV0FBVyxDQUFDLGdCQUFnQixDQUFDLENBQUM7UUFDN0QsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQ2QsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMscUJBQXFCLENBQUMsQ0FBQyxDQUFDLENBQ3BFLENBQUM7UUFDRixJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FDZCxNQUFNLENBQUMsTUFBTSxDQUFDLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxnQkFBZ0IsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUMxRSxDQUFDO1FBQ0YsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sU0FBUyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQzNFLElBQUksQ0FBQyxpQkFBaUIsRUFBRTtZQUN0QixJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FDZCxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQ2QsTUFBTSxDQUFDLEdBQUcsQ0FBQyxtREFBbUQsQ0FBQyxDQUNoRSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLEVBQUUsQ0FDbEMsQ0FBQztTQUNIO0lBQ0gsQ0FBQyxDQUFDO0NBQ0giLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZGVib3VuY2UgZnJvbSAnZGVib3VuY2UtcHJvbWlzZSc7XG5pbXBvcnQgcGFyY2VsV2F0Y2hlciwgeyBzdWJzY3JpYmUgfSBmcm9tICdAcGFyY2VsL3dhdGNoZXInO1xuaW1wb3J0IHsgQW1wbGlmeVNhbmRib3hFeGVjdXRvciB9IGZyb20gJy4vc2FuZGJveF9leGVjdXRvci5qcyc7XG5pbXBvcnQge1xuICBCYWNrZW5kSWRTYW5kYm94UmVzb2x2ZXIsXG4gIFNhbmRib3gsXG4gIFNhbmRib3hEZWxldGVPcHRpb25zLFxuICBTYW5kYm94RXZlbnRzLFxuICBTYW5kYm94T3B0aW9ucyxcbn0gZnJvbSAnLi9zYW5kYm94LmpzJztcbmltcG9ydCBwYXJzZUdpdElnbm9yZSBmcm9tICdwYXJzZS1naXRpZ25vcmUnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgZnMgZnJvbSAnZnMnO1xuaW1wb3J0IF9vcGVuIGZyb20gJ29wZW4nO1xuLy8gRXZlbnRFbWl0dGVyIGlzIGEgY2xhc3MgbmFtZSBhbmQgZXhwZWN0ZWQgdG8gaGF2ZSBQYXNjYWxDYXNlXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQge1xuICBHZXRQYXJhbWV0ZXJDb21tYW5kLFxuICBQYXJhbWV0ZXJOb3RGb3VuZCxcbiAgU1NNQ2xpZW50LFxuICBTU01TZXJ2aWNlRXhjZXB0aW9uLFxufSBmcm9tICdAYXdzLXNkay9jbGllbnQtc3NtJztcbmltcG9ydCB7XG4gIEFtcGxpZnlQcm9tcHRlcixcbiAgTG9nTGV2ZWwsXG4gIFByaW50ZXIsXG4gIGZvcm1hdCxcbn0gZnJvbSAnQGF3cy1hbXBsaWZ5L2NsaS1jb3JlJztcbmltcG9ydCB7XG4gIEZpbGVzQ2hhbmdlc1RyYWNrZXIsXG4gIGNyZWF0ZUZpbGVzQ2hhbmdlc1RyYWNrZXIsXG59IGZyb20gJy4vZmlsZXNfY2hhbmdlc190cmFja2VyLmpzJztcbmltcG9ydCB7XG4gIEFtcGxpZnlFcnJvcixcbiAgQW1wbGlmeVVzZXJFcnJvcixcbiAgQmFja2VuZElkZW50aWZpZXJDb252ZXJzaW9ucyxcbn0gZnJvbSAnQGF3cy1hbXBsaWZ5L3BsYXRmb3JtLWNvcmUnO1xuaW1wb3J0IHsgTGFtYmRhRnVuY3Rpb25Mb2dTdHJlYW1lciB9IGZyb20gJy4vbGFtYmRhX2Z1bmN0aW9uX2xvZ19zdHJlYW1lci5qcyc7XG5pbXBvcnQgeyBFT0wgfSBmcm9tICdvcyc7XG5cbi8qKlxuICogQ0RLIHN0b3JlcyBib290c3RyYXAgdmVyc2lvbiBpbiBwYXJhbWV0ZXIgc3RvcmUuIEV4YW1wbGUgcGFyYW1ldGVyIG5hbWUgbG9va3MgbGlrZSAvY2RrLWJvb3RzdHJhcC88cXVhbGlmaWVyPi92ZXJzaW9uLlxuICogVGhlIGRlZmF1bHQgdmFsdWUgZm9yIHF1YWxpZmllciBpcyBobmI2NTlmZHMsIGkuZS4gZGVmYXVsdCBwYXJhbWV0ZXIgcGF0aCBpcyAvY2RrLWJvb3RzdHJhcC9obmI2NTlmZHMvdmVyc2lvbi5cbiAqIFRoZSBkZWZhdWx0IHF1YWxpZmllciBpcyBoYXJkY29kZWQgdmFsdWUgd2l0aG91dCBhbnkgc2lnbmlmaWNhbmNlLlxuICogQWJpbGl0eSB0byBwcm92aWRlIGN1c3RvbSBxdWFsaWZpZXIgaXMgaW50ZW5kZWQgZm9yIG5hbWUgaXNvbGF0aW9uIGJldHdlZW4gYXV0b21hdGVkIHRlc3RzIG9mIHRoZSBDREsgaXRzZWxmLlxuICogSW4gb3JkZXIgdG8gdXNlIGN1c3RvbSBxdWFsaWZpZXIgYWxsIHN0YWNrIHN5bnRoZXNpemVycyBtdXN0IGJlIHByb2dyYW1tYXRpY2FsbHkgY29uZmlndXJlZCB0byB1c2UgaXQuXG4gKiBUaGF0IG1ha2VzIGJvb3RzdHJhcHMgd2l0aCBjdXN0b20gcXVhbGlmaWVyIGluY29tcGF0aWJsZSB3aXRoIEFtcGxpZnkgQmFja2VuZCBhbmQgd2UgdHJlYXQgdGhhdCBzZXR1cCBhc1xuICogbm90IGJvb3RzdHJhcHBlZC5cbiAqIFNlZTogaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL2Nkay92Mi9ndWlkZS9ib290c3RyYXBwaW5nLmh0bWxcbiAqL1xuZXhwb3J0IGNvbnN0IENES19ERUZBVUxUX0JPT1RTVFJBUF9WRVJTSU9OX1BBUkFNRVRFUl9OQU1FID1cbiAgLy8gc3VwcHJlc3Mgc3BlbGwgY2hlY2tlciwgaXQgaXMgdHJpZ2dlcmVkIGJ5IHF1YWxpZmllciB2YWx1ZS5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHNwZWxsY2hlY2svc3BlbGwtY2hlY2tlclxuICAnL2Nkay1ib290c3RyYXAvaG5iNjU5ZmRzL3ZlcnNpb24nO1xuZXhwb3J0IGNvbnN0IENES19NSU5fQk9PVFNUUkFQX1ZFUlNJT04gPSA2O1xuXG4vKipcbiAqIENvbnN0cnVjdHMgQW1wbGlmeSBDb25zb2xlIGJvb3RzdHJhcCBVUkwgZm9yIGEgZ2l2ZW4gcmVnaW9uXG4gKiBAcGFyYW0gcmVnaW9uIEFXUyByZWdpb25cbiAqIEByZXR1cm5zIEFtcGxpZnkgQ29uc29sZSBib290c3RyYXAgVVJMXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRCb290c3RyYXBVcmwgPSAocmVnaW9uOiBzdHJpbmcpID0+XG4gIGBodHRwczovLyR7cmVnaW9ufS5jb25zb2xlLmF3cy5hbWF6b24uY29tL2FtcGxpZnkvY3JlYXRlL2Jvb3RzdHJhcD9yZWdpb249JHtyZWdpb259YDtcblxuLyoqXG4gKiBSdW5zIGEgZmlsZSB3YXRjaGVyIGFuZCBkZXBsb3lzXG4gKi9cbmV4cG9ydCBjbGFzcyBGaWxlV2F0Y2hpbmdTYW5kYm94IGV4dGVuZHMgRXZlbnRFbWl0dGVyIGltcGxlbWVudHMgU2FuZGJveCB7XG4gIHByaXZhdGUgd2F0Y2hlclN1YnNjcmlwdGlvbjogQXdhaXRlZDxSZXR1cm5UeXBlPHR5cGVvZiBzdWJzY3JpYmU+PjtcbiAgcHJpdmF0ZSBvdXRwdXRGaWxlc0V4Y2x1ZGVkRnJvbVdhdGNoID0gWycuYW1wbGlmeSddO1xuICBwcml2YXRlIGZpbGVzQ2hhbmdlc1RyYWNrZXI6IEZpbGVzQ2hhbmdlc1RyYWNrZXI7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSB3YXRjaGVyIHByb2Nlc3MgZm9yIHRoaXMgaW5zdGFuY2VcbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgYmFja2VuZElkU2FuZGJveFJlc29sdmVyOiBCYWNrZW5kSWRTYW5kYm94UmVzb2x2ZXIsXG4gICAgcHJpdmF0ZSByZWFkb25seSBleGVjdXRvcjogQW1wbGlmeVNhbmRib3hFeGVjdXRvcixcbiAgICBwcml2YXRlIHJlYWRvbmx5IHNzbUNsaWVudDogU1NNQ2xpZW50LFxuICAgIHByaXZhdGUgcmVhZG9ubHkgZnVuY3Rpb25zTG9nU3RyZWFtZXI6IExhbWJkYUZ1bmN0aW9uTG9nU3RyZWFtZXIsXG4gICAgcHJpdmF0ZSByZWFkb25seSBwcmludGVyOiBQcmludGVyLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgb3BlbiA9IF9vcGVuXG4gICkge1xuICAgIHByb2Nlc3Mub25jZSgnU0lHSU5UJywgKCkgPT4gdm9pZCB0aGlzLnN0b3AoKSk7XG4gICAgcHJvY2Vzcy5vbmNlKCdTSUdURVJNJywgKCkgPT4gdm9pZCB0aGlzLnN0b3AoKSk7XG4gICAgc3VwZXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdGRvY1xuICAgKi9cbiAgb3ZlcnJpZGUgZW1pdChldmVudE5hbWU6IFNhbmRib3hFdmVudHMsIC4uLmFyZ3M6IHVua25vd25bXSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBzdXBlci5lbWl0KGV2ZW50TmFtZSwgLi4uYXJncyk7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXRkb2NcbiAgICovXG4gIG92ZXJyaWRlIG9uKFxuICAgIGV2ZW50TmFtZTogU2FuZGJveEV2ZW50cyxcbiAgICBsaXN0ZW5lcjogKC4uLmFyZ3M6IHVua25vd25bXSkgPT4gdm9pZFxuICApOiB0aGlzIHtcbiAgICByZXR1cm4gc3VwZXIub24oZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXRkb2NcbiAgICovXG4gIHN0YXJ0ID0gYXN5bmMgKG9wdGlvbnM6IFNhbmRib3hPcHRpb25zKSA9PiB7XG4gICAgY29uc3Qgd2F0Y2hEaXIgPSBvcHRpb25zLmRpciA/PyAnLi9hbXBsaWZ5JztcbiAgICBjb25zdCB3YXRjaEZvckNoYW5nZXMgPSBvcHRpb25zLndhdGNoRm9yQ2hhbmdlcyA/PyB0cnVlO1xuXG4gICAgaWYgKCFmcy5leGlzdHNTeW5jKHdhdGNoRGlyKSkge1xuICAgICAgdGhyb3cgbmV3IEFtcGxpZnlVc2VyRXJyb3IoJ1BhdGhOb3RGb3VuZEVycm9yJywge1xuICAgICAgICBtZXNzYWdlOiBgJHt3YXRjaERpcn0gZG9lcyBub3QgZXhpc3QuYCxcbiAgICAgICAgcmVzb2x1dGlvbjpcbiAgICAgICAgICAnTWFrZSBzdXJlIHlvdSBhcmUgcnVubmluZyB0aGlzIGNvbW1hbmQgZnJvbSB5b3VyIHByb2plY3Qgcm9vdCBkaXJlY3RvcnkuJyxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuZmlsZXNDaGFuZ2VzVHJhY2tlciA9IGF3YWl0IGNyZWF0ZUZpbGVzQ2hhbmdlc1RyYWNrZXIod2F0Y2hEaXIpO1xuICAgIGNvbnN0IGJvb3RzdHJhcHBlZCA9IGF3YWl0IHRoaXMuaXNCb290c3RyYXBwZWQoKTtcbiAgICAvLyBnZXQgcmVnaW9uIGZyb20gYW4gYXZhaWxhYmxlIHNkayBjbGllbnQ7XG4gICAgY29uc3QgcmVnaW9uID0gYXdhaXQgdGhpcy5zc21DbGllbnQuY29uZmlnLnJlZ2lvbigpO1xuICAgIGlmICghYm9vdHN0cmFwcGVkKSB7XG4gICAgICB0aGlzLnByaW50ZXIubG9nKFxuICAgICAgICBgVGhlIHJlZ2lvbiAke2Zvcm1hdC5oaWdobGlnaHQoXG4gICAgICAgICAgcmVnaW9uXG4gICAgICAgICl9IGhhcyBub3QgYmVlbiBib290c3RyYXBwZWQuIFNpZ24gaW4gdG8gdGhlIEFXUyBjb25zb2xlIGFzIGEgUm9vdCB1c2VyIG9yIEFkbWluIHRvIGNvbXBsZXRlIHRoZSBib290c3RyYXAgcHJvY2VzcywgdGhlbiByZXN0YXJ0IHRoZSBzYW5kYm94LiR7RU9MfUlmIHRoaXMgaXMgbm90IHRoZSByZWdpb24geW91IGFyZSBleHBlY3RpbmcgdG8gYm9vdHN0cmFwLCBjaGVjayBmb3IgYW55IEFXUyBlbnZpcm9ubWVudCB2YXJpYWJsZXMgdGhhdCBtYXkgYmUgc2V0IGluIHlvdXIgc2hlbGwgb3IgdXNlICR7Zm9ybWF0LmNvbW1hbmQoXG4gICAgICAgICAgJy0tcHJvZmlsZSA8cHJvZmlsZS1uYW1lPidcbiAgICAgICAgKX0gdG8gc3BlY2lmeSBhIHByb2ZpbGUgd2l0aCB0aGUgY29ycmVjdCByZWdpb24uYFxuICAgICAgKTtcbiAgICAgIGNvbnN0IGJvb3RzdHJhcFVybCA9IGdldEJvb3RzdHJhcFVybChyZWdpb24pO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5vcGVuKGJvb3RzdHJhcFVybCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIElmIG9wZW5pbmcgdGhlIGxpbmsgZmFpbHMgZm9yIGFueSByZWFzb24gd2UgZmFsbCBiYWNrIHRvXG4gICAgICAgIC8vIHByaW50aW5nIHRoZSB1cmwgaW4gdGhlIGNvbnNvbGUuXG4gICAgICAgIC8vIFRoaXMgbWlnaHQgaGFwcGVuOlxuICAgICAgICAvLyAtIGluIGhlYWRsZXNzIGVudmlyb25tZW50c1xuICAgICAgICAvLyAtIGlmIHVzZXIgZG9lcyBub3QgaGF2ZSBhbnkgYXBwIHRvIG9wZW4gVVJMXG4gICAgICAgIC8vIC0gaWYgYnJvd3NlciBjcmFzaGVzXG4gICAgICAgIGxldCBsb2dFbnRyeSA9ICdVbmFibGUgdG8gb3BlbiBib290c3RyYXAgdXJsJztcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIGxvZ0VudHJ5ID0gYCR7bG9nRW50cnl9LCAke2UubWVzc2FnZX1gO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJpbnRlci5sb2cobG9nRW50cnksIExvZ0xldmVsLkRFQlVHKTtcbiAgICAgICAgdGhpcy5wcmludGVyLmxvZyhgT3BlbiAke2Jvb3RzdHJhcFVybH0gaW4gdGhlIGJyb3dzZXIuYCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgaWdub3JlZFBhdGhzID0gdGhpcy5nZXRHaXRJZ25vcmVkUGF0aHMoKTtcbiAgICB0aGlzLm91dHB1dEZpbGVzRXhjbHVkZWRGcm9tV2F0Y2ggPVxuICAgICAgdGhpcy5vdXRwdXRGaWxlc0V4Y2x1ZGVkRnJvbVdhdGNoLmNvbmNhdCguLi5pZ25vcmVkUGF0aHMpO1xuXG4gICAgYXdhaXQgdGhpcy5wcmludFNhbmRib3hOYW1lSW5mbyhvcHRpb25zLmlkZW50aWZpZXIpO1xuXG4gICAgLy8gU2luY2UgJ2NkayBkZXBsb3knIGlzIGEgcmVsYXRpdmVseSBzbG93IG9wZXJhdGlvbiBmb3IgYSAnd2F0Y2gnIHByb2Nlc3MsXG4gICAgLy8gaW50cm9kdWNlIGEgY29uY3VycmVuY3kgbGF0Y2ggdGhhdCB0cmFja3MgdGhlIHN0YXRlLlxuICAgIC8vIFRoaXMgd2F5LCBpZiBmaWxlIGNoYW5nZSBldmVudHMgYXJyaXZlIHdoZW4gYSAnY2RrIGRlcGxveScgaXMgc3RpbGwgZXhlY3V0aW5nLFxuICAgIC8vIHdlIHdpbGwgYmF0Y2ggdGhlbSwgYW5kIHRyaWdnZXIgYW5vdGhlciAnY2RrIGRlcGxveScgYWZ0ZXIgdGhlIGN1cnJlbnQgb25lIGZpbmlzaGVzLFxuICAgIC8vIG1ha2luZyBzdXJlICdjZGsgZGVwbG95J3MgIGFsd2F5cyBleGVjdXRlIG9uZSBhdCBhIHRpbWUuXG4gICAgLy8gSGVyZSdzIGEgZGlhZ3JhbSBzaG93aW5nIHRoZSBzdGF0ZSB0cmFuc2l0aW9uczpcblxuICAgIC8vIC0tLS0tLS0tICAgIGZpbGUgY2hhbmdlZCAgICAgLS0tLS0tLS0tLS0tLS0gICAgZmlsZSBjaGFuZ2VkICAgICAtLS0tLS0tLS0tLS0tLSAgZmlsZSBjaGFuZ2VkXG4gICAgLy8gfCAgICAgIHwgLS0tLS0tLS0tLS0tLS0tLS0tPiB8ICAgICAgICAgICAgfCAtLS0tLS0tLS0tLS0tLS0tLS0+IHwgICAgICAgICAgICB8IC0tLS0tLS0tLS0tLS0tfFxuICAgIC8vIHwgb3BlbiB8ICAgICAgICAgICAgICAgICAgICAgfCBkZXBsb3lpbmcgIHwgICAgICAgICAgICAgICAgICAgICB8ICAgcXVldWVkICAgfCAgICAgICAgICAgICAgIHxcbiAgICAvLyB8ICAgICAgfCA8LS0tLS0tLS0tLS0tLS0tLS0tIHwgICAgICAgICAgICB8IDwtLS0tLS0tLS0tLS0tLS0tLS0gfCAgICAgICAgICAgIHwgPC0tLS0tLS0tLS0tLS18XG4gICAgLy8gLS0tLS0tLS0gICdjZGsgZGVwbG95JyBkb25lICAtLS0tLS0tLS0tLS0tLSAgJ2NkayBkZXBsb3knIGRvbmUgIC0tLS0tLS0tLS0tLS0tXG5cbiAgICBsZXQgbGF0Y2g6ICdvcGVuJyB8ICdkZXBsb3lpbmcnIHwgJ3F1ZXVlZCcgPSAnb3Blbic7XG5cbiAgICBjb25zdCBkZXBsb3lBbmRXYXRjaCA9IGRlYm91bmNlKGFzeW5jICgpID0+IHtcbiAgICAgIGxhdGNoID0gJ2RlcGxveWluZyc7XG5cbiAgICAgIC8vIFN0b3Agc3RyZWFtaW5nIHRoZSBsb2dzIHNvIHRoYXQgZGVwbG95bWVudCBsb2dzIGRvbid0IGdldCBtaXhlZCB1cFxuICAgICAgdGhpcy5mdW5jdGlvbnNMb2dTdHJlYW1lci5zdG9wU3RyZWFtaW5nTG9ncygpO1xuXG4gICAgICBhd2FpdCB0aGlzLmRlcGxveShvcHRpb25zKTtcblxuICAgICAgLy8gSWYgbGF0Y2ggaXMgc3RpbGwgJ2RlcGxveWluZycgYWZ0ZXIgdGhlICdhd2FpdCcsIHRoYXQncyBmaW5lLFxuICAgICAgLy8gYnV0IGlmIGl0J3MgJ3F1ZXVlZCcsIHRoYXQgbWVhbnMgd2UgbmVlZCB0byBkZXBsb3kgYWdhaW5cbiAgICAgIHdoaWxlICgobGF0Y2ggYXMgJ2RlcGxveWluZycgfCAncXVldWVkJykgPT09ICdxdWV1ZWQnKSB7XG4gICAgICAgIC8vIFR5cGVTY3JpcHQgZG9lc24ndCByZWFsaXplIGxhdGNoIGNhbiBjaGFuZ2UgYmV0d2VlbiAnYXdhaXRzJyDCr1xcXyjjg4QpXy/CryxcbiAgICAgICAgLy8gYW5kIHRoaW5rcyB0aGUgYWJvdmUgJ3doaWxlJyBjb25kaXRpb24gaXMgYWx3YXlzICdmYWxzZScgd2l0aG91dCB0aGUgY2FzdFxuICAgICAgICBsYXRjaCA9ICdkZXBsb3lpbmcnO1xuICAgICAgICB0aGlzLnByaW50ZXIubG9nKFxuICAgICAgICAgIFwiW1NhbmRib3hdIERldGVjdGVkIGZpbGUgY2hhbmdlcyB3aGlsZSBwcmV2aW91cyBkZXBsb3ltZW50IHdhcyBpbiBwcm9ncmVzcy4gSW52b2tpbmcgJ3NhbmRib3gnIGFnYWluXCJcbiAgICAgICAgKTtcbiAgICAgICAgYXdhaXQgdGhpcy5kZXBsb3kob3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBsYXRjaCA9ICdvcGVuJztcblxuICAgICAgLy8gSWRsZSBzdGF0ZSwgbGV0IGN1c3RvbWVycyBrbm93IGFuZCBzdGFydCBzdHJlYW1pbmcgZnVuY3Rpb24gbG9nc1xuICAgICAgdGhpcy5lbWl0V2F0Y2hpbmcoKTtcbiAgICAgIGF3YWl0IHRoaXMuZnVuY3Rpb25zTG9nU3RyZWFtZXIuc3RhcnRTdHJlYW1pbmdMb2dzKFxuICAgICAgICBhd2FpdCB0aGlzLmJhY2tlbmRJZFNhbmRib3hSZXNvbHZlcihvcHRpb25zLmlkZW50aWZpZXIpLFxuICAgICAgICBvcHRpb25zLmZ1bmN0aW9uU3RyZWFtaW5nT3B0aW9uc1xuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGlmICh3YXRjaEZvckNoYW5nZXMpIHtcbiAgICAgIHRoaXMud2F0Y2hlclN1YnNjcmlwdGlvbiA9IGF3YWl0IHBhcmNlbFdhdGNoZXIuc3Vic2NyaWJlKFxuICAgICAgICB3YXRjaERpcixcbiAgICAgICAgYXN5bmMgKF8sIGV2ZW50cykgPT4ge1xuICAgICAgICAgIC8vIExvZyBhbmQgdHJhY2sgZmlsZSBjaGFuZ2VzLlxuICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgICAgZXZlbnRzLm1hcCgoeyB0eXBlOiBldmVudE5hbWUsIHBhdGggfSkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLmZpbGVzQ2hhbmdlc1RyYWNrZXIudHJhY2tGaWxlQ2hhbmdlKHBhdGgpO1xuICAgICAgICAgICAgICB0aGlzLnByaW50ZXIubG9nKFxuICAgICAgICAgICAgICAgIGBbU2FuZGJveF0gVHJpZ2dlcmVkIGR1ZSB0byBhIGZpbGUgJHtldmVudE5hbWV9IGV2ZW50OiAke3BhdGh9YFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChsYXRjaCA9PT0gJ29wZW4nKSB7XG4gICAgICAgICAgICBhd2FpdCBkZXBsb3lBbmRXYXRjaCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0aGlzIG1lYW5zIGxhdGNoIGlzIGVpdGhlciAnZGVwbG95aW5nJyBvciAncXVldWVkJ1xuICAgICAgICAgICAgbGF0Y2ggPSAncXVldWVkJztcbiAgICAgICAgICAgIHRoaXMucHJpbnRlci5sb2coXG4gICAgICAgICAgICAgICdbU2FuZGJveF0gUHJldmlvdXMgZGVwbG95bWVudCBpcyBzdGlsbCBpbiBwcm9ncmVzcy4gJyArXG4gICAgICAgICAgICAgICAgJ1dpbGwgcXVldWUgZm9yIGFub3RoZXIgZGVwbG95bWVudCBhZnRlciB0aGlzIG9uZSBmaW5pc2hlcydcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgaWdub3JlOiB0aGlzLm91dHB1dEZpbGVzRXhjbHVkZWRGcm9tV2F0Y2guY29uY2F0KFxuICAgICAgICAgICAgLi4uKG9wdGlvbnMuZXhjbHVkZSA/PyBbXSlcbiAgICAgICAgICApLFxuICAgICAgICB9XG4gICAgICApO1xuICAgICAgLy8gU3RhcnQgdGhlIGZpcnN0IGZ1bGwgZGVwbG95bWVudCB3aXRob3V0IHdhaXRpbmcgZm9yIGEgZmlsZSBjaGFuZ2VcbiAgICAgIGF3YWl0IGRlcGxveUFuZFdhdGNoKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF3YWl0IHRoaXMuZGVwbG95KG9wdGlvbnMpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXRkb2NcbiAgICovXG4gIHN0b3AgPSBhc3luYyAoKSA9PiB7XG4gICAgdGhpcy5wcmludGVyLmxvZyhgW1NhbmRib3hdIFNodXR0aW5nIGRvd25gLCBMb2dMZXZlbC5ERUJVRyk7XG4gICAgdGhpcy5mdW5jdGlvbnNMb2dTdHJlYW1lcj8uc3RvcFN0cmVhbWluZ0xvZ3MoKTtcbiAgICAvLyBjYW4gYmUgdW5kZWZpbmVkIGlmIGNvbW1hbmQgZXhpdHMgYmVmb3JlIHN1YnNjcmlwdGlvblxuICAgIGF3YWl0IHRoaXMud2F0Y2hlclN1YnNjcmlwdGlvbj8udW5zdWJzY3JpYmUoKTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXRkb2NcbiAgICovXG4gIGRlbGV0ZSA9IGFzeW5jIChvcHRpb25zOiBTYW5kYm94RGVsZXRlT3B0aW9ucykgPT4ge1xuICAgIHRoaXMucHJpbnRlci5sb2coXG4gICAgICAnW1NhbmRib3hdIERlbGV0aW5nIGFsbCB0aGUgcmVzb3VyY2VzIGluIHRoZSBzYW5kYm94IGVudmlyb25tZW50Li4uJ1xuICAgICk7XG4gICAgYXdhaXQgdGhpcy5leGVjdXRvci5kZXN0cm95KFxuICAgICAgYXdhaXQgdGhpcy5iYWNrZW5kSWRTYW5kYm94UmVzb2x2ZXIob3B0aW9ucy5pZGVudGlmaWVyKSxcbiAgICAgIG9wdGlvbnMucHJvZmlsZVxuICAgICk7XG4gICAgdGhpcy5lbWl0KCdzdWNjZXNzZnVsRGVsZXRpb24nKTtcbiAgICB0aGlzLnByaW50ZXIubG9nKCdbU2FuZGJveF0gRmluaXNoZWQgZGVsZXRpbmcuJyk7XG4gIH07XG5cbiAgcHJpdmF0ZSBzaG91bGRWYWxpZGF0ZUFwcFNvdXJjZXMgPSAoKTogYm9vbGVhbiA9PiB7XG4gICAgY29uc3Qgc25hcHNob3QgPSB0aGlzLmZpbGVzQ2hhbmdlc1RyYWNrZXIuZ2V0QW5kUmVzZXRTbmFwc2hvdCgpO1xuICAgIC8vIGlmIHplcm8gZmlsZXMgY2hhbmdlZCB0aGlzIGluZGljYXRlcyBpbml0aWFsIGRlcGxveW1lbnRcbiAgICBjb25zdCBzaG91bGRWYWxpZGF0ZU9uQ29sZFN0YXJ0ID1cbiAgICAgIHNuYXBzaG90LmhhZFR5cGVTY3JpcHRGaWxlc0F0U3RhcnQgJiZcbiAgICAgICFzbmFwc2hvdC5kaWRBbnlGaWxlQ2hhbmdlU2luY2VTdGFydDtcbiAgICByZXR1cm4gKFxuICAgICAgc2hvdWxkVmFsaWRhdGVPbkNvbGRTdGFydCB8fFxuICAgICAgc25hcHNob3QuZGlkQW55VHlwZVNjcmlwdEZpbGVDaGFuZ2VTaW5jZUxhc3RTbmFwc2hvdFxuICAgICk7XG4gIH07XG5cbiAgcHJpdmF0ZSBkZXBsb3kgPSBhc3luYyAob3B0aW9uczogU2FuZGJveE9wdGlvbnMpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGVwbG95UmVzdWx0ID0gYXdhaXQgdGhpcy5leGVjdXRvci5kZXBsb3koXG4gICAgICAgIGF3YWl0IHRoaXMuYmFja2VuZElkU2FuZGJveFJlc29sdmVyKG9wdGlvbnMuaWRlbnRpZmllciksXG4gICAgICAgIC8vIEl0J3MgaW1wb3J0YW50IHRvIHBhc3MgdGhpcyBhcyBjYWxsYmFjayBzbyB0aGF0IGRlYm91bmNlIGRvZXNcbiAgICAgICAgLy8gbm90IHJlc2V0IHRyYWNrZXIgcHJlbWF0dXJlbHlcbiAgICAgICAgdGhpcy5zaG91bGRWYWxpZGF0ZUFwcFNvdXJjZXMsXG4gICAgICAgIG9wdGlvbnMucHJvZmlsZVxuICAgICAgKTtcbiAgICAgIHRoaXMucHJpbnRlci5sb2coJ1tTYW5kYm94XSBEZXBsb3ltZW50IHN1Y2Nlc3NmdWwnLCBMb2dMZXZlbC5ERUJVRyk7XG4gICAgICB0aGlzLmVtaXQoJ3N1Y2Nlc3NmdWxEZXBsb3ltZW50JywgZGVwbG95UmVzdWx0KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gUHJpbnQgYSBtZWFuaW5nZnVsIG1lc3NhZ2VcbiAgICAgIHRoaXMucHJpbnRlci5wcmludChmb3JtYXQuZXJyb3IodGhpcy5nZXRFcnJvck1lc3NhZ2UoZXJyb3IpKSk7XG4gICAgICB0aGlzLmVtaXQoJ2ZhaWxlZERlcGxveW1lbnQnLCBlcnJvcik7XG5cbiAgICAgIC8vIElmIHRoZSBlcnJvciBpcyBiZWNhdXNlIG9mIGEgbm9uLWFsbG93ZWQgZGVzdHJ1Y3RpdmUgY2hhbmdlIHN1Y2ggYXNcbiAgICAgIC8vIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9BV1NDbG91ZEZvcm1hdGlvbi9sYXRlc3QvVXNlckd1aWRlL2F3cy1yZXNvdXJjZS1jb2duaXRvLXVzZXJwb29sLmh0bWwjY2ZuLWNvZ25pdG8tdXNlcnBvb2wtYWxpYXNhdHRyaWJ1dGVzXG4gICAgICAvLyBvZmZlciB0byByZWNyZWF0ZSB0aGUgc2FuZGJveCBvciByZXZlcnQgdGhlIGNoYW5nZVxuICAgICAgaWYgKFxuICAgICAgICBBbXBsaWZ5RXJyb3IuaXNBbXBsaWZ5RXJyb3IoZXJyb3IpICYmXG4gICAgICAgIGVycm9yLm5hbWUgPT09ICdDRk5VcGRhdGVOb3RTdXBwb3J0ZWRFcnJvcidcbiAgICAgICkge1xuICAgICAgICBhd2FpdCB0aGlzLmhhbmRsZVVuc3VwcG9ydGVkRGVzdHJ1Y3RpdmVDaGFuZ2VzKG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgLy8gZWxzZSBkbyBub3QgcHJvcGFnYXRlIGFuZCBsZXQgdGhlIHNhbmRib3ggY29udGludWUgdG8gcnVuXG4gICAgfVxuICB9O1xuXG4gIHByaXZhdGUgcmVzZXQgPSBhc3luYyAob3B0aW9uczogU2FuZGJveE9wdGlvbnMpID0+IHtcbiAgICBhd2FpdCB0aGlzLmRlbGV0ZSh7IGlkZW50aWZpZXI6IG9wdGlvbnMuaWRlbnRpZmllciB9KTtcbiAgICBhd2FpdCB0aGlzLnN0YXJ0KG9wdGlvbnMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBKdXN0IGEgc2hvcnRoYW5kIGNvbnNvbGUgbG9nIHRvIGluZGljYXRlIHdoZW5ldmVyIHdhdGNoZXIgaXMgZ29pbmcgaWRsZVxuICAgKi9cbiAgcHJpdmF0ZSBlbWl0V2F0Y2hpbmcgPSAoKSA9PiB7XG4gICAgdGhpcy5wcmludGVyLmxvZyhgW1NhbmRib3hdIFdhdGNoaW5nIGZvciBmaWxlIGNoYW5nZXMuLi5gKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVhZHMgYW5kIHBhcnNlcyAuZ2l0aWdub3JlIGZpbGUgYW5kIHJldHVybnMgdGhlIGxpc3Qgb2YgcGF0aHNcbiAgICovXG4gIHByaXZhdGUgZ2V0R2l0SWdub3JlZFBhdGhzID0gKCkgPT4ge1xuICAgIGNvbnN0IGdpdElnbm9yZUZpbGVQYXRoID0gcGF0aC5qb2luKHByb2Nlc3MuY3dkKCksICcuZ2l0aWdub3JlJyk7XG4gICAgaWYgKGZzLmV4aXN0c1N5bmMoZ2l0SWdub3JlRmlsZVBhdGgpKSB7XG4gICAgICByZXR1cm4gcGFyc2VHaXRJZ25vcmVcbiAgICAgICAgLnBhcnNlKGdpdElnbm9yZUZpbGVQYXRoKVxuICAgICAgICAucGF0dGVybnMubWFwKChwYXR0ZXJuOiBzdHJpbmcpID0+XG4gICAgICAgICAgcGF0dGVybi5zdGFydHNXaXRoKCcvJykgPyBwYXR0ZXJuLnN1YnN0cmluZygxKSA6IHBhdHRlcm5cbiAgICAgICAgKVxuICAgICAgICAuZmlsdGVyKChwYXR0ZXJuOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICBpZiAocGF0dGVybi5zdGFydHNXaXRoKCchJykpIHtcbiAgICAgICAgICAgIHRoaXMucHJpbnRlci5sb2coXG4gICAgICAgICAgICAgIGBbU2FuZGJveF0gUGF0dGVybiAke3BhdHRlcm59IGZvdW5kIGluIC5naXRpZ25vcmUuIFwiJHtwYXR0ZXJuLnN1YnN0cmluZyhcbiAgICAgICAgICAgICAgICAxXG4gICAgICAgICAgICAgICl9XCIgd2lsbCBub3QgYmUgd2F0Y2hlZCBpZiBvdGhlciBwYXR0ZXJucyBpbiAuZ2l0aWdub3JlIGFyZSBleGNsdWRpbmcgaXQuYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gW107XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBhIGdpdmVuIHJlZ2lvbiBoYXMgYmVlbiBib290c3RyYXBwZWQgd2l0aCA+PSBtaW4gdmVyc2lvbiB1c2luZyBDREsgYm9vdHN0cmFwIHZlcnNpb24gcGFyYW1ldGVyXG4gICAqIHN0b3JlZCBpbiBwYXJhbWV0ZXIgc3RvcmUuXG4gICAqIEByZXR1cm5zIEEgQm9vbGVhbiB0aGF0IHJlcHJlc2VudHMgaWYgcmVnaW9uIGhhcyBiZWVuIGJvb3RzdHJhcHBlZC5cbiAgICovXG4gIHByaXZhdGUgaXNCb290c3RyYXBwZWQgPSBhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgUGFyYW1ldGVyOiBwYXJhbWV0ZXIgfSA9IGF3YWl0IHRoaXMuc3NtQ2xpZW50LnNlbmQoXG4gICAgICAgIG5ldyBHZXRQYXJhbWV0ZXJDb21tYW5kKHtcbiAgICAgICAgICBOYW1lOiBDREtfREVGQVVMVF9CT09UU1RSQVBfVkVSU0lPTl9QQVJBTUVURVJfTkFNRSxcbiAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IGJvb3RzdHJhcFZlcnNpb24gPSBwYXJhbWV0ZXI/LlZhbHVlO1xuICAgICAgaWYgKFxuICAgICAgICAhYm9vdHN0cmFwVmVyc2lvbiB8fFxuICAgICAgICBOdW1iZXIoYm9vdHN0cmFwVmVyc2lvbikgPCBDREtfTUlOX0JPT1RTVFJBUF9WRVJTSU9OXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUgaW5zdGFuY2VvZiBQYXJhbWV0ZXJOb3RGb3VuZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoXG4gICAgICAgIGUgaW5zdGFuY2VvZiBTU01TZXJ2aWNlRXhjZXB0aW9uICYmXG4gICAgICAgIFtcbiAgICAgICAgICAnVW5yZWNvZ25pemVkQ2xpZW50RXhjZXB0aW9uJyxcbiAgICAgICAgICAnQWNjZXNzRGVuaWVkRXhjZXB0aW9uJyxcbiAgICAgICAgICAnTm90QXV0aG9yaXplZCcsXG4gICAgICAgICAgJ0V4cGlyZWRUb2tlbkV4Y2VwdGlvbicsXG4gICAgICAgICAgJ0V4cGlyZWRUb2tlbicsXG4gICAgICAgICAgJ0ludmFsaWRTaWduYXR1cmVFeGNlcHRpb24nLFxuICAgICAgICBdLmluY2x1ZGVzKGUubmFtZSlcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgQW1wbGlmeVVzZXJFcnJvcihcbiAgICAgICAgICAnU1NNQ3JlZGVudGlhbHNFcnJvcicsXG4gICAgICAgICAge1xuICAgICAgICAgICAgbWVzc2FnZTogYCR7ZS5uYW1lfTogJHtlLm1lc3NhZ2V9YCxcbiAgICAgICAgICAgIHJlc29sdXRpb246XG4gICAgICAgICAgICAgICdNYWtlIHN1cmUgeW91ciBBV1MgY3JlZGVudGlhbHMgYXJlIHNldCB1cCBjb3JyZWN0bHkgYW5kIGhhdmUgcGVybWlzc2lvbnMgdG8gY2FsbCBTU006R2V0UGFyYW1ldGVyJyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgd2UgYXJlIHVuYWJsZSB0byByZXRyaWV2ZSBib290c3RyYXAgdmVyc2lvbiBwYXJhbWV0ZXIgZHVlIHRvIG90aGVyIHJlYXNvbnMsIHdlIGZhaWwgZmFzdC5cbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBwcmludGFibGUgZXJyb3IgbWVzc2FnZSBmcm9tIHRoZSB0aHJvd24gZXJyb3JcbiAgICovXG4gIHByaXZhdGUgZ2V0RXJyb3JNZXNzYWdlID0gKGVycm9yOiB1bmtub3duKSA9PiB7XG4gICAgbGV0IG1lc3NhZ2U7XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIG1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlO1xuXG4gICAgICAvLyBBZGQgdGhlIGRvd25zdHJlYW0gZXhjZXB0aW9uXG4gICAgICBpZiAoZXJyb3IuY2F1c2UgJiYgZXJyb3IuY2F1c2UgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5jYXVzZS5tZXNzYWdlKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBgJHttZXNzYWdlfVxcbkNhdXNlZCBCeTogJHtlcnJvci5jYXVzZS5tZXNzYWdlfVxcbmA7XG4gICAgICB9XG5cbiAgICAgIGlmIChBbXBsaWZ5RXJyb3IuaXNBbXBsaWZ5RXJyb3IoZXJyb3IpICYmIGVycm9yLnJlc29sdXRpb24pIHtcbiAgICAgICAgbWVzc2FnZSA9IGAke21lc3NhZ2V9XFxuUmVzb2x1dGlvbjogJHtlcnJvci5yZXNvbHV0aW9ufVxcbmA7XG4gICAgICB9XG4gICAgfSBlbHNlIG1lc3NhZ2UgPSBTdHJpbmcoZXJyb3IpO1xuICAgIHJldHVybiBtZXNzYWdlO1xuICB9O1xuXG4gIHByaXZhdGUgaGFuZGxlVW5zdXBwb3J0ZWREZXN0cnVjdGl2ZUNoYW5nZXMgPSBhc3luYyAoXG4gICAgb3B0aW9uczogU2FuZGJveE9wdGlvbnNcbiAgKSA9PiB7XG4gICAgdGhpcy5wcmludGVyLnByaW50KFxuICAgICAgZm9ybWF0LmVycm9yKFxuICAgICAgICAnW1NhbmRib3hdIFdlIGNhbm5vdCBkZXBsb3kgeW91ciBuZXcgY2hhbmdlcy4gWW91IGNhbiBlaXRoZXIgcmV2ZXJ0IHRoZW0gb3IgcmVjcmVhdGUgeW91ciBzYW5kYm94IHdpdGggdGhlIG5ldyBjaGFuZ2VzIChkZWxldGluZyBhbGwgdXNlciBkYXRhKSdcbiAgICAgIClcbiAgICApO1xuICAgIC8vIG9mZmVyIHRvIHJlY3JlYXRlIHRoZSBzYW5kYm94IHdpdGggbmV3IHByb3BlcnRpZXNcbiAgICBjb25zdCBhbnN3ZXIgPSBhd2FpdCBBbXBsaWZ5UHJvbXB0ZXIueWVzT3JObyh7XG4gICAgICBtZXNzYWdlOlxuICAgICAgICAnV291bGQgeW91IGxpa2UgdG8gcmVjcmVhdGUgeW91ciBzYW5kYm94IChkZWxldGluZyBhbGwgdXNlciBkYXRhKT8nLFxuICAgICAgZGVmYXVsdFZhbHVlOiBmYWxzZSxcbiAgICB9KTtcbiAgICBpZiAoYW5zd2VyKSB7XG4gICAgICBhd2FpdCB0aGlzLnN0b3AoKTtcbiAgICAgIGF3YWl0IHRoaXMucmVzZXQob3B0aW9ucyk7XG4gICAgfVxuICAgIC8vIGVsc2UgbGV0IHRoZSBzYW5kYm94IGNvbnRpbnVlIHNvIGN1c3RvbWVycyBjYW4gcmV2ZXJ0IHRoZWlyIGNoYW5nZXNcbiAgfTtcblxuICBwcml2YXRlIHByaW50U2FuZGJveE5hbWVJbmZvID0gYXN5bmMgKHNhbmRib3hJZGVudGlmaWVyPzogc3RyaW5nKSA9PiB7XG4gICAgY29uc3Qgc2FuZGJveEJhY2tlbmRJZCA9IGF3YWl0IHRoaXMuYmFja2VuZElkU2FuZGJveFJlc29sdmVyKFxuICAgICAgc2FuZGJveElkZW50aWZpZXJcbiAgICApO1xuICAgIGNvbnN0IHN0YWNrTmFtZSA9XG4gICAgICBCYWNrZW5kSWRlbnRpZmllckNvbnZlcnNpb25zLnRvU3RhY2tOYW1lKHNhbmRib3hCYWNrZW5kSWQpO1xuICAgIHRoaXMucHJpbnRlci5sb2coXG4gICAgICBmb3JtYXQuaW5kZW50KGZvcm1hdC5oaWdobGlnaHQoZm9ybWF0LmJvbGQoJ1xcbkFtcGxpZnkgU2FuZGJveFxcbicpKSlcbiAgICApO1xuICAgIHRoaXMucHJpbnRlci5sb2coXG4gICAgICBmb3JtYXQuaW5kZW50KGAke2Zvcm1hdC5ib2xkKCdJZGVudGlmaWVyOicpfSBcXHQke3NhbmRib3hCYWNrZW5kSWQubmFtZX1gKVxuICAgICk7XG4gICAgdGhpcy5wcmludGVyLmxvZyhmb3JtYXQuaW5kZW50KGAke2Zvcm1hdC5ib2xkKCdTdGFjazonKX0gXFx0JHtzdGFja05hbWV9YCkpO1xuICAgIGlmICghc2FuZGJveElkZW50aWZpZXIpIHtcbiAgICAgIHRoaXMucHJpbnRlci5sb2coXG4gICAgICAgIGAke2Zvcm1hdC5pbmRlbnQoXG4gICAgICAgICAgZm9ybWF0LmRpbSgnXFxuVG8gc3BlY2lmeSBhIGRpZmZlcmVudCBzYW5kYm94IGlkZW50aWZpZXIsIHVzZSAnKVxuICAgICAgICApfSR7Zm9ybWF0LmJvbGQoJy0taWRlbnRpZmllcicpfWBcbiAgICAgICk7XG4gICAgfVxuICB9O1xufVxuIl19