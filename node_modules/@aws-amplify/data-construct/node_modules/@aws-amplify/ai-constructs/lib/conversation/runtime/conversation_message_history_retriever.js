"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConversationMessageHistoryRetriever = void 0;
const graphql_request_executor_1 = require("./graphql_request_executor");
const user_agent_provider_1 = require("./user_agent_provider");
/**
 * These are all properties we have to pull.
 * Unfortunately, GQL doesn't support wildcards.
 * https://github.com/graphql/graphql-spec/issues/127
 */
const messageItemSelectionSet = `
                id
                conversationId
                associatedUserMessageId
                aiContext
                role
                content {
                  text
                  document {
                    source {
                      bytes
                    }
                    format
                    name
                  }
                  image {
                    format
                    source {
                      bytes
                    }
                  }
                  toolResult {
                    content {
                      document {
                        format
                        name
                        source {
                          bytes
                        }
                      }
                      image {
                        format
                        source {
                          bytes
                        }
                      }
                      json
                      text
                    }
                    status
                    toolUseId
                  }
                  toolUse {
                    input
                    name
                    toolUseId
                  }
                }
`;
/**
 * This class is responsible for retrieving message history that belongs to conversation turn event.
 * It queries AppSync to list messages that belong to conversation.
 * Additionally, it looks up a current message in case it's missing in the list due to eventual consistency.
 */
class ConversationMessageHistoryRetriever {
    /**
     * Creates conversation message history retriever.
     */
    constructor(event, graphqlRequestExecutor = new graphql_request_executor_1.GraphqlRequestExecutor(event.graphqlApiEndpoint, event.request.headers.authorization, new user_agent_provider_1.UserAgentProvider(event))) {
        this.event = event;
        this.graphqlRequestExecutor = graphqlRequestExecutor;
        this.getMessageHistory = async () => {
            const messages = await this.listMessages();
            let currentMessage = messages.find((m) => m.id === this.event.currentMessageId);
            // This is a fallback in case current message is not available in the message list.
            // I.e. in a situation when freshly written message is not yet visible in
            // eventually consistent reads.
            if (!currentMessage) {
                currentMessage = await this.getCurrentMessage();
                messages.push(currentMessage);
            }
            // Index assistant messages by corresponding user message.
            const assistantMessageByUserMessageId = new Map();
            messages.forEach((message) => {
                if (message.role === 'assistant' && message.associatedUserMessageId) {
                    assistantMessageByUserMessageId.set(message.associatedUserMessageId, message);
                }
            });
            // Reconcile history and inject aiContext
            const orderedMessages = messages.reduce((acc, current) => {
                // Bedrock expects that message history is user->assistant->user->assistant->... and so on.
                // The chronological order doesn't assure this ordering if there were any concurrent messages sent.
                // Therefore, conversation is ordered by user's messages only and corresponding assistant messages are inserted
                // into right place regardless of their createdAt value.
                // This algorithm assumes that GQL query returns messages sorted by createdAt.
                if (current.role === 'assistant') {
                    // Initially, skip assistant messages, these might be out of chronological order.
                    return acc;
                }
                if (current.role === 'user' &&
                    !assistantMessageByUserMessageId.has(current.id) &&
                    current.id !== this.event.currentMessageId) {
                    // Skip user messages that didn't get answer from assistant yet.
                    // These might be still "in-flight", i.e. assistant is still working on them in separate invocation.
                    // Except current message, we want to process that one.
                    return acc;
                }
                const aiContext = current.aiContext;
                const content = aiContext
                    ? [...current.content, { text: JSON.stringify(aiContext) }]
                    : current.content;
                acc.push({ role: current.role, content });
                // Find and insert corresponding assistant message.
                const correspondingAssistantMessage = assistantMessageByUserMessageId.get(current.id);
                if (correspondingAssistantMessage) {
                    acc.push({
                        role: correspondingAssistantMessage.role,
                        content: correspondingAssistantMessage.content,
                    });
                }
                return acc;
            }, []);
            // Remove tool usage from non-current turn and squash messages.
            return this.squashNonCurrentTurns(orderedMessages);
        };
        /**
         * This function removes tool usage from non-current turns.
         * The tool usage and result blocks don't matter after a turn is completed,
         * but do cost extra tokens to process.
         * The algorithm is as follows:
         * 1. Find where current turn begins. I.e. last user message that isn't tool block.
         * 2. Remove toolUse and toolResult blocks before current turn.
         * 3. Squash continuous sequences of messages that belong to same 'message.role'.
         */
        this.squashNonCurrentTurns = (messages) => {
            const isNonToolBlockPredicate = (contentBlock) => !contentBlock.toolUse && !contentBlock.toolResult;
            // find where current turn begins. I.e. last user message that is not related to tools
            const lastNonToolUseUserMessageIndex = messages.findLastIndex((message) => {
                return (message.role === 'user' && message.content.find(isNonToolBlockPredicate));
            });
            // No non-current turns, don't transform.
            if (lastNonToolUseUserMessageIndex <= 0) {
                return messages;
            }
            const squashedMessages = [];
            // Define a "buffer". I.e. a message we keep around and squash content on.
            let currentSquashedMessage = undefined;
            // Process messages before current turn begins
            // Remove tool usage blocks.
            // Combine content for consecutive message that have same role.
            for (let i = 0; i < lastNonToolUseUserMessageIndex; i++) {
                const currentMessage = messages[i];
                const currentMessageRole = currentMessage.role;
                const currentMessageNonToolContent = currentMessage.content.filter(isNonToolBlockPredicate);
                if (currentMessageNonToolContent.length === 0) {
                    // Tool only message. Nothing to squash, skip;
                    continue;
                }
                if (!currentSquashedMessage) {
                    // Nothing squashed yet, initialize the buffer.
                    currentSquashedMessage = {
                        role: currentMessageRole,
                        content: currentMessageNonToolContent,
                    };
                }
                else if (currentSquashedMessage.role === currentMessageRole) {
                    // if role is same append content.
                    currentSquashedMessage.content.push(...currentMessageNonToolContent);
                }
                else {
                    // if role flips push current squashed message and re-initialize the buffer.
                    squashedMessages.push(currentSquashedMessage);
                    currentSquashedMessage = {
                        role: currentMessageRole,
                        content: currentMessageNonToolContent,
                    };
                }
            }
            // flush the last buffer.
            if (currentSquashedMessage) {
                squashedMessages.push(currentSquashedMessage);
            }
            // Append current turn as is.
            squashedMessages.push(...messages.slice(lastNonToolUseUserMessageIndex));
            return squashedMessages;
        };
        this.getCurrentMessage = async () => {
            const query = `
        query GetMessage($id: ${this.event.messageHistoryQuery.getQueryInputTypeName}!) {
            ${this.event.messageHistoryQuery.getQueryName}(id: $id) {
              ${messageItemSelectionSet}
            }
        }
    `;
            const variables = {
                id: this.event.currentMessageId,
            };
            const response = await this.graphqlRequestExecutor.executeGraphql({
                query,
                variables,
            });
            return response.data[this.event.messageHistoryQuery.getQueryName];
        };
        this.listMessages = async () => {
            var _a;
            const query = `
        query ListMessages($filter: ${this.event.messageHistoryQuery.listQueryInputTypeName}!, $limit: Int) {
            ${this.event.messageHistoryQuery.listQueryName}(filter: $filter, limit: $limit) {
              items {
                ${messageItemSelectionSet}
              }
            }
        }
    `;
            const variables = {
                filter: {
                    conversationId: {
                        eq: this.event.conversationId,
                    },
                },
                limit: (_a = this.event.messageHistoryQuery.listQueryLimit) !== null && _a !== void 0 ? _a : 1000,
            };
            const response = await this.graphqlRequestExecutor.executeGraphql({
                query,
                variables,
            });
            const items = response.data[this.event.messageHistoryQuery.listQueryName].items;
            items.forEach((item) => {
                var _a;
                (_a = item.content) === null || _a === void 0 ? void 0 : _a.forEach((contentBlock) => {
                    var _a, _b;
                    let property;
                    for (property in contentBlock) {
                        // Deserialization of GraphQl query result sets these properties to 'null'
                        // This can trigger Bedrock SDK validation as it expects 'undefined' if properties are not set.
                        // We can't fix how GraphQl response is deserialized.
                        // Therefore, we apply this transformation to fix the data.
                        if (contentBlock[property] === null) {
                            contentBlock[property] = undefined;
                        }
                    }
                    if (typeof ((_a = contentBlock.toolUse) === null || _a === void 0 ? void 0 : _a.input) === 'string') {
                        // toolUse.input may come as serialized JSON for Client Tools.
                        // Parse it in that case.
                        contentBlock.toolUse.input = JSON.parse(contentBlock.toolUse.input);
                    }
                    if ((_b = contentBlock.toolResult) === null || _b === void 0 ? void 0 : _b.content) {
                        contentBlock.toolResult.content.forEach((toolResultContentBlock) => {
                            if (typeof toolResultContentBlock.json === 'string') {
                                // toolResult.content[].json may come as serialized JSON for Client Tools.
                                // Parse it in that case.
                                toolResultContentBlock.json = JSON.parse(toolResultContentBlock.json);
                            }
                        });
                    }
                });
            });
            return items;
        };
    }
}
exports.ConversationMessageHistoryRetriever = ConversationMessageHistoryRetriever;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udmVyc2F0aW9uX21lc3NhZ2VfaGlzdG9yeV9yZXRyaWV2ZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvY29udmVyc2F0aW9uL3J1bnRpbWUvY29udmVyc2F0aW9uX21lc3NhZ2VfaGlzdG9yeV9yZXRyaWV2ZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBS0EseUVBQW9FO0FBQ3BFLCtEQUEwRDtBQW1DMUQ7Ozs7R0FJRztBQUNILE1BQU0sdUJBQXVCLEdBQUc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWdEL0IsQ0FBQztBQUVGOzs7O0dBSUc7QUFDSCxNQUFhLG1DQUFtQztJQUM5Qzs7T0FFRztJQUNILFlBQ21CLEtBQTRCLEVBQzVCLHlCQUF5QixJQUFJLGlEQUFzQixDQUNsRSxLQUFLLENBQUMsa0JBQWtCLEVBQ3hCLEtBQUssQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLGFBQWEsRUFDbkMsSUFBSSx1Q0FBaUIsQ0FBQyxLQUFLLENBQUMsQ0FDN0I7UUFMZ0IsVUFBSyxHQUFMLEtBQUssQ0FBdUI7UUFDNUIsMkJBQXNCLEdBQXRCLHNCQUFzQixDQUl0QztRQUdILHNCQUFpQixHQUFHLEtBQUssSUFBeUMsRUFBRTtZQUNsRSxNQUFNLFFBQVEsR0FBRyxNQUFNLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQztZQUUzQyxJQUFJLGNBQWMsR0FBRyxRQUFRLENBQUMsSUFBSSxDQUNoQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsS0FBSyxJQUFJLENBQUMsS0FBSyxDQUFDLGdCQUFnQixDQUM1QyxDQUFDO1lBRUYsbUZBQW1GO1lBQ25GLHlFQUF5RTtZQUN6RSwrQkFBK0I7WUFDL0IsSUFBSSxDQUFDLGNBQWMsRUFBRTtnQkFDbkIsY0FBYyxHQUFHLE1BQU0sSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7Z0JBQ2hELFFBQVEsQ0FB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LElBQUksT0FBTyxzQkFBc0IsQ0FBQyxJQUFJLEtBQUssUUFBUSxFQUFFO2dDQUNuRCwwRUFBMEU7Z0NBQzFFLHlCQUF5QjtnQ0FDekIsc0JBQXNCLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQ3RDLHNCQUFzQixDQUFDLElBQUksQ0FDNUIsQ0FBQzs2QkFDSDt3QkFDSCxDQUFDLENBQUMsQ0FBQztxQkFDSjtnQkFDSCxDQUFDLENBQUMsQ0FBQztZQUNMLENBQUMsQ0FBQyxDQUFDO1lBRUgsT0FBTyxLQUFLLENBQUM7UUFDZixDQUFDLENBQUM7SUE3T0MsQ0FBQztDQThPTDtBQXpQRCxrRkF5UEMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBDb252ZXJzYXRpb25NZXNzYWdlLFxuICBDb252ZXJzYXRpb25NZXNzYWdlQ29udGVudEJsb2NrLFxuICBDb252ZXJzYXRpb25UdXJuRXZlbnQsXG59IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgR3JhcGhxbFJlcXVlc3RFeGVjdXRvciB9IGZyb20gJy4vZ3JhcGhxbF9yZXF1ZXN0X2V4ZWN1dG9yJztcbmltcG9ydCB7IFVzZXJBZ2VudFByb3ZpZGVyIH0gZnJvbSAnLi91c2VyX2FnZW50X3Byb3ZpZGVyJztcblxuZXhwb3J0IHR5cGUgQ29udmVyc2F0aW9uSGlzdG9yeU1lc3NhZ2VJdGVtID0gQ29udmVyc2F0aW9uTWVzc2FnZSAmIHtcbiAgaWQ6IHN0cmluZztcbiAgY29udmVyc2F0aW9uSWQ6IHN0cmluZztcbiAgYXNzb2NpYXRlZFVzZXJNZXNzYWdlSWQ/OiBzdHJpbmc7XG4gIGFpQ29udGV4dD86IHVua25vd247XG59O1xuXG5leHBvcnQgdHlwZSBHZXRRdWVyeUlucHV0ID0ge1xuICBpZDogc3RyaW5nO1xufTtcblxuZXhwb3J0IHR5cGUgR2V0UXVlcnlPdXRwdXQgPSB7XG4gIGRhdGE6IFJlY29yZDxzdHJpbmcsIENvbnZlcnNhdGlvbkhpc3RvcnlNZXNzYWdlSXRlbT47XG59O1xuXG5leHBvcnQgdHlwZSBMaXN0UXVlcnlJbnB1dCA9IHtcbiAgZmlsdGVyOiB7XG4gICAgY29udmVyc2F0aW9uSWQ6IHtcbiAgICAgIGVxOiBzdHJpbmc7XG4gICAgfTtcbiAgfTtcbiAgbGltaXQ6IG51bWJlcjtcbn07XG5cbmV4cG9ydCB0eXBlIExpc3RRdWVyeU91dHB1dCA9IHtcbiAgZGF0YTogUmVjb3JkPFxuICAgIHN0cmluZyxcbiAgICB7XG4gICAgICBpdGVtczogQXJyYXk8Q29udmVyc2F0aW9uSGlzdG9yeU1lc3NhZ2VJdGVtPjtcbiAgICB9XG4gID47XG59O1xuXG4vKipcbiAqIFRoZXNlIGFyZSBhbGwgcHJvcGVydGllcyB3ZSBoYXZlIHRvIHB1bGwuXG4gKiBVbmZvcnR1bmF0ZWx5LCBHUUwgZG9lc24ndCBzdXBwb3J0IHdpbGRjYXJkcy5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ncmFwaHFsL2dyYXBocWwtc3BlYy9pc3N1ZXMvMTI3XG4gKi9cbmNvbnN0IG1lc3NhZ2VJdGVtU2VsZWN0aW9uU2V0ID0gYFxuICAgICAgICAgICAgICAgIGlkXG4gICAgICAgICAgICAgICAgY29udmVyc2F0aW9uSWRcbiAgICAgICAgICAgICAgICBhc3NvY2lhdGVkVXNlck1lc3NhZ2VJZFxuICAgICAgICAgICAgICAgIGFpQ29udGV4dFxuICAgICAgICAgICAgICAgIHJvbGVcbiAgICAgICAgICAgICAgICBjb250ZW50IHtcbiAgICAgICAgICAgICAgICAgIHRleHRcbiAgICAgICAgICAgICAgICAgIGRvY3VtZW50IHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBieXRlc1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdFxuICAgICAgICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpbWFnZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHRvb2xSZXN1bHQge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50IHtcbiAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXRcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGltYWdlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdFxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAganNvblxuICAgICAgICAgICAgICAgICAgICAgIHRleHRcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdGF0dXNcbiAgICAgICAgICAgICAgICAgICAgdG9vbFVzZUlkXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB0b29sVXNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRcbiAgICAgICAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgICAgICAgICB0b29sVXNlSWRcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5gO1xuXG4vKipcbiAqIFRoaXMgY2xhc3MgaXMgcmVzcG9uc2libGUgZm9yIHJldHJpZXZpbmcgbWVzc2FnZSBoaXN0b3J5IHRoYXQgYmVsb25ncyB0byBjb252ZXJzYXRpb24gdHVybiBldmVudC5cbiAqIEl0IHF1ZXJpZXMgQXBwU3luYyB0byBsaXN0IG1lc3NhZ2VzIHRoYXQgYmVsb25nIHRvIGNvbnZlcnNhdGlvbi5cbiAqIEFkZGl0aW9uYWxseSwgaXQgbG9va3MgdXAgYSBjdXJyZW50IG1lc3NhZ2UgaW4gY2FzZSBpdCdzIG1pc3NpbmcgaW4gdGhlIGxpc3QgZHVlIHRvIGV2ZW50dWFsIGNvbnNpc3RlbmN5LlxuICovXG5leHBvcnQgY2xhc3MgQ29udmVyc2F0aW9uTWVzc2FnZUhpc3RvcnlSZXRyaWV2ZXIge1xuICAvKipcbiAgICogQ3JlYXRlcyBjb252ZXJzYXRpb24gbWVzc2FnZSBoaXN0b3J5IHJldHJpZXZlci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgZXZlbnQ6IENvbnZlcnNhdGlvblR1cm5FdmVudCxcbiAgICBwcml2YXRlIHJlYWRvbmx5IGdyYXBocWxSZXF1ZXN0RXhlY3V0b3IgPSBuZXcgR3JhcGhxbFJlcXVlc3RFeGVjdXRvcihcbiAgICAgIGV2ZW50LmdyYXBocWxBcGlFbmRwb2ludCxcbiAgICAgIGV2ZW50LnJlcXVlc3QuaGVhZGVycy5hdXRob3JpemF0aW9uLFxuICAgICAgbmV3IFVzZXJBZ2VudFByb3ZpZGVyKGV2ZW50KVxuICAgIClcbiAgKSB7fVxuXG4gIGdldE1lc3NhZ2VIaXN0b3J5ID0gYXN5bmMgKCk6IFByb21pc2U8QXJyYXk8Q29udmVyc2F0aW9uTWVzc2FnZT4+ID0+IHtcbiAgICBjb25zdCBtZXNzYWdlcyA9IGF3YWl0IHRoaXMubGlzdE1lc3NhZ2VzKCk7XG5cbiAgICBsZXQgY3VycmVudE1lc3NhZ2UgPSBtZXNzYWdlcy5maW5kKFxuICAgICAgKG0pID0+IG0uaWQgPT09IHRoaXMuZXZlbnQuY3VycmVudE1lc3NhZ2VJZFxuICAgICk7XG5cbiAgICAvLyBUaGlzIGlzIGEgZmFsbGJhY2sgaW4gY2FzZSBjdXJyZW50IG1lc3NhZ2UgaXMgbm90IGF2YWlsYWJsZSBpbiB0aGUgbWVzc2FnZSBsaXN0LlxuICAgIC8vIEkuZS4gaW4gYSBzaXR1YXRpb24gd2hlbiBmcmVzaGx5IHdyaXR0ZW4gbWVzc2FnZSBpcyBub3QgeWV0IHZpc2libGUgaW5cbiAgICAvLyBldmVudHVhbGx5IGNvbnNpc3RlbnQgcmVhZHMuXG4gICAgaWYgKCFjdXJyZW50TWVzc2FnZSkge1xuICAgICAgY3VycmVudE1lc3NhZ2UgPSBhd2FpdCB0aGlzLmdldEN1cnJlbnRNZXNzYWdlKCk7XG4gICAgICBtZXNzYWdlcy5wdXNoKGN1cnJlbnRNZXNzYWdlKTtcbiAgICB9XG5cbiAgICAvLyBJbmRleCBhc3Npc3RhbnQgbWVzc2FnZXMgYnkgY29ycmVzcG9uZGluZyB1c2VyIG1lc3NhZ2UuXG4gICAgY29uc3QgYXNzaXN0YW50TWVzc2FnZUJ5VXNlck1lc3NhZ2VJZDogTWFwPFxuICAgICAgc3RyaW5nLFxuICAgICAgQ29udmVyc2F0aW9uSGlzdG9yeU1lc3NhZ2VJdGVtXG4gICAgPiA9IG5ldyBNYXAoKTtcbiAgICBtZXNzYWdlcy5mb3JFYWNoKChtZXNzYWdlKSA9PiB7XG4gICAgICBpZiAobWVzc2FnZS5yb2xlID09PSAnYXNzaXN0YW50JyAmJiBtZXNzYWdlLmFzc29jaWF0ZWRVc2VyTWVzc2FnZUlkKSB7XG4gICAgICAgIGFzc2lzdGFudE1lc3NhZ2VCeVVzZXJNZXNzYWdlSWQuc2V0KFxuICAgICAgICAgIG1lc3NhZ2UuYXNzb2NpYXRlZFVzZXJNZXNzYWdlSWQsXG4gICAgICAgICAgbWVzc2FnZVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gUmVjb25jaWxlIGhpc3RvcnkgYW5kIGluamVjdCBhaUNvbnRleHRcbiAgICBjb25zdCBvcmRlcmVkTWVzc2FnZXMgPSBtZXNzYWdlcy5yZWR1Y2UoKGFjYywgY3VycmVudCkgPT4ge1xuICAgICAgLy8gQmVkcm9jayBleHBlY3RzIHRoYXQgbWVzc2FnZSBoaXN0b3J5IGlzIHVzZXItPmFzc2lzdGFudC0+dXNlci0+YXNzaXN0YW50LT4uLi4gYW5kIHNvIG9uLlxuICAgICAgLy8gVGhlIGNocm9ub2xvZ2ljYWwgb3JkZXIgZG9lc24ndCBhc3N1cmUgdGhpcyBvcmRlcmluZyBpZiB0aGVyZSB3ZXJlIGFueSBjb25jdXJyZW50IG1lc3NhZ2VzIHNlbnQuXG4gICAgICAvLyBUaGVyZWZvcmUsIGNvbnZlcnNhdGlvbiBpcyBvcmRlcmVkIGJ5IHVzZXIncyBtZXNzYWdlcyBvbmx5IGFuZCBjb3JyZXNwb25kaW5nIGFzc2lzdGFudCBtZXNzYWdlcyBhcmUgaW5zZXJ0ZWRcbiAgICAgIC8vIGludG8gcmlnaHQgcGxhY2UgcmVnYXJkbGVzcyBvZiB0aGVpciBjcmVhdGVkQXQgdmFsdWUuXG4gICAgICAvLyBUaGlzIGFsZ29yaXRobSBhc3N1bWVzIHRoYXQgR1FMIHF1ZXJ5IHJldHVybnMgbWVzc2FnZXMgc29ydGVkIGJ5IGNyZWF0ZWRBdC5cbiAgICAgIGlmIChjdXJyZW50LnJvbGUgPT09ICdhc3Npc3RhbnQnKSB7XG4gICAgICAgIC8vIEluaXRpYWxseSwgc2tpcCBhc3Npc3RhbnQgbWVzc2FnZXMsIHRoZXNlIG1pZ2h0IGJlIG91dCBvZiBjaHJvbm9sb2dpY2FsIG9yZGVyLlxuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfVxuICAgICAgaWYgKFxuICAgICAgICBjdXJyZW50LnJvbGUgPT09ICd1c2VyJyAmJlxuICAgICAgICAhYXNzaXN0YW50TWVzc2FnZUJ5VXNlck1lc3NhZ2VJZC5oYXMoY3VycmVudC5pZCkgJiZcbiAgICAgICAgY3VycmVudC5pZCAhPT0gdGhpcy5ldmVudC5jdXJyZW50TWVzc2FnZUlkXG4gICAgICApIHtcbiAgICAgICAgLy8gU2tpcCB1c2VyIG1lc3NhZ2VzIHRoYXQgZGlkbid0IGdldCBhbnN3ZXIgZnJvbSBhc3Npc3RhbnQgeWV0LlxuICAgICAgICAvLyBUaGVzZSBtaWdodCBiZSBzdGlsbCBcImluLWZsaWdodFwiLCBpLmUuIGFzc2lzdGFudCBpcyBzdGlsbCB3b3JraW5nIG9uIHRoZW0gaW4gc2VwYXJhdGUgaW52b2NhdGlvbi5cbiAgICAgICAgLy8gRXhjZXB0IGN1cnJlbnQgbWVzc2FnZSwgd2Ugd2FudCB0byBwcm9jZXNzIHRoYXQgb25lLlxuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfVxuICAgICAgY29uc3QgYWlDb250ZXh0ID0gY3VycmVudC5haUNvbnRleHQ7XG4gICAgICBjb25zdCBjb250ZW50ID0gYWlDb250ZXh0XG4gICAgICAgID8gWy4uLmN1cnJlbnQuY29udGVudCwgeyB0ZXh0OiBKU09OLnN0cmluZ2lmeShhaUNvbnRleHQpIH1dXG4gICAgICAgIDogY3VycmVudC5jb250ZW50O1xuXG4gICAgICBhY2MucHVzaCh7IHJvbGU6IGN1cnJlbnQucm9sZSwgY29udGVudCB9KTtcblxuICAgICAgLy8gRmluZCBhbmQgaW5zZXJ0IGNvcnJlc3BvbmRpbmcgYXNzaXN0YW50IG1lc3NhZ2UuXG4gICAgICBjb25zdCBjb3JyZXNwb25kaW5nQXNzaXN0YW50TWVzc2FnZSA9IGFzc2lzdGFudE1lc3NhZ2VCeVVzZXJNZXNzYWdlSWQuZ2V0KFxuICAgICAgICBjdXJyZW50LmlkXG4gICAgICApO1xuICAgICAgaWYgKGNvcnJlc3BvbmRpbmdBc3Npc3RhbnRNZXNzYWdlKSB7XG4gICAgICAgIGFjYy5wdXNoKHtcbiAgICAgICAgICByb2xlOiBjb3JyZXNwb25kaW5nQXNzaXN0YW50TWVzc2FnZS5yb2xlLFxuICAgICAgICAgIGNvbnRlbnQ6IGNvcnJlc3BvbmRpbmdBc3Npc3RhbnRNZXNzYWdlLmNvbnRlbnQsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBbXSBhcyBBcnJheTxDb252ZXJzYXRpb25NZXNzYWdlPik7XG5cbiAgICAvLyBSZW1vdmUgdG9vbCB1c2FnZSBmcm9tIG5vbi1jdXJyZW50IHR1cm4gYW5kIHNxdWFzaCBtZXNzYWdlcy5cbiAgICByZXR1cm4gdGhpcy5zcXVhc2hOb25DdXJyZW50VHVybnMob3JkZXJlZE1lc3NhZ2VzKTtcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiByZW1vdmVzIHRvb2wgdXNhZ2UgZnJvbSBub24tY3VycmVudCB0dXJucy5cbiAgICogVGhlIHRvb2wgdXNhZ2UgYW5kIHJlc3VsdCBibG9ja3MgZG9uJ3QgbWF0dGVyIGFmdGVyIGEgdHVybiBpcyBjb21wbGV0ZWQsXG4gICAqIGJ1dCBkbyBjb3N0IGV4dHJhIHRva2VucyB0byBwcm9jZXNzLlxuICAgKiBUaGUgYWxnb3JpdGhtIGlzIGFzIGZvbGxvd3M6XG4gICAqIDEuIEZpbmQgd2hlcmUgY3VycmVudCB0dXJuIGJlZ2lucy4gSS5lLiBsYXN0IHVzZXIgbWVzc2FnZSB0aGF0IGlzbid0IHRvb2wgYmxvY2suXG4gICAqIDIuIFJlbW92ZSB0b29sVXNlIGFuZCB0b29sUmVzdWx0IGJsb2NrcyBiZWZvcmUgY3VycmVudCB0dXJuLlxuICAgKiAzLiBTcXVhc2ggY29udGludW91cyBzZXF1ZW5jZXMgb2YgbWVzc2FnZXMgdGhhdCBiZWxvbmcgdG8gc2FtZSAnbWVzc2FnZS5yb2xlJy5cbiAgICovXG4gIHByaXZhdGUgc3F1YXNoTm9uQ3VycmVudFR1cm5zID0gKG1lc3NhZ2VzOiBBcnJheTxDb252ZXJzYXRpb25NZXNzYWdlPikgPT4ge1xuICAgIGNvbnN0IGlzTm9uVG9vbEJsb2NrUHJlZGljYXRlID0gKFxuICAgICAgY29udGVudEJsb2NrOiBDb252ZXJzYXRpb25NZXNzYWdlQ29udGVudEJsb2NrXG4gICAgKSA9PiAhY29udGVudEJsb2NrLnRvb2xVc2UgJiYgIWNvbnRlbnRCbG9jay50b29sUmVzdWx0O1xuXG4gICAgLy8gZmluZCB3aGVyZSBjdXJyZW50IHR1cm4gYmVnaW5zLiBJLmUuIGxhc3QgdXNlciBtZXNzYWdlIHRoYXQgaXMgbm90IHJlbGF0ZWQgdG8gdG9vbHNcbiAgICBjb25zdCBsYXN0Tm9uVG9vbFVzZVVzZXJNZXNzYWdlSW5kZXggPSBtZXNzYWdlcy5maW5kTGFzdEluZGV4KChtZXNzYWdlKSA9PiB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBtZXNzYWdlLnJvbGUgPT09ICd1c2VyJyAmJiBtZXNzYWdlLmNvbnRlbnQuZmluZChpc05vblRvb2xCbG9ja1ByZWRpY2F0ZSlcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICAvLyBObyBub24tY3VycmVudCB0dXJucywgZG9uJ3QgdHJhbnNmb3JtLlxuICAgIGlmIChsYXN0Tm9uVG9vbFVzZVVzZXJNZXNzYWdlSW5kZXggPD0gMCkge1xuICAgICAgcmV0dXJuIG1lc3NhZ2VzO1xuICAgIH1cblxuICAgIGNvbnN0IHNxdWFzaGVkTWVzc2FnZXM6IEFycmF5PENvbnZlcnNhdGlvbk1lc3NhZ2U+ID0gW107XG5cbiAgICAvLyBEZWZpbmUgYSBcImJ1ZmZlclwiLiBJLmUuIGEgbWVzc2FnZSB3ZSBrZWVwIGFyb3VuZCBhbmQgc3F1YXNoIGNvbnRlbnQgb24uXG4gICAgbGV0IGN1cnJlbnRTcXVhc2hlZE1lc3NhZ2U6IENvbnZlcnNhdGlvbk1lc3NhZ2UgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgLy8gUHJvY2VzcyBtZXNzYWdlcyBiZWZvcmUgY3VycmVudCB0dXJuIGJlZ2luc1xuICAgIC8vIFJlbW92ZSB0b29sIHVzYWdlIGJsb2Nrcy5cbiAgICAvLyBDb21iaW5lIGNvbnRlbnQgZm9yIGNvbnNlY3V0aXZlIG1lc3NhZ2UgdGhhdCBoYXZlIHNhbWUgcm9sZS5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxhc3ROb25Ub29sVXNlVXNlck1lc3NhZ2VJbmRleDsgaSsrKSB7XG4gICAgICBjb25zdCBjdXJyZW50TWVzc2FnZSA9IG1lc3NhZ2VzW2ldO1xuICAgICAgY29uc3QgY3VycmVudE1lc3NhZ2VSb2xlID0gY3VycmVudE1lc3NhZ2Uucm9sZTtcbiAgICAgIGNvbnN0IGN1cnJlbnRNZXNzYWdlTm9uVG9vbENvbnRlbnQgPSBjdXJyZW50TWVzc2FnZS5jb250ZW50LmZpbHRlcihcbiAgICAgICAgaXNOb25Ub29sQmxvY2tQcmVkaWNhdGVcbiAgICAgICk7XG4gICAgICBpZiAoY3VycmVudE1lc3NhZ2VOb25Ub29sQ29udGVudC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgLy8gVG9vbCBvbmx5IG1lc3NhZ2UuIE5vdGhpbmcgdG8gc3F1YXNoLCBza2lwO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFjdXJyZW50U3F1YXNoZWRNZXNzYWdlKSB7XG4gICAgICAgIC8vIE5vdGhpbmcgc3F1YXNoZWQgeWV0LCBpbml0aWFsaXplIHRoZSBidWZmZXIuXG4gICAgICAgIGN1cnJlbnRTcXVhc2hlZE1lc3NhZ2UgPSB7XG4gICAgICAgICAgcm9sZTogY3VycmVudE1lc3NhZ2VSb2xlLFxuICAgICAgICAgIGNvbnRlbnQ6IGN1cnJlbnRNZXNzYWdlTm9uVG9vbENvbnRlbnQsXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKGN1cnJlbnRTcXVhc2hlZE1lc3NhZ2Uucm9sZSA9PT0gY3VycmVudE1lc3NhZ2VSb2xlKSB7XG4gICAgICAgIC8vIGlmIHJvbGUgaXMgc2FtZSBhcHBlbmQgY29udGVudC5cbiAgICAgICAgY3VycmVudFNxdWFzaGVkTWVzc2FnZS5jb250ZW50LnB1c2goLi4uY3VycmVudE1lc3NhZ2VOb25Ub29sQ29udGVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZiByb2xlIGZsaXBzIHB1c2ggY3VycmVudCBzcXVhc2hlZCBtZXNzYWdlIGFuZCByZS1pbml0aWFsaXplIHRoZSBidWZmZXIuXG4gICAgICAgIHNxdWFzaGVkTWVzc2FnZXMucHVzaChjdXJyZW50U3F1YXNoZWRNZXNzYWdlKTtcbiAgICAgICAgY3VycmVudFNxdWFzaGVkTWVzc2FnZSA9IHtcbiAgICAgICAgICByb2xlOiBjdXJyZW50TWVzc2FnZVJvbGUsXG4gICAgICAgICAgY29udGVudDogY3VycmVudE1lc3NhZ2VOb25Ub29sQ29udGVudCxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gZmx1c2ggdGhlIGxhc3QgYnVmZmVyLlxuICAgIGlmIChjdXJyZW50U3F1YXNoZWRNZXNzYWdlKSB7XG4gICAgICBzcXVhc2hlZE1lc3NhZ2VzLnB1c2goY3VycmVudFNxdWFzaGVkTWVzc2FnZSk7XG4gICAgfVxuXG4gICAgLy8gQXBwZW5kIGN1cnJlbnQgdHVybiBhcyBpcy5cbiAgICBzcXVhc2hlZE1lc3NhZ2VzLnB1c2goLi4ubWVzc2FnZXMuc2xpY2UobGFzdE5vblRvb2xVc2VVc2VyTWVzc2FnZUluZGV4KSk7XG4gICAgcmV0dXJuIHNxdWFzaGVkTWVzc2FnZXM7XG4gIH07XG5cbiAgcHJpdmF0ZSBnZXRDdXJyZW50TWVzc2FnZSA9XG4gICAgYXN5bmMgKCk6IFByb21pc2U8Q29udmVyc2F0aW9uSGlzdG9yeU1lc3NhZ2VJdGVtPiA9PiB7XG4gICAgICBjb25zdCBxdWVyeSA9IGBcbiAgICAgICAgcXVlcnkgR2V0TWVzc2FnZSgkaWQ6ICR7dGhpcy5ldmVudC5tZXNzYWdlSGlzdG9yeVF1ZXJ5LmdldFF1ZXJ5SW5wdXRUeXBlTmFtZX0hKSB7XG4gICAgICAgICAgICAke3RoaXMuZXZlbnQubWVzc2FnZUhpc3RvcnlRdWVyeS5nZXRRdWVyeU5hbWV9KGlkOiAkaWQpIHtcbiAgICAgICAgICAgICAgJHttZXNzYWdlSXRlbVNlbGVjdGlvblNldH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIGA7XG4gICAgICBjb25zdCB2YXJpYWJsZXM6IEdldFF1ZXJ5SW5wdXQgPSB7XG4gICAgICAgIGlkOiB0aGlzLmV2ZW50LmN1cnJlbnRNZXNzYWdlSWQsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZ3JhcGhxbFJlcXVlc3RFeGVjdXRvci5leGVjdXRlR3JhcGhxbDxcbiAgICAgICAgR2V0UXVlcnlJbnB1dCxcbiAgICAgICAgR2V0UXVlcnlPdXRwdXRcbiAgICAgID4oe1xuICAgICAgICBxdWVyeSxcbiAgICAgICAgdmFyaWFibGVzLFxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhW3RoaXMuZXZlbnQubWVzc2FnZUhpc3RvcnlRdWVyeS5nZXRRdWVyeU5hbWVdO1xuICAgIH07XG5cbiAgcHJpdmF0ZSBsaXN0TWVzc2FnZXMgPSBhc3luYyAoKTogUHJvbWlzZTxcbiAgICBBcnJheTxDb252ZXJzYXRpb25IaXN0b3J5TWVzc2FnZUl0ZW0+XG4gID4gPT4ge1xuICAgIGNvbnN0IHF1ZXJ5ID0gYFxuICAgICAgICBxdWVyeSBMaXN0TWVzc2FnZXMoJGZpbHRlcjogJHt0aGlzLmV2ZW50Lm1lc3NhZ2VIaXN0b3J5UXVlcnkubGlzdFF1ZXJ5SW5wdXRUeXBlTmFtZX0hLCAkbGltaXQ6IEludCkge1xuICAgICAgICAgICAgJHt0aGlzLmV2ZW50Lm1lc3NhZ2VIaXN0b3J5UXVlcnkubGlzdFF1ZXJ5TmFtZX0oZmlsdGVyOiAkZmlsdGVyLCBsaW1pdDogJGxpbWl0KSB7XG4gICAgICAgICAgICAgIGl0ZW1zIHtcbiAgICAgICAgICAgICAgICAke21lc3NhZ2VJdGVtU2VsZWN0aW9uU2V0fVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBgO1xuICAgIGNvbnN0IHZhcmlhYmxlczogTGlzdFF1ZXJ5SW5wdXQgPSB7XG4gICAgICBmaWx0ZXI6IHtcbiAgICAgICAgY29udmVyc2F0aW9uSWQ6IHtcbiAgICAgICAgICBlcTogdGhpcy5ldmVudC5jb252ZXJzYXRpb25JZCxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICBsaW1pdDogdGhpcy5ldmVudC5tZXNzYWdlSGlzdG9yeVF1ZXJ5Lmxpc3RRdWVyeUxpbWl0ID8/IDEwMDAsXG4gICAgfTtcblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5ncmFwaHFsUmVxdWVzdEV4ZWN1dG9yLmV4ZWN1dGVHcmFwaHFsPFxuICAgICAgTGlzdFF1ZXJ5SW5wdXQsXG4gICAgICBMaXN0UXVlcnlPdXRwdXRcbiAgICA+KHtcbiAgICAgIHF1ZXJ5LFxuICAgICAgdmFyaWFibGVzLFxuICAgIH0pO1xuXG4gICAgY29uc3QgaXRlbXMgPVxuICAgICAgcmVzcG9uc2UuZGF0YVt0aGlzLmV2ZW50Lm1lc3NhZ2VIaXN0b3J5UXVlcnkubGlzdFF1ZXJ5TmFtZV0uaXRlbXM7XG5cbiAgICBpdGVtcy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICBpdGVtLmNvbnRlbnQ/LmZvckVhY2goKGNvbnRlbnRCbG9jaykgPT4ge1xuICAgICAgICBsZXQgcHJvcGVydHk6IGtleW9mIHR5cGVvZiBjb250ZW50QmxvY2s7XG4gICAgICAgIGZvciAocHJvcGVydHkgaW4gY29udGVudEJsb2NrKSB7XG4gICAgICAgICAgLy8gRGVzZXJpYWxpemF0aW9uIG9mIEdyYXBoUWwgcXVlcnkgcmVzdWx0IHNldHMgdGhlc2UgcHJvcGVydGllcyB0byAnbnVsbCdcbiAgICAgICAgICAvLyBUaGlzIGNhbiB0cmlnZ2VyIEJlZHJvY2sgU0RLIHZhbGlkYXRpb24gYXMgaXQgZXhwZWN0cyAndW5kZWZpbmVkJyBpZiBwcm9wZXJ0aWVzIGFyZSBub3Qgc2V0LlxuICAgICAgICAgIC8vIFdlIGNhbid0IGZpeCBob3cgR3JhcGhRbCByZXNwb25zZSBpcyBkZXNlcmlhbGl6ZWQuXG4gICAgICAgICAgLy8gVGhlcmVmb3JlLCB3ZSBhcHBseSB0aGlzIHRyYW5zZm9ybWF0aW9uIHRvIGZpeCB0aGUgZGF0YS5cbiAgICAgICAgICBpZiAoY29udGVudEJsb2NrW3Byb3BlcnR5XSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGVudEJsb2NrW3Byb3BlcnR5XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnRCbG9jay50b29sVXNlPy5pbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAvLyB0b29sVXNlLmlucHV0IG1heSBjb21lIGFzIHNlcmlhbGl6ZWQgSlNPTiBmb3IgQ2xpZW50IFRvb2xzLlxuICAgICAgICAgIC8vIFBhcnNlIGl0IGluIHRoYXQgY2FzZS5cbiAgICAgICAgICBjb250ZW50QmxvY2sudG9vbFVzZS5pbnB1dCA9IEpTT04ucGFyc2UoY29udGVudEJsb2NrLnRvb2xVc2UuaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250ZW50QmxvY2sudG9vbFJlc3VsdD8uY29udGVudCkge1xuICAgICAgICAgIGNvbnRlbnRCbG9jay50b29sUmVzdWx0LmNvbnRlbnQuZm9yRWFjaCgodG9vbFJlc3VsdENvbnRlbnRCbG9jaykgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0b29sUmVzdWx0Q29udGVudEJsb2NrLmpzb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIC8vIHRvb2xSZXN1bHQuY29udGVudFtdLmpzb24gbWF5IGNvbWUgYXMgc2VyaWFsaXplZCBKU09OIGZvciBDbGllbnQgVG9vbHMuXG4gICAgICAgICAgICAgIC8vIFBhcnNlIGl0IGluIHRoYXQgY2FzZS5cbiAgICAgICAgICAgICAgdG9vbFJlc3VsdENvbnRlbnRCbG9jay5qc29uID0gSlNPTi5wYXJzZShcbiAgICAgICAgICAgICAgICB0b29sUmVzdWx0Q29udGVudEJsb2NrLmpzb25cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gaXRlbXM7XG4gIH07XG59XG4iXX0=