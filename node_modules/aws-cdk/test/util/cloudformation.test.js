"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const cx_api_1 = require("@aws-cdk/cx-api");
const client_cloudformation_1 = require("@aws-sdk/client-cloudformation");
const mock_sdk_1 = require("./mock-sdk");
const deployments_1 = require("../../lib/api/deployments");
const PARAM = 'TheParameter';
const DEFAULT = 'TheDefault';
const OVERRIDE = 'TheOverride';
const USE_OVERRIDE = { ParameterKey: PARAM, ParameterValue: OVERRIDE };
const USE_PREVIOUS = { ParameterKey: PARAM, UsePreviousValue: true };
let cfn;
beforeEach(async () => {
    cfn = new mock_sdk_1.MockSdk().cloudFormation();
});
test('A non-existent stack pretends to have an empty template', async () => {
    // GIVEN
    mock_sdk_1.mockCloudFormationClient.on(client_cloudformation_1.DescribeStacksCommand).resolves({
        Stacks: [],
    });
    // WHEN
    const stack = await deployments_1.CloudFormationStack.lookup(cfn, 'Dummy');
    // THEN
    expect(await stack.template()).toEqual({});
});
test("Retrieving a processed template passes 'Processed' to CloudFormation", async () => {
    // GIVEN
    mock_sdk_1.mockCloudFormationClient
        .on(client_cloudformation_1.DescribeStacksCommand)
        .resolves({
        Stacks: [
            {
                StackName: 'Dummy',
                StackStatus: client_cloudformation_1.StackStatus.CREATE_COMPLETE,
                CreationTime: new Date(),
            },
        ],
    })
        .on(client_cloudformation_1.GetTemplateCommand)
        .resolves({
        TemplateBody: '',
    });
    // WHEN
    const retrieveProcessedTemplate = true;
    const cloudFormationStack = await deployments_1.CloudFormationStack.lookup(cfn, 'Dummy', retrieveProcessedTemplate);
    await cloudFormationStack.template();
    // THEN
    expect(mock_sdk_1.mockCloudFormationClient).toHaveReceivedCommandWith(client_cloudformation_1.GetTemplateCommand, {
        StackName: 'Dummy',
        TemplateStage: 'Processed',
    });
});
test.each([
    [false, false],
    [false, true],
    [true, false],
    [true, true],
])('given override, always use the override (parameter has a default: %p, parameter previously supplied: %p)', (haveDefault, havePrevious) => {
    expect(makeParams(haveDefault, havePrevious, true)).toEqual({
        apiParameters: [USE_OVERRIDE],
        changed: true,
    });
});
test('no default, no prev, no override => error', () => {
    expect(() => makeParams(false, false, false)).toThrow(/missing a value: TheParameter/);
});
test('no default, yes prev, no override => use previous', () => {
    expect(makeParams(false, true, false)).toEqual({
        apiParameters: [USE_PREVIOUS],
        changed: false,
    });
});
test('default, no prev, no override => empty param set (and obviously changes to be applied)', () => {
    expect(makeParams(true, false, false)).toEqual({
        apiParameters: [],
        changed: true,
    });
});
test('default, prev, no override => use previous', () => {
    expect(makeParams(true, true, false)).toEqual({
        apiParameters: [USE_PREVIOUS],
        changed: false,
    });
});
test('if a parameter is retrieved from SSM, the parameters always count as changed', () => {
    const params = deployments_1.TemplateParameters.fromTemplate({
        Parameters: {
            Foo: {
                Type: 'AWS::SSM::Parameter::Name',
                Default: '/Some/Key',
            },
        },
    });
    const oldValues = { Foo: '/Some/Key' };
    // If we don't pass a new value
    expect(params.updateExisting({}, oldValues).hasChanges(oldValues)).toEqual('ssm');
    // If we do pass a new value but it's the same as the old one
    expect(params.updateExisting({ Foo: '/Some/Key' }, oldValues).hasChanges(oldValues)).toEqual('ssm');
});
test('if a parameter is retrieved from SSM, the parameters doesnt count as changed if it has the magic marker', () => {
    const params = deployments_1.TemplateParameters.fromTemplate({
        Parameters: {
            Foo: {
                Type: 'AWS::SSM::Parameter::Name',
                Default: '/Some/Key',
                Description: `blabla ${cx_api_1.SSMPARAM_NO_INVALIDATE}`,
            },
        },
    });
    const oldValues = { Foo: '/Some/Key' };
    // If we don't pass a new value
    expect(params.updateExisting({}, oldValues).hasChanges(oldValues)).toEqual(false);
    // If we do pass a new value but it's the same as the old one
    expect(params.updateExisting({ Foo: '/Some/Key' }, oldValues).hasChanges(oldValues)).toEqual(false);
    // If we do pass a new value and it's different
    expect(params.updateExisting({ Foo: '/OTHER/Key' }, oldValues).hasChanges(oldValues)).toEqual(true);
});
test('empty string is a valid update value', () => {
    const params = deployments_1.TemplateParameters.fromTemplate({
        Parameters: {
            Foo: { Type: 'String', Default: 'Foo' },
        },
    });
    expect(params.updateExisting({ Foo: '' }, { Foo: 'ThisIsOld' }).apiParameters).toEqual([
        { ParameterKey: 'Foo', ParameterValue: '' },
    ]);
});
test('unknown parameter in overrides, pass it anyway', () => {
    // Not sure if we really want this. It seems like it would be nice
    // to not pass parameters that aren't expected, given that CFN will
    // just error out. But maybe we want to be warned of typos...
    const params = deployments_1.TemplateParameters.fromTemplate({
        Parameters: {
            Foo: { Type: 'String', Default: 'Foo' },
        },
    });
    expect(params.updateExisting({ Bar: 'Bar' }, {}).apiParameters).toEqual([
        { ParameterKey: 'Bar', ParameterValue: 'Bar' },
    ]);
});
test('if an unsupplied parameter reverts to its default, it can still be dirty', () => {
    // GIVEN
    const templateParams = deployments_1.TemplateParameters.fromTemplate({
        Parameters: {
            Foo: { Type: 'String', Default: 'Foo' },
        },
    });
    // WHEN
    const stackParams = templateParams.supplyAll({});
    // THEN
    expect(stackParams.hasChanges({ Foo: 'NonStandard' })).toEqual(true);
    expect(stackParams.hasChanges({ Foo: 'Foo' })).toEqual(false);
});
function makeParams(defaultValue, hasPrevValue, override) {
    const params = deployments_1.TemplateParameters.fromTemplate({
        Parameters: {
            [PARAM]: {
                Type: 'String',
                Default: defaultValue ? DEFAULT : undefined,
            },
        },
    });
    const prevParams = hasPrevValue ? { [PARAM]: 'Foo' } : {};
    const stackParams = params.updateExisting({ [PARAM]: override ? OVERRIDE : undefined }, prevParams);
    return { apiParameters: stackParams.apiParameters, changed: stackParams.hasChanges(prevParams) };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xvdWRmb3JtYXRpb24udGVzdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNsb3VkZm9ybWF0aW9uLnRlc3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSw0Q0FBeUQ7QUFDekQsMEVBQXdHO0FBQ3hHLHlDQUErRDtBQUUvRCwyREFBb0Y7QUFFcEYsTUFBTSxLQUFLLEdBQUcsY0FBYyxDQUFDO0FBQzdCLE1BQU0sT0FBTyxHQUFHLFlBQVksQ0FBQztBQUM3QixNQUFNLFFBQVEsR0FBRyxhQUFhLENBQUM7QUFFL0IsTUFBTSxZQUFZLEdBQUcsRUFBRSxZQUFZLEVBQUUsS0FBSyxFQUFFLGNBQWMsRUFBRSxRQUFRLEVBQUUsQ0FBQztBQUN2RSxNQUFNLFlBQVksR0FBRyxFQUFFLFlBQVksRUFBRSxLQUFLLEVBQUUsZ0JBQWdCLEVBQUUsSUFBSSxFQUFFLENBQUM7QUFFckUsSUFBSSxHQUEwQixDQUFDO0FBRS9CLFVBQVUsQ0FBQyxLQUFLLElBQUksRUFBRTtJQUNwQixHQUFHLEdBQUcsSUFBSSxrQkFBTyxFQUFFLENBQUMsY0FBYyxFQUFFLENBQUM7QUFDdkMsQ0FBQyxDQUFDLENBQUM7QUFFSCxJQUFJLENBQUMseURBQXlELEVBQUUsS0FBSyxJQUFJLEVBQUU7SUFDekUsUUFBUTtJQUNSLG1DQUF3QixDQUFDLEVBQUUsQ0FBQyw2Q0FBcUIsQ0FBQyxDQUFDLFFBQVEsQ0FBQztRQUMxRCxNQUFNLEVBQUUsRUFBRTtLQUNYLENBQUMsQ0FBQztJQUVILE9BQU87SUFDUCxNQUFNLEtBQUssR0FBRyxNQUFNLGlDQUFtQixDQUFDLE1BQU0sQ0FBQyxHQUFHLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFFN0QsT0FBTztJQUNQLE1BQU0sQ0FBQyxNQUFNLEtBQUssQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUM3QyxDQUFDLENBQUMsQ0FBQztBQUVILElBQUksQ0FBQyxzRUFBc0UsRUFBRSxLQUFL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R0FBMkIsWUFBWSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLEVBQUUsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztJQUNsRixNQUFNLFdBQVcsR0FBRyxNQUFNLENBQUMsY0FBYyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsU0FBUyxFQUFFLEVBQUUsVUFBVSxDQUFDLENBQUM7SUFFcEcsT0FBTyxFQUFFLGFBQWEsRUFBRSxXQUFXLENBQUMsYUFBYSxFQUFFLE9BQU8sRUFBRSxXQUFXLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUM7QUFDbkcsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNTTVBBUkFNX05PX0lOVkFMSURBVEUgfSBmcm9tICdAYXdzLWNkay9jeC1hcGknO1xuaW1wb3J0IHsgRGVzY3JpYmVTdGFja3NDb21tYW5kLCBHZXRUZW1wbGF0ZUNvbW1hbmQsIFN0YWNrU3RhdHVzIH0gZnJvbSAnQGF3cy1zZGsvY2xpZW50LWNsb3VkZm9ybWF0aW9uJztcbmltcG9ydCB7IE1vY2tTZGssIG1vY2tDbG91ZEZvcm1hdGlvbkNsaWVudCB9IGZyb20gJy4vbW9jay1zZGsnO1xuaW1wb3J0IHR5cGUgeyBJQ2xvdWRGb3JtYXRpb25DbGllbnQgfSBmcm9tICcuLi8uLi9saWIvYXBpL2F3cy1hdXRoJztcbmltcG9ydCB7IENsb3VkRm9ybWF0aW9uU3RhY2ssIFRlbXBsYXRlUGFyYW1ldGVycyB9IGZyb20gJy4uLy4uL2xpYi9hcGkvZGVwbG95bWVudHMnO1xuXG5jb25zdCBQQVJBTSA9ICdUaGVQYXJhbWV0ZXInO1xuY29uc3QgREVGQVVMVCA9ICdUaGVEZWZhdWx0JztcbmNvbnN0IE9WRVJSSURFID0gJ1RoZU92ZXJyaWRlJztcblxuY29uc3QgVVNFX09WRVJSSURFID0geyBQYXJhbWV0ZXJLZXk6IFBBUkFNLCBQYXJhbWV0ZXJWYWx1ZTogT1ZFUlJJREUgfTtcbmNvbnN0IFVTRV9QUkVWSU9VUyA9IHsgUGFyYW1ldGVyS2V5OiBQQVJBTSwgVXNlUHJldmlvdXNWYWx1ZTogdHJ1ZSB9O1xuXG5sZXQgY2ZuOiBJQ2xvdWRGb3JtYXRpb25DbGllbnQ7XG5cbmJlZm9yZUVhY2goYXN5bmMgKCkgPT4ge1xuICBjZm4gPSBuZXcgTW9ja1NkaygpLmNsb3VkRm9ybWF0aW9uKCk7XG59KTtcblxudGVzdCgnQSBub24tZXhpc3RlbnQgc3RhY2sgcHJldGVuZHMgdG8gaGF2ZSBhbiBlbXB0eSB0ZW1wbGF0ZScsIGFzeW5jICgpID0+IHtcbiAgLy8gR0lWRU5cbiAgbW9ja0Nsb3VkRm9ybWF0aW9uQ2xpZW50Lm9uKERlc2NyaWJlU3RhY2tzQ29tbWFuZCkucmVzb2x2ZXMoe1xuICAgIFN0YWNrczogW10sXG4gIH0pO1xuXG4gIC8vIFdIRU5cbiAgY29uc3Qgc3RhY2sgPSBhd2FpdCBDbG91ZEZvcm1hdGlvblN0YWNrLmxvb2t1cChjZm4sICdEdW1teScpO1xuXG4gIC8vIFRIRU5cbiAgZXhwZWN0KGF3YWl0IHN0YWNrLnRlbXBsYXRlKCkpLnRvRXF1YWwoe30pO1xufSk7XG5cbnRlc3QoXCJSZXRyaWV2aW5nIGEgcHJvY2Vzc2VkIHRlbXBsYXRlIHBhc3NlcyAnUHJvY2Vzc2VkJyB0byBDbG91ZEZvcm1hdGlvblwiLCBhc3luYyAoKSA9PiB7XG4gIC8vIEdJVkVOXG4gIG1vY2tDbG91ZEZvcm1hdGlvbkNsaWVudFxuICAgIC5vbihEZXNjcmliZVN0YWNrc0NvbW1hbmQpXG4gICAgLnJlc29sdmVzKHtcbiAgICAgIFN0YWNrczogW1xuICAgICAgICB7XG4gICAgICAgICAgU3RhY2tOYW1lOiAnRHVtbXknLFxuICAgICAgICAgIFN0YWNrU3RhdHVzOiBTdGFja1N0YXR1cy5DUkVBVEVfQ09NUExFVEUsXG4gICAgICAgICAgQ3JlYXRpb25UaW1lOiBuZXcgRGF0ZSgpLFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICB9KVxuICAgIC5vbihHZXRUZW1wbGF0ZUNvbW1hbmQpXG4gICAgLnJlc29sdmVzKHtcbiAgICAgIFRlbXBsYXRlQm9keTogJycsXG4gICAgfSk7XG5cbiAgLy8gV0hFTlxuICBjb25zdCByZXRyaWV2ZVByb2Nlc3NlZFRlbXBsYXRlID0gdHJ1ZTtcbiAgY29uc3QgY2xvdWRGb3JtYXRpb25TdGFjayA9IGF3YWl0IENsb3VkRm9ybWF0aW9uU3RhY2subG9va3VwKGNmbiwgJ0R1bW15JywgcmV0cmlldmVQcm9jZXNzZWRUZW1wbGF0ZSk7XG4gIGF3YWl0IGNsb3VkRm9ybWF0aW9uU3RhY2sudGVtcGxhdGUoKTtcblxuICAvLyBUSEVOXG4gIGV4cGVjdChtb2NrQ2xvdWRGb3JtYXRpb25DbGllbnQpLnRvSGF2ZVJlY2VpdmVkQ29tbWFuZFdpdGgoR2V0VGVtcGxhdGVDb21tYW5kLCB7XG4gICAgU3RhY2tOYW1lOiAnRHVtbXknLFxuICAgIFRlbXBsYXRlU3RhZ2U6ICdQcm9jZXNzZWQnLFxuICB9KTtcbn0pO1xuXG50ZXN0LmVhY2goW1xuICBbZmFsc2UsIGZhbHNlXSxcbiAgW2ZhbHNlLCB0cnVlXSxcbiAgW3RydWUsIGZhbHNlXSxcbiAgW3RydWUsIHRydWVdLFxuXSkoXG4gICdnaXZlbiBvdmVycmlkZSwgYWx3YXlzIHVzZSB0aGUgb3ZlcnJpZGUgKHBhcmFtZXRlciBoYXMgYSBkZWZhdWx0OiAlcCwgcGFyYW1ldGVyIHByZXZpb3VzbHkgc3VwcGxpZWQ6ICVwKScsXG4gIChoYXZlRGVmYXVsdCwgaGF2ZVByZXZpb3VzKSA9PiB7XG4gICAgZXhwZWN0KG1ha2VQYXJhbXMoaGF2ZURlZmF1bHQsIGhhdmVQcmV2aW91cywgdHJ1ZSkpLnRvRXF1YWwoe1xuICAgICAgYXBpUGFyYW1ldGVyczogW1VTRV9PVkVSUklERV0sXG4gICAgICBjaGFuZ2VkOiB0cnVlLFxuICAgIH0pO1xuICB9LFxuKTtcblxudGVzdCgnbm8gZGVmYXVsdCwgbm8gcHJldiwgbm8gb3ZlcnJpZGUgPT4gZXJyb3InLCAoKSA9PiB7XG4gIGV4cGVjdCgoKSA9PiBtYWtlUGFyYW1zKGZhbHNlLCBmYWxzZSwgZmFsc2UpKS50b1Rocm93KC9taXNzaW5nIGEgdmFsdWU6IFRoZVBhcmFtZXRlci8pO1xufSk7XG5cbnRlc3QoJ25vIGRlZmF1bHQsIHllcyBwcmV2LCBubyBvdmVycmlkZSA9PiB1c2UgcHJldmlvdXMnLCAoKSA9PiB7XG4gIGV4cGVjdChtYWtlUGFyYW1zKGZhbHNlLCB0cnVlLCBmYWxzZSkpLnRvRXF1YWwoe1xuICAgIGFwaVBhcmFtZXRlcnM6IFtVU0VfUFJFVklPVVNdLFxuICAgIGNoYW5nZWQ6IGZhbHNlLFxuICB9KTtcbn0pO1xuXG50ZXN0KCdkZWZhdWx0LCBubyBwcmV2LCBubyBvdmVycmlkZSA9PiBlbXB0eSBwYXJhbSBzZXQgKGFuZCBvYnZpb3VzbHkgY2hhbmdlcyB0byBiZSBhcHBsaWVkKScsICgpID0+IHtcbiAgZXhwZWN0KG1ha2VQYXJhbXModHJ1ZSwgZmFsc2UsIGZhbHNlKSkudG9FcXVhbCh7XG4gICAgYXBpUGFyYW1ldGVyczogW10sXG4gICAgY2hhbmdlZDogdHJ1ZSxcbiAgfSk7XG59KTtcblxudGVzdCgnZGVmYXVsdCwgcHJldiwgbm8gb3ZlcnJpZGUgPT4gdXNlIHByZXZpb3VzJywgKCkgPT4ge1xuICBleHBlY3QobWFrZVBhcmFtcyh0cnVlLCB0cnVlLCBmYWxzZSkpLnRvRXF1YWwoe1xuICAgIGFwaVBhcmFtZXRlcnM6IFtVU0VfUFJFVklPVVNdLFxuICAgIGNoYW5nZWQ6IGZhbHNlLFxuICB9KTtcbn0pO1xuXG50ZXN0KCdpZiBhIHBhcmFtZXRlciBpcyByZXRyaWV2ZWQgZnJvbSBTU00sIHRoZSBwYXJhbWV0ZXJzIGFsd2F5cyBjb3VudCBhcyBjaGFuZ2VkJywgKCkgPT4ge1xuICBjb25zdCBwYXJhbXMgPSBUZW1wbGF0ZVBhcmFtZXRlcnMuZnJvbVRlbXBsYXRlKHtcbiAgICBQYXJhbWV0ZXJzOiB7XG4gICAgICBGb286IHtcbiAgICAgICAgVHlwZTogJ0FXUzo6U1NNOjpQYXJhbWV0ZXI6Ok5hbWUnLFxuICAgICAgICBEZWZhdWx0OiAnL1NvbWUvS2V5JyxcbiAgICAgIH0sXG4gICAgfSxcbiAgfSk7XG4gIGNvbnN0IG9sZFZhbHVlcyA9IHsgRm9vOiAnL1NvbWUvS2V5JyB9O1xuXG4gIC8vIElmIHdlIGRvbid0IHBhc3MgYSBuZXcgdmFsdWVcbiAgZXhwZWN0KHBhcmFtcy51cGRhdGVFeGlzdGluZyh7fSwgb2xkVmFsdWVzKS5oYXNDaGFuZ2VzKG9sZFZhbHVlcykpLnRvRXF1YWwoJ3NzbScpO1xuXG4gIC8vIElmIHdlIGRvIHBhc3MgYSBuZXcgdmFsdWUgYnV0IGl0J3MgdGhlIHNhbWUgYXMgdGhlIG9sZCBvbmVcbiAgZXhwZWN0KHBhcmFtcy51cGRhdGVFeGlzdGluZyh7IEZvbzogJy9Tb21lL0tleScgfSwgb2xkVmFsdWVzKS5oYXNDaGFuZ2VzKG9sZFZhbHVlcykpLnRvRXF1YWwoJ3NzbScpO1xufSk7XG5cbnRlc3QoJ2lmIGEgcGFyYW1ldGVyIGlzIHJldHJpZXZlZCBmcm9tIFNTTSwgdGhlIHBhcmFtZXRlcnMgZG9lc250IGNvdW50IGFzIGNoYW5nZWQgaWYgaXQgaGFzIHRoZSBtYWdpYyBtYXJrZXInLCAoKSA9PiB7XG4gIGNvbnN0IHBhcmFtcyA9IFRlbXBsYXRlUGFyYW1ldGVycy5mcm9tVGVtcGxhdGUoe1xuICAgIFBhcmFtZXRlcnM6IHtcbiAgICAgIEZvbzoge1xuICAgICAgICBUeXBlOiAnQVdTOjpTU006OlBhcmFtZXRlcjo6TmFtZScsXG4gICAgICAgIERlZmF1bHQ6ICcvU29tZS9LZXknLFxuICAgICAgICBEZXNjcmlwdGlvbjogYGJsYWJsYSAke1NTTVBBUkFNX05PX0lOVkFMSURBVEV9YCxcbiAgICAgIH0sXG4gICAgfSxcbiAgfSk7XG4gIGNvbnN0IG9sZFZhbHVlcyA9IHsgRm9vOiAnL1NvbWUvS2V5JyB9O1xuXG4gIC8vIElmIHdlIGRvbid0IHBhc3MgYSBuZXcgdmFsdWVcbiAgZXhwZWN0KHBhcmFtcy51cGRhdGVFeGlzdGluZyh7fSwgb2xkVmFsdWVzKS5oYXNDaGFuZ2VzKG9sZFZhbHVlcykpLnRvRXF1YWwoZmFsc2UpO1xuXG4gIC8vIElmIHdlIGRvIHBhc3MgYSBuZXcgdmFsdWUgYnV0IGl0J3MgdGhlIHNhbWUgYXMgdGhlIG9sZCBvbmVcbiAgZXhwZWN0KHBhcmFtcy51cGRhdGVFeGlzdGluZyh7IEZvbzogJy9Tb21lL0tleScgfSwgb2xkVmFsdWVzKS5oYXNDaGFuZ2VzKG9sZFZhbHVlcykpLnRvRXF1YWwoZmFsc2UpO1xuXG4gIC8vIElmIHdlIGRvIHBhc3MgYSBuZXcgdmFsdWUgYW5kIGl0J3MgZGlmZmVyZW50XG4gIGV4cGVjdChwYXJhbXMudXBkYXRlRXhpc3RpbmcoeyBGb286ICcvT1RIRVIvS2V5JyB9LCBvbGRWYWx1ZXMpLmhhc0NoYW5nZXMob2xkVmFsdWVzKSkudG9FcXVhbCh0cnVlKTtcbn0pO1xuXG50ZXN0KCdlbXB0eSBzdHJpbmcgaXMgYSB2YWxpZCB1cGRhdGUgdmFsdWUnLCAoKSA9PiB7XG4gIGNvbnN0IHBhcmFtcyA9IFRlbXBsYXRlUGFyYW1ldGVycy5mcm9tVGVtcGxhdGUoe1xuICAgIFBhcmFtZXRlcnM6IHtcbiAgICAgIEZvbzogeyBUeXBlOiAnU3RyaW5nJywgRGVmYXVsdDogJ0ZvbycgfSxcbiAgICB9LFxuICB9KTtcblxuICBleHBlY3QocGFyYW1zLnVwZGF0ZUV4aXN0aW5nKHsgRm9vOiAnJyB9LCB7IEZvbzogJ1RoaXNJc09sZCcgfSkuYXBpUGFyYW1ldGVycykudG9FcXVhbChbXG4gICAgeyBQYXJhbWV0ZXJLZXk6ICdGb28nLCBQYXJhbWV0ZXJWYWx1ZTogJycgfSxcbiAgXSk7XG59KTtcblxudGVzdCgndW5rbm93biBwYXJhbWV0ZXIgaW4gb3ZlcnJpZGVzLCBwYXNzIGl0IGFueXdheScsICgpID0+IHtcbiAgLy8gTm90IHN1cmUgaWYgd2UgcmVhbGx5IHdhbnQgdGhpcy4gSXQgc2VlbXMgbGlrZSBpdCB3b3VsZCBiZSBuaWNlXG4gIC8vIHRvIG5vdCBwYXNzIHBhcmFtZXRlcnMgdGhhdCBhcmVuJ3QgZXhwZWN0ZWQsIGdpdmVuIHRoYXQgQ0ZOIHdpbGxcbiAgLy8ganVzdCBlcnJvciBvdXQuIEJ1dCBtYXliZSB3ZSB3YW50IHRvIGJlIHdhcm5lZCBvZiB0eXBvcy4uLlxuICBjb25zdCBwYXJhbXMgPSBUZW1wbGF0ZVBhcmFtZXRlcnMuZnJvbVRlbXBsYXRlKHtcbiAgICBQYXJhbWV0ZXJzOiB7XG4gICAgICBGb286IHsgVHlwZTogJ1N0cmluZycsIERlZmF1bHQ6ICdGb28nIH0sXG4gICAgfSxcbiAgfSk7XG5cbiAgZXhwZWN0KHBhcmFtcy51cGRhdGVFeGlzdGluZyh7IEJhcjogJ0JhcicgfSwge30pLmFwaVBhcmFtZXRlcnMpLnRvRXF1YWwoW1xuICAgIHsgUGFyYW1ldGVyS2V5OiAnQmFyJywgUGFyYW1ldGVyVmFsdWU6ICdCYXInIH0sXG4gIF0pO1xufSk7XG5cbnRlc3QoJ2lmIGFuIHVuc3VwcGxpZWQgcGFyYW1ldGVyIHJldmVydHMgdG8gaXRzIGRlZmF1bHQsIGl0IGNhbiBzdGlsbCBiZSBkaXJ0eScsICgpID0+IHtcbiAgLy8gR0lWRU5cbiAgY29uc3QgdGVtcGxhdGVQYXJhbXMgPSBUZW1wbGF0ZVBhcmFtZXRlcnMuZnJvbVRlbXBsYXRlKHtcbiAgICBQYXJhbWV0ZXJzOiB7XG4gICAgICBGb286IHsgVHlwZTogJ1N0cmluZycsIERlZmF1bHQ6ICdGb28nIH0sXG4gICAgfSxcbiAgfSk7XG5cbiAgLy8gV0hFTlxuICBjb25zdCBzdGFja1BhcmFtcyA9IHRlbXBsYXRlUGFyYW1zLnN1cHBseUFsbCh7fSk7XG5cbiAgLy8gVEhFTlxuICBleHBlY3Qoc3RhY2tQYXJhbXMuaGFzQ2hhbmdlcyh7IEZvbzogJ05vblN0YW5kYXJkJyB9KSkudG9FcXVhbCh0cnVlKTtcbiAgZXhwZWN0KHN0YWNrUGFyYW1zLmhhc0NoYW5nZXMoeyBGb286ICdGb28nIH0pKS50b0VxdWFsKGZhbHNlKTtcbn0pO1xuXG5mdW5jdGlvbiBtYWtlUGFyYW1zKGRlZmF1bHRWYWx1ZTogYm9vbGVhbiwgaGFzUHJldlZhbHVlOiBib29sZWFuLCBvdmVycmlkZTogYm9vbGVhbikge1xuICBjb25zdCBwYXJhbXMgPSBUZW1wbGF0ZVBhcmFtZXRlcnMuZnJvbVRlbXBsYXRlKHtcbiAgICBQYXJhbWV0ZXJzOiB7XG4gICAgICBbUEFSQU1dOiB7XG4gICAgICAgIFR5cGU6ICdTdHJpbmcnLFxuICAgICAgICBEZWZhdWx0OiBkZWZhdWx0VmFsdWUgPyBERUZBVUxUIDogdW5kZWZpbmVkLFxuICAgICAgfSxcbiAgICB9LFxuICB9KTtcbiAgY29uc3QgcHJldlBhcmFtczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IGhhc1ByZXZWYWx1ZSA/IHsgW1BBUkFNXTogJ0ZvbycgfSA6IHt9O1xuICBjb25zdCBzdGFja1BhcmFtcyA9IHBhcmFtcy51cGRhdGVFeGlzdGluZyh7IFtQQVJBTV06IG92ZXJyaWRlID8gT1ZFUlJJREUgOiB1bmRlZmluZWQgfSwgcHJldlBhcmFtcyk7XG5cbiAgcmV0dXJuIHsgYXBpUGFyYW1ldGVyczogc3RhY2tQYXJhbXMuYXBpUGFyYW1ldGVycywgY2hhbmdlZDogc3RhY2tQYXJhbXMuaGFzQ2hhbmdlcyhwcmV2UGFyYW1zKSB9O1xufVxuIl19